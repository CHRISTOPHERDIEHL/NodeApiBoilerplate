var Strategy = require('../lib/strategy')
    , chai = require('chai')
    , test_data = require('./testdata')
    , sinon = require('sinon')
    , extract_jwt = require('../lib/extract_jwt');

describe('Strategy', function() ***REMOVED***

    describe('calling JWT validation function', function() ***REMOVED***
        var strategy;

        before(function(done) ***REMOVED***
            verifyStub = sinon.stub();
            verifyStub.callsArgWith(1, null, ***REMOVED******REMOVED***, ***REMOVED******REMOVED***);
            options = ***REMOVED******REMOVED***;
            options.issuer = "TestIssuer";
            options.audience = "TestAudience";
            options.secretOrKey = 'secret';
            options.algorithms = ["HS256", "HS384"];
            options.ignoreExpiration = false;
            options.jwtFromRequest = extract_jwt.fromAuthHeader();
            strategy = new Strategy(options, verifyStub);

            Strategy.JwtVerifier = sinon.stub();
            Strategy.JwtVerifier.callsArgWith(3, null, test_data.valid_jwt.payload);

            chai.passport.use(strategy)
                .success(function(u, i) ***REMOVED***
                    done();
                ***REMOVED***)
                .req(function(req) ***REMOVED***
                    req.headers['authorization'] = "JWT " + test_data.valid_jwt.token;
                ***REMOVED***)
                .authenticate();
        ***REMOVED***);


        it('should call with the right secret as an argument', function() ***REMOVED***
            expect(Strategy.JwtVerifier.args[0][1]).to.equal('secret');
        ***REMOVED***);


        it('should call with the right issuer option', function() ***REMOVED***
            expect(Strategy.JwtVerifier.args[0][2]).to.be.an.object;
            expect(Strategy.JwtVerifier.args[0][2].issuer).to.equal('TestIssuer');
        ***REMOVED***);


        it('should call with the right audience option', function() ***REMOVED***
            expect(Strategy.JwtVerifier.args[0][2]).to.be.an.object;
            expect(Strategy.JwtVerifier.args[0][2].audience).to.equal('TestAudience');
        ***REMOVED***);

        it('should call with the right algorithms option', function() ***REMOVED***
            expect(Strategy.JwtVerifier.args[0][2]).to.be.an.object;
            expect(Strategy.JwtVerifier.args[0][2].algorithms).to.eql(["HS256", "HS384"]);
        ***REMOVED***);

        it('should call with the right ignoreExpiration option', function() ***REMOVED***
            expect(Strategy.JwtVerifier.args[0][2]).to.be.an.object;
            expect(Strategy.JwtVerifier.args[0][2].ignoreExpiration).to.be.false;
        ***REMOVED***);

    ***REMOVED***);


    describe('handling valid jwt', function() ***REMOVED***
        var strategy, payload;

        before(function(done) ***REMOVED***
            strategy = new Strategy(***REMOVED***jwtFromRequest: extract_jwt.fromAuthHeader(), secretOrKey: 'secret'***REMOVED***, function(jwt_payload, next) ***REMOVED***
                payload = jwt_payload;
                next(null, ***REMOVED******REMOVED***, ***REMOVED******REMOVED***);
            ***REMOVED***);

            // Mock successful verification
            Strategy.JwtVerifier = sinon.stub();
            Strategy.JwtVerifier.callsArgWith(3, null, test_data.valid_jwt.payload);

            chai.passport.use(strategy)
                .success(function(u, i) ***REMOVED***
                    done();
                ***REMOVED***)
                .req(function(req) ***REMOVED***
                    req.headers['authorization'] = "JWT " + test_data.valid_jwt.token;
                ***REMOVED***)
                .authenticate();
        ***REMOVED***);


        it('should call verify with the correct payload', function() ***REMOVED***
            expect(payload).to.deep.equal(test_data.valid_jwt.payload);
        ***REMOVED***);


    ***REMOVED***);


    describe('handling failing jwt', function() ***REMOVED***
        var strategy, info;
        var verify_spy = sinon.spy();

        before(function(done) ***REMOVED***

            strategy = new Strategy(***REMOVED***jwtFromRequest: extract_jwt.fromAuthHeader(), secretOrKey: 'secret'***REMOVED***, verify_spy);

            // Mock errored verification
            Strategy.JwtVerifier = sinon.stub();
            Strategy.JwtVerifier.callsArgWith(3, new Error("jwt expired"), false);

            chai.passport.use(strategy)
                .fail(function(i) ***REMOVED***
                    info = i;
                    done();
                ***REMOVED***)
                .req(function(req) ***REMOVED***
                    req.headers['authorization'] = "JWT " + test_data.valid_jwt.token;
                ***REMOVED***)
                .authenticate();
        ***REMOVED***);


        it('should not call verify', function() ***REMOVED***
            sinon.assert.notCalled(verify_spy);
        ***REMOVED***);


        it('should fail with error message.', function() ***REMOVED***
            expect(info).to.be.an.object;
            expect(info.message).to.equal('jwt expired');
        ***REMOVED***);

    ***REMOVED***);


    describe('handling an invalid authentication header', function() ***REMOVED***
        var strategy, info;
        var verify_spy = sinon.spy();

        before(function(done) ***REMOVED***

            strategy = new Strategy(***REMOVED***jwtFromRequest: extract_jwt.fromAuthHeader(), secretOrKey: 'secret'***REMOVED***, verify_spy);

            chai.passport.use(strategy)
                .fail(function(i) ***REMOVED***
                    info = i;
                    done();
                ***REMOVED***)
                .req(function(req) ***REMOVED***
                    req.headers['authorization'] = "malformed";
                ***REMOVED***)
                .authenticate();
        ***REMOVED***);


        it('should not call verify', function() ***REMOVED***
            sinon.assert.notCalled(verify_spy);
        ***REMOVED***);


        it('should fail with error message.', function() ***REMOVED***
            expect(info).to.be.an.object;
            expect(info).to.be.an.instanceof(Error);
        ***REMOVED***);

    ***REMOVED***);

***REMOVED***);
