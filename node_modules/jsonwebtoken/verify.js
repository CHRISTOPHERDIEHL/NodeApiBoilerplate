var JsonWebTokenError = require('./lib/JsonWebTokenError');
var NotBeforeError    = require('./lib/NotBeforeError');
var TokenExpiredError = require('./lib/TokenExpiredError');
var decode            = require('./decode');
var jws               = require('jws');
var ms                = require('ms');
var xtend             = require('xtend');

module.exports = function (jwtString, secretOrPublicKey, options, callback) ***REMOVED***
  if ((typeof options === 'function') && !callback) ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  if (!options) ***REMOVED***
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  //clone this object since we are going to mutate it.
  options = xtend(options);
  var done;

  if (callback) ***REMOVED***
    done = function() ***REMOVED***
      var args = Array.prototype.slice.call(arguments, 0);
      return process.nextTick(function() ***REMOVED***
        callback.apply(null, args);
      ***REMOVED***);
    ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
    done = function(err, data) ***REMOVED***
      if (err) throw err;
      return data;
    ***REMOVED***;
  ***REMOVED***

  if (!jwtString)***REMOVED***
    return done(new JsonWebTokenError('jwt must be provided'));
  ***REMOVED***

  var parts = jwtString.split('.');

  if (parts.length !== 3)***REMOVED***
    return done(new JsonWebTokenError('jwt malformed'));
  ***REMOVED***

  var hasSignature = parts[2].trim() !== '';

  if (!hasSignature && secretOrPublicKey)***REMOVED***
    return done(new JsonWebTokenError('jwt signature is required'));
  ***REMOVED***

  if (hasSignature && !secretOrPublicKey) ***REMOVED***
    return done(new JsonWebTokenError('secret or public key must be provided'));
  ***REMOVED***

  if (!hasSignature && !options.algorithms) ***REMOVED***
    options.algorithms = ['none'];
  ***REMOVED***

  if (!options.algorithms) ***REMOVED***
    options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||
                         ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ?
                          [ 'RS256','RS384','RS512','ES256','ES384','ES512' ] :
                         ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ?
                          [ 'RS256','RS384','RS512' ] :
                          [ 'HS256','HS384','HS512' ];

  ***REMOVED***

  var decodedToken;
  try ***REMOVED***
    decodedToken = jws.decode(jwtString);
  ***REMOVED*** catch(err) ***REMOVED***
    return done(new JsonWebTokenError('invalid token'));
  ***REMOVED***

  if (!decodedToken) ***REMOVED***
    return done(new JsonWebTokenError('invalid token'));
  ***REMOVED***

  var header = decodedToken.header;

  if (!~options.algorithms.indexOf(header.alg)) ***REMOVED***
    return done(new JsonWebTokenError('invalid algorithm'));
  ***REMOVED***

  var valid;

  try ***REMOVED***
    valid = jws.verify(jwtString, header.alg, secretOrPublicKey);
  ***REMOVED*** catch (e) ***REMOVED***
    return done(e);
  ***REMOVED***

  if (!valid)
    return done(new JsonWebTokenError('invalid signature'));

  var payload;

  try ***REMOVED***
    payload = decode(jwtString);
  ***REMOVED*** catch(err) ***REMOVED***
    return done(err);
  ***REMOVED***

  if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) ***REMOVED***
    if (typeof payload.nbf !== 'number') ***REMOVED***
      return done(new JsonWebTokenError('invalid nbf value'));
    ***REMOVED***
    if (payload.nbf > Math.floor(Date.now() / 1000) + (options.clockTolerance || 0)) ***REMOVED***
      return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
    ***REMOVED***
  ***REMOVED***

  if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) ***REMOVED***
    if (typeof payload.exp !== 'number') ***REMOVED***
      return done(new JsonWebTokenError('invalid exp value'));
    ***REMOVED***
    if (Math.floor(Date.now() / 1000) >= payload.exp + (options.clockTolerance || 0)) ***REMOVED***
      return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
    ***REMOVED***
  ***REMOVED***

  if (options.audience) ***REMOVED***
    var audiences = Array.isArray(options.audience)? options.audience : [options.audience];
    var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

    var match = target.some(function(aud) ***REMOVED*** return audiences.indexOf(aud) != -1; ***REMOVED***);

    if (!match)
      return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
  ***REMOVED***

  if (options.issuer) ***REMOVED***
    var invalid_issuer =
        (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
        (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

    if (invalid_issuer) ***REMOVED***
      return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
    ***REMOVED***
  ***REMOVED***

  if (options.subject) ***REMOVED***
    if (payload.sub !== options.subject) ***REMOVED***
      return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
    ***REMOVED***
  ***REMOVED***

  if (options.jwtid) ***REMOVED***
    if (payload.jti !== options.jwtid) ***REMOVED***
      return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
    ***REMOVED***
  ***REMOVED***

  if (options.maxAge) ***REMOVED***
    var maxAge = ms(options.maxAge);
    if (typeof payload.iat !== 'number') ***REMOVED***
      return done(new JsonWebTokenError('iat required when maxAge is specified'));
    ***REMOVED***
    if (Date.now() - (payload.iat * 1000) > maxAge + (options.clockTolerance || 0) * 1000) ***REMOVED***
      return done(new TokenExpiredError('maxAge exceeded', new Date(payload.iat * 1000 + maxAge)));
    ***REMOVED***
  ***REMOVED***

  return done(null, payload);
***REMOVED***;
