"use strict";

var MongoError = require('mongodb-core').MongoError

var shallowClone = function(obj) ***REMOVED***
  var copy = ***REMOVED******REMOVED***;
  for(var name in obj) copy[name] = obj[name];
  return copy;
***REMOVED***

// Set simple property
var getSingleProperty = function(obj, name, value) ***REMOVED***
  Object.defineProperty(obj, name, ***REMOVED***
    enumerable:true,
    get: function() ***REMOVED***
      return value
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

var formatSortValue = exports.formatSortValue = function(sortDirection) ***REMOVED***
  var value = ("" + sortDirection).toLowerCase();

  switch (value) ***REMOVED***
    case 'ascending':
    case 'asc':
    case '1':
      return 1;
    case 'descending':
    case 'desc':
    case '-1':
      return -1;
    default:
      throw new Error("Illegal sort clause, must be of the form "
                    + "[['field1', '(ascending|descending)'], "
                    + "['field2', '(ascending|descending)']]");
  ***REMOVED***
***REMOVED***;

var formattedOrderClause = exports.formattedOrderClause = function(sortValue) ***REMOVED***
  var orderBy = ***REMOVED******REMOVED***;
  if(sortValue == null) return null;
  if (Array.isArray(sortValue)) ***REMOVED***
    if(sortValue.length === 0) ***REMOVED***
      return null;
    ***REMOVED***

    for(var i = 0; i < sortValue.length; i++) ***REMOVED***
      if(sortValue[i].constructor == String) ***REMOVED***
        orderBy[sortValue[i]] = 1;
      ***REMOVED*** else ***REMOVED***
        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if(sortValue != null && typeof sortValue == 'object') ***REMOVED***
    orderBy = sortValue;
  ***REMOVED*** else if (typeof sortValue == 'string') ***REMOVED***
    orderBy[sortValue] = 1;
  ***REMOVED*** else ***REMOVED***
    throw new Error("Illegal sort clause, must be of the form " +
      "[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
  ***REMOVED***

  return orderBy;
***REMOVED***;

var checkCollectionName = function checkCollectionName (collectionName) ***REMOVED***
  if('string' !== typeof collectionName) ***REMOVED***
    throw Error("collection name must be a String");
  ***REMOVED***

  if(!collectionName || collectionName.indexOf('..') != -1) ***REMOVED***
    throw Error("collection names cannot be empty");
  ***REMOVED***

  if(collectionName.indexOf('$') != -1 &&
      collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) ***REMOVED***
    throw Error("collection names must not contain '$'");
  ***REMOVED***

  if(collectionName.match(/^\.|\.$/) != null) ***REMOVED***
    throw Error("collection names must not start or end with '.'");
  ***REMOVED***

  // Validate that we are not passing 0x00 in the colletion name
  if(!!~collectionName.indexOf("\x00")) ***REMOVED***
    throw new Error("collection names cannot contain a null character");
  ***REMOVED***
***REMOVED***;

var handleCallback = function(callback, err, value1, value2) ***REMOVED***
  try ***REMOVED***
    if(callback == null) return;
    if(callback) ***REMOVED***
      return value2 ? callback(err, value1, value2) :  callback(err, value1);
    ***REMOVED***
  ***REMOVED*** catch(err) ***REMOVED***
    process.nextTick(function() ***REMOVED*** throw err; ***REMOVED***);
    return false;
  ***REMOVED***

  return true;
***REMOVED***

/**
 * Wrap a Mongo error document in an Error instance
 * @ignore
 * @api private
 */
var toError = function(error) ***REMOVED***
  if (error instanceof Error) return error;

  var msg = error.err || error.errmsg || error.errMessage || error;
  var e = MongoError.create(***REMOVED***message: msg, driver:true***REMOVED***);

  // Get all object keys
  var keys = typeof error == 'object'
    ? Object.keys(error)
    : [];

  for(var i = 0; i < keys.length; i++) ***REMOVED***
    try ***REMOVED***
      e[keys[i]] = error[keys[i]];
    ***REMOVED*** catch(err) ***REMOVED***
      // continue
    ***REMOVED***
  ***REMOVED***

  return e;
***REMOVED***

/**
 * @ignore
 */
var normalizeHintField = function normalizeHintField(hint) ***REMOVED***
  var finalHint = null;

  if(typeof hint == 'string') ***REMOVED***
    finalHint = hint;
  ***REMOVED*** else if(Array.isArray(hint)) ***REMOVED***
    finalHint = ***REMOVED******REMOVED***;

    hint.forEach(function(param) ***REMOVED***
      finalHint[param] = 1;
    ***REMOVED***);
  ***REMOVED*** else if(hint != null && typeof hint == 'object') ***REMOVED***
    finalHint = ***REMOVED******REMOVED***;
    for (var name in hint) ***REMOVED***
      finalHint[name] = hint[name];
    ***REMOVED***
  ***REMOVED***

  return finalHint;
***REMOVED***;

/**
 * Create index name based on field spec
 *
 * @ignore
 * @api private
 */
var parseIndexOptions = function(fieldOrSpec) ***REMOVED***
  var fieldHash = ***REMOVED******REMOVED***;
  var indexes = [];
  var keys;

  // Get all the fields accordingly
  if('string' == typeof fieldOrSpec) ***REMOVED***
    // 'type'
    indexes.push(fieldOrSpec + '_' + 1);
    fieldHash[fieldOrSpec] = 1;
  ***REMOVED*** else if(Array.isArray(fieldOrSpec)) ***REMOVED***
    fieldOrSpec.forEach(function(f) ***REMOVED***
      if('string' == typeof f) ***REMOVED***
        // [***REMOVED***location:'2d'***REMOVED***, 'type']
        indexes.push(f + '_' + 1);
        fieldHash[f] = 1;
      ***REMOVED*** else if(Array.isArray(f)) ***REMOVED***
        // [['location', '2d'],['type', 1]]
        indexes.push(f[0] + '_' + (f[1] || 1));
        fieldHash[f[0]] = f[1] || 1;
      ***REMOVED*** else if(isObject(f)) ***REMOVED***
        // [***REMOVED***location:'2d'***REMOVED***, ***REMOVED***type:1***REMOVED***]
        keys = Object.keys(f);
        keys.forEach(function(k) ***REMOVED***
          indexes.push(k + '_' + f[k]);
          fieldHash[k] = f[k];
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        // undefined (ignore)
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED*** else if(isObject(fieldOrSpec)) ***REMOVED***
    // ***REMOVED***location:'2d', type:1***REMOVED***
    keys = Object.keys(fieldOrSpec);
    keys.forEach(function(key) ***REMOVED***
      indexes.push(key + '_' + fieldOrSpec[key]);
      fieldHash[key] = fieldOrSpec[key];
    ***REMOVED***);
  ***REMOVED***

  return ***REMOVED***
    name: indexes.join("_"), keys: keys, fieldHash: fieldHash
  ***REMOVED***
***REMOVED***

var isObject = exports.isObject = function (arg) ***REMOVED***
  return '[object Object]' == toString.call(arg)
***REMOVED***

var debugOptions = function(debugFields, options) ***REMOVED***
  var finaloptions = ***REMOVED******REMOVED***;
  debugFields.forEach(function(n) ***REMOVED***
    finaloptions[n] = options[n];
  ***REMOVED***);

  return finaloptions;
***REMOVED***

var decorateCommand = function(command, options, exclude) ***REMOVED***
  for(var name in options) ***REMOVED***
    if(exclude[name] == null) command[name] = options[name];
  ***REMOVED***

  return command;
***REMOVED***

var mergeOptions = function(target, source) ***REMOVED***
  for(var name in source) ***REMOVED***
    target[name] = source[name];
  ***REMOVED***

  return target;
***REMOVED***

// Merge options with translation
var translateOptions = function(target, source) ***REMOVED***
  var translations = ***REMOVED***
    // SSL translation options
    'sslCA': 'ca', 'sslValidate': 'rejectUnauthorized', 'sslKey': 'key', 'sslCert': 'cert', 'sslPass': 'passphrase',
    // SocketTimeout translation options
    'socketTimeoutMS': 'socketTimeout', 'connectTimeoutMS': 'connectionTimeout',
    // Replicaset options
    'replicaSet': 'setName', 'rs_name': 'setName', 'secondaryAcceptableLatencyMS': 'acceptableLatency',
    'connectWithNoPrimary': 'secondaryOnlyConnectionAllowed',
    // Mongos options
    'acceptableLatencyMS': 'localThresholdMS'
  ***REMOVED***

  for(var name in source) ***REMOVED***
    if(translations[name]) ***REMOVED***
      target[translations[name]] = source[name];
    ***REMOVED*** else ***REMOVED***
      target[name] = source[name];
    ***REMOVED***
  ***REMOVED***

  return target;
***REMOVED***

var filterOptions = function(options, names) ***REMOVED***
  var filterOptions =  ***REMOVED******REMOVED***;

  for(var name in options) ***REMOVED***
    if(names.indexOf(name) != -1) filterOptions[name] = options[name];
  ***REMOVED***

  // Filtered options
  return filterOptions;
***REMOVED***

// Object.assign method or polyfille
var assign = Object.assign ? Object.assign : function assign(target) ***REMOVED***
  if (target === undefined || target === null) ***REMOVED***
    throw new TypeError('Cannot convert first argument to object');
  ***REMOVED***

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) ***REMOVED***
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) ***REMOVED***
      continue;
    ***REMOVED***

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) ***REMOVED***
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) ***REMOVED***
        to[nextKey] = nextSource[nextKey];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return to;
***REMOVED***

exports.filterOptions = filterOptions;
exports.mergeOptions = mergeOptions;
exports.translateOptions = translateOptions;
exports.shallowClone = shallowClone;
exports.getSingleProperty = getSingleProperty;
exports.checkCollectionName = checkCollectionName;
exports.toError = toError;
exports.formattedOrderClause = formattedOrderClause;
exports.parseIndexOptions = parseIndexOptions;
exports.normalizeHintField = normalizeHintField;
exports.handleCallback = handleCallback;
exports.decorateCommand = decorateCommand;
exports.isObject = isObject;
exports.debugOptions = debugOptions;
exports.MAX_JS_INT = 0x20000000000000;
exports.assign = assign;
