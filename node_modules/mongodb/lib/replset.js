"use strict";

var EventEmitter = require('events').EventEmitter
  , inherits = require('util').inherits
  , f = require('util').format
  , Server = require('./server')
  , Cursor = require('./cursor')
  , AggregationCursor = require('./aggregation_cursor')
  , CommandCursor = require('./command_cursor')
  , ReadPreference = require('./read_preference')
  , MongoError = require('mongodb-core').MongoError
  , ServerCapabilities = require('./topology_base').ServerCapabilities
  , Store = require('./topology_base').Store
  , Define = require('./metadata')
  , CReplSet = require('mongodb-core').ReplSet
  , CoreReadPreference = require('mongodb-core').ReadPreference
  , MAX_JS_INT = require('./utils').MAX_JS_INT
  , translateOptions = require('./utils').translateOptions
  , filterOptions = require('./utils').filterOptions
  , mergeOptions = require('./utils').mergeOptions
  , os = require('os');
/**
 * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is
 * used to construct connections.
 *
 * **ReplSet Should not be used, use MongoClient.connect**
 * @example
 * var Db = require('mongodb').Db,
 *   ReplSet = require('mongodb').ReplSet,
 *   Server = require('mongodb').Server,
 *   test = require('assert');
 * // Connect using ReplSet
 * var server = new Server('localhost', 27017);
 * var db = new Db('test', new ReplSet([server]));
 * db.open(function(err, db) ***REMOVED***
 *   // Get an additional db
 *   db.close();
 * ***REMOVED***);
 */

// Allowed parameters
var legalOptionNames = ['ha', 'haInterval', 'replicaSet', 'rs_name', 'secondaryAcceptableLatencyMS'
  , 'connectWithNoPrimary', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate'
  , 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries'
  , 'store', 'auto_reconnect', 'autoReconnect', 'emitError'
  , 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'strategy', 'debug'
  , 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled'
  , 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];

// Get package.json variable
var driverVersion = require(__dirname + '/../package.json').version;
var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
var type = os.type();
var name = process.platform;
var architecture = process.arch;
var release = os.release();

/**
 * Creates a new ReplSet instance
 * @class
 * @deprecated
 * @param ***REMOVED***Server[]***REMOVED*** servers A seedlist of servers participating in the replicaset.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***booelan***REMOVED*** [options.ha=true] Turn on high availability monitoring.
 * @param ***REMOVED***number***REMOVED*** [options.haInterval=10000] Time between each replicaset status check.
 * @param ***REMOVED***string***REMOVED*** [options.replicaSet] The name of the replicaset to connect to.
 * @param ***REMOVED***number***REMOVED*** [options.secondaryAcceptableLatencyMS=15] Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)
 * @param ***REMOVED***boolean***REMOVED*** [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available
 * @param ***REMOVED***number***REMOVED*** [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***object***REMOVED*** [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***array***REMOVED*** [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***string***REMOVED*** [options.servername=null] String containing the server name requested via TLS SNI.
 * @param ***REMOVED***object***REMOVED*** [options.socketOptions=null] Socket options
 * @param ***REMOVED***boolean***REMOVED*** [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.connectTimeoutMS=10000] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @fires ReplSet#connect
 * @fires ReplSet#ha
 * @fires ReplSet#joined
 * @fires ReplSet#left
 * @fires ReplSet#fullsetup
 * @fires ReplSet#open
 * @fires ReplSet#close
 * @fires ReplSet#error
 * @fires ReplSet#timeout
 * @fires ReplSet#parseError
 * @property ***REMOVED***string***REMOVED*** parserType the parser type used (c++ or js).
 * @return ***REMOVED***ReplSet***REMOVED*** a ReplSet instance.
 */
var ReplSet = function(servers, options) ***REMOVED***
  if(!(this instanceof ReplSet)) return new ReplSet(servers, options);
  options = options || ***REMOVED******REMOVED***;
  var self = this;
  // Set up event emitter
  EventEmitter.call(this);

  // Filter the options
  options = filterOptions(options, legalOptionNames);

  // Ensure all the instances are Server
  for(var i = 0; i < servers.length; i++) ***REMOVED***
    if(!(servers[i] instanceof Server)) ***REMOVED***
      throw MongoError.create(***REMOVED***message: "all seed list instances must be of the Server type", driver:true***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  // Stored options
  var storeOptions = ***REMOVED***
      force: false
    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
  ***REMOVED***

  // Shared global store
  var store = options.store || new Store(self, storeOptions);

  // Build seed list
  var seedlist = servers.map(function(x) ***REMOVED***
    return ***REMOVED***host: x.host, port: x.port***REMOVED***
  ***REMOVED***);

  // Clone options
  var clonedOptions = mergeOptions(***REMOVED******REMOVED***, ***REMOVED***
    disconnectHandler: store,
    cursorFactory: Cursor,
    reconnect: false,
    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
    size: typeof options.poolSize == 'number' ? options.poolSize : 5
  ***REMOVED***);

  // Translate any SSL options and other connectivity options
  clonedOptions = translateOptions(clonedOptions, options);

  // Socket options
  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0
    ? options.socketOptions : options;

  // Translate all the options to the mongodb-core ones
  clonedOptions = translateOptions(clonedOptions, socketOptions);
  if(typeof clonedOptions.keepAlive == 'number') ***REMOVED***
    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
  ***REMOVED***

  // Client info
  this.clientInfo = ***REMOVED***
    driver: ***REMOVED***
      name: "nodejs",
      version: driverVersion
    ***REMOVED***,
    os: ***REMOVED***
      type: type,
      name: name,
      architecture: architecture,
      version: release
    ***REMOVED***,
    platform: nodejsversion
  ***REMOVED***

  // Build default client information
  clonedOptions.clientInfo = this.clientInfo;
  // Do we have an application specific string
  if(options.appname) ***REMOVED***
    clonedOptions.clientInfo.application = ***REMOVED*** name: options.appname ***REMOVED***;
  ***REMOVED***

  // Create the ReplSet
  var replset = new CReplSet(seedlist, clonedOptions);

  // Listen to reconnect event
  replset.on('reconnect', function() ***REMOVED***
    self.emit('reconnect');
    store.execute();
  ***REMOVED***);

  // Internal state
  this.s = ***REMOVED***
    // Replicaset
    replset: replset
    // Server capabilities
    , sCapabilities: null
    // Debug tag
    , tag: options.tag
    // Store options
    , storeOptions: storeOptions
    // Cloned options
    , clonedOptions: clonedOptions
    // Store
    , store: store
    // Options
    , options: options
  ***REMOVED***

  // Debug
  if(clonedOptions.debug) ***REMOVED***
    // Last ismaster
    Object.defineProperty(this, 'replset', ***REMOVED***
      enumerable:true, get: function() ***REMOVED*** return replset; ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * @ignore
 */
inherits(ReplSet, EventEmitter);

// Last ismaster
Object.defineProperty(ReplSet.prototype, 'isMasterDoc', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.replset.lastIsMaster(); ***REMOVED***
***REMOVED***);

Object.defineProperty(ReplSet.prototype, 'parserType', ***REMOVED***
  enumerable:true, get: function() ***REMOVED***
    return this.s.replset.parserType;
  ***REMOVED***
***REMOVED***);

// BSON property
Object.defineProperty(ReplSet.prototype, 'bson', ***REMOVED***
  enumerable: true, get: function() ***REMOVED***
    return this.s.replset.s.bson;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(ReplSet.prototype, 'haInterval', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.replset.s.haInterval; ***REMOVED***
***REMOVED***);

var define = ReplSet.define = new Define('ReplSet', ReplSet, false);

// Ensure the right read Preference object
var translateReadPreference = function(options) ***REMOVED***
  if(typeof options.readPreference == 'string') ***REMOVED***
    options.readPreference = new CoreReadPreference(options.readPreference);
  ***REMOVED*** else if(options.readPreference instanceof ReadPreference) ***REMOVED***
    options.readPreference = new CoreReadPreference(options.readPreference.mode
      , options.readPreference.tags, ***REMOVED***maxStalenessSeconds: options.readPreference.maxStalenessSeconds***REMOVED***);
  ***REMOVED***

  return options;
***REMOVED***

// Connect method
ReplSet.prototype.connect = function(db, _options, callback) ***REMOVED***
  var self = this;
  if('function' === typeof _options) callback = _options, _options = ***REMOVED******REMOVED***;
  if(_options == null) _options = ***REMOVED******REMOVED***;
  if(!('function' === typeof callback)) callback = null;
  self.s.options = _options;

  // Update bufferMaxEntries
  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;

  // Actual handler
  var errorHandler = function(event) ***REMOVED***
    return function(err) ***REMOVED***
      if(event != 'error') ***REMOVED***
        self.emit(event, err);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Connect handler
  var connectHandler = function() ***REMOVED***
    // Clear out all the current handlers left over
    ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
      'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
      'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) ***REMOVED***
      self.s.replset.removeAllListeners(e);
    ***REMOVED***);

    // Set up listeners
    self.s.replset.once('timeout', errorHandler('timeout'));
    self.s.replset.once('error', errorHandler('error'));
    self.s.replset.once('close', errorHandler('close'));

    // relay the event
    var relay = function(event) ***REMOVED***
      return function(t, server) ***REMOVED***
        self.emit(event, t, server);
      ***REMOVED***
    ***REMOVED***

    // Replset events relay
    var replsetRelay = function(event) ***REMOVED***
      return function(t, server) ***REMOVED***
        self.emit(event, t, server.lastIsMaster(), server);
      ***REMOVED***
    ***REMOVED***

    // Relay ha
    var relayHa = function(t, state) ***REMOVED***
      self.emit('ha', t, state);

      if(t == 'start') ***REMOVED***
        self.emit('ha_connect', t, state);
      ***REMOVED*** else if(t == 'end') ***REMOVED***
        self.emit('ha_ismaster', t, state);
      ***REMOVED***
    ***REMOVED***

    // Set up serverConfig listeners
    self.s.replset.on('joined', replsetRelay('joined'));
    self.s.replset.on('left', relay('left'));
    self.s.replset.on('ping', relay('ping'));
    self.s.replset.on('ha', relayHa);

    // Set up SDAM listeners
    self.s.replset.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
    self.s.replset.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
    self.s.replset.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
    self.s.replset.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
    self.s.replset.on('serverOpening', relay('serverOpening'));
    self.s.replset.on('serverClosed', relay('serverClosed'));
    self.s.replset.on('topologyOpening', relay('topologyOpening'));
    self.s.replset.on('topologyClosed', relay('topologyClosed'));
    self.s.replset.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));

    self.s.replset.on('fullsetup', function() ***REMOVED***
      self.emit('fullsetup', null, self);
    ***REMOVED***);

    self.s.replset.on('all', function() ***REMOVED***
      self.emit('all', null, self);
    ***REMOVED***);

    // Emit open event
    self.emit('open', null, self);

    // Return correctly
    try ***REMOVED***
      callback(null, self);
    ***REMOVED*** catch(err) ***REMOVED***
      process.nextTick(function() ***REMOVED*** throw err; ***REMOVED***)
    ***REMOVED***
  ***REMOVED***

  // Error handler
  var connectErrorHandler = function() ***REMOVED***
    return function(err) ***REMOVED***
      ['timeout', 'error', 'close'].forEach(function(e) ***REMOVED***
        self.s.replset.removeListener(e, connectErrorHandler);
      ***REMOVED***);

      self.s.replset.removeListener('connect', connectErrorHandler);
      // Destroy the replset
      self.s.replset.destroy();

      // Try to callback
      try ***REMOVED***
        callback(err);
      ***REMOVED*** catch(err) ***REMOVED***
        if(!self.s.replset.isConnected())
          process.nextTick(function() ***REMOVED*** throw err; ***REMOVED***)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Set up listeners
  self.s.replset.once('timeout', connectErrorHandler('timeout'));
  self.s.replset.once('error', connectErrorHandler('error'));
  self.s.replset.once('close', connectErrorHandler('close'));
  self.s.replset.once('connect', connectHandler);

  // Start connection
  self.s.replset.connect(_options);
***REMOVED***

// Server capabilities
ReplSet.prototype.capabilities = function() ***REMOVED***
  if(this.s.sCapabilities) return this.s.sCapabilities;
  if(this.s.replset.lastIsMaster() == null) return null;
  this.s.sCapabilities = new ServerCapabilities(this.s.replset.lastIsMaster());
  return this.s.sCapabilities;
***REMOVED***

define.classMethod('capabilities', ***REMOVED***callback: false, promise:false, returns: [ServerCapabilities]***REMOVED***);

// Command
ReplSet.prototype.command = function(ns, cmd, options, callback) ***REMOVED***
  options = translateReadPreference(options);
  this.s.replset.command(ns, cmd, options, callback);
***REMOVED***

define.classMethod('command', ***REMOVED***callback: true, promise:false***REMOVED***);

// Insert
ReplSet.prototype.insert = function(ns, ops, options, callback) ***REMOVED***
  this.s.replset.insert(ns, ops, options, callback);
***REMOVED***

define.classMethod('insert', ***REMOVED***callback: true, promise:false***REMOVED***);

// Update
ReplSet.prototype.update = function(ns, ops, options, callback) ***REMOVED***
  this.s.replset.update(ns, ops, options, callback);
***REMOVED***

define.classMethod('update', ***REMOVED***callback: true, promise:false***REMOVED***);

// Remove
ReplSet.prototype.remove = function(ns, ops, options, callback) ***REMOVED***
  this.s.replset.remove(ns, ops, options, callback);
***REMOVED***

define.classMethod('remove', ***REMOVED***callback: true, promise:false***REMOVED***);

// Destroyed
ReplSet.prototype.isDestroyed = function() ***REMOVED***
  return this.s.replset.isDestroyed();
***REMOVED***

// IsConnected
ReplSet.prototype.isConnected = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // If we passed in a readPreference, translate to
  // a CoreReadPreference instance
  if(options.readPreference) ***REMOVED***
    options.readPreference = translateReadPreference(options.readPreference);
  ***REMOVED***

  return this.s.replset.isConnected(options);
***REMOVED***

define.classMethod('isConnected', ***REMOVED***callback: false, promise:false, returns: [Boolean]***REMOVED***);

// Insert
ReplSet.prototype.cursor = function(ns, cmd, options) ***REMOVED***
  options = translateReadPreference(options);
  options.disconnectHandler = this.s.store;
  return this.s.replset.cursor(ns, cmd, options);
***REMOVED***

define.classMethod('cursor', ***REMOVED***callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]***REMOVED***);

ReplSet.prototype.lastIsMaster = function() ***REMOVED***
  return this.s.replset.lastIsMaster();
***REMOVED***

ReplSet.prototype.close = function(forceClosed) ***REMOVED***
  var self = this;
  this.s.replset.destroy();
  // We need to wash out all stored processes
  if(forceClosed == true) ***REMOVED***
    this.s.storeOptions.force = forceClosed;
    this.s.store.flush();
  ***REMOVED***

  var events = ['timeout', 'error', 'close', 'joined', 'left'];
  events.forEach(function(e) ***REMOVED***
    self.removeAllListeners(e);
  ***REMOVED***);
***REMOVED***

define.classMethod('close', ***REMOVED***callback: false, promise:false***REMOVED***);

ReplSet.prototype.auth = function() ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  this.s.replset.auth.apply(this.s.replset, args);
***REMOVED***

define.classMethod('auth', ***REMOVED***callback: true, promise:false***REMOVED***);

ReplSet.prototype.logout = function() ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  this.s.replset.logout.apply(this.s.replset, args);
***REMOVED***

define.classMethod('logout', ***REMOVED***callback: true, promise:false***REMOVED***);

/**
 * All raw connections
 * @method
 * @return ***REMOVED***array***REMOVED***
 */
ReplSet.prototype.connections = function() ***REMOVED***
  return this.s.replset.connections();
***REMOVED***

define.classMethod('connections', ***REMOVED***callback: false, promise:false, returns:[Array]***REMOVED***);

/**
 * A replset connect event, used to verify that the connection is up and running
 *
 * @event ReplSet#connect
 * @type ***REMOVED***ReplSet***REMOVED***
 */

/**
 * The replset high availability event
 *
 * @event ReplSet#ha
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The stage in the high availability event (start|end)
 * @param ***REMOVED***boolean***REMOVED*** data.norepeat This is a repeating high availability process or a single execution only
 * @param ***REMOVED***number***REMOVED*** data.id The id for this high availability request
 * @param ***REMOVED***object***REMOVED*** data.state An object containing the information about the current replicaset
 */

/**
 * A server member left the replicaset
 *
 * @event ReplSet#left
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that left (primary|secondary|arbiter)
 * @param ***REMOVED***Server***REMOVED*** server The server object that left
 */

/**
 * A server member joined the replicaset
 *
 * @event ReplSet#joined
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that joined (primary|secondary|arbiter)
 * @param ***REMOVED***Server***REMOVED*** server The server object that joined
 */

/**
 * ReplSet open event, emitted when replicaset can start processing commands.
 *
 * @event ReplSet#open
 * @type ***REMOVED***Replset***REMOVED***
 */

/**
 * ReplSet fullsetup event, emitted when all servers in the topology have been connected to.
 *
 * @event ReplSet#fullsetup
 * @type ***REMOVED***Replset***REMOVED***
 */

/**
 * ReplSet close event
 *
 * @event ReplSet#close
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * ReplSet error event, emitted if there is an error listener.
 *
 * @event ReplSet#error
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * ReplSet timeout event
 *
 * @event ReplSet#timeout
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * ReplSet parseError event
 *
 * @event ReplSet#parseError
 * @type ***REMOVED***object***REMOVED***
 */

module.exports = ReplSet;
