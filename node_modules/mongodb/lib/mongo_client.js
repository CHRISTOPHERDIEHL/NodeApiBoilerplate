"use strict";

var parse = require('./url_parser')
  , Server = require('./server')
  , Mongos = require('./mongos')
  , ReplSet = require('./replset')
  , Define = require('./metadata')
  , ReadPreference = require('./read_preference')
  , Logger = require('mongodb-core').Logger
  , MongoError = require('mongodb-core').MongoError
  , Db = require('./db')
  , f = require('util').format
  , shallowClone = require('./utils').shallowClone;

/**
 * @fileOverview The **MongoClient** class is a class that allows for making Connections to MongoDB.
 *
 * @example
 * var MongoClient = require('mongodb').MongoClient,
 *   test = require('assert');
 * // Connection url
 * var url = 'mongodb://localhost:27017/test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, db) ***REMOVED***
 *   // Get an additional db
 *   db.close();
 * ***REMOVED***);
 */

/**
 * Creates a new MongoClient instance
 * @class
 * @return ***REMOVED***MongoClient***REMOVED*** a MongoClient instance.
 */
function MongoClient() ***REMOVED***
  /**
   * The callback format for results
   * @callback MongoClient~connectCallback
   * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
   * @param ***REMOVED***Db***REMOVED*** db The connected database.
   */

  /**
   * Connect to MongoDB using a url as documented at
   *
   *  docs.mongodb.org/manual/reference/connection-string/
   *
   * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
   *
   * @method
   * @param ***REMOVED***string***REMOVED*** url The connection URI string
   * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
   * @param ***REMOVED***boolean***REMOVED*** [options.uri_decode_auth=false] Uri decode the user name and password for authentication
   * @param ***REMOVED***object***REMOVED*** [options.db=null] A hash of options to set on the db object, see **Db constructor**
   * @param ***REMOVED***object***REMOVED*** [options.server=null] A hash of options to set on the server objects, see **Server** constructor**
   * @param ***REMOVED***object***REMOVED*** [options.replSet=null] A hash of options to set on the replSet object, see **ReplSet** constructor**
   * @param ***REMOVED***object***REMOVED*** [options.mongos=null] A hash of options to set on the mongos object, see **Mongos** constructor**
   * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
   * @param ***REMOVED***MongoClient~connectCallback***REMOVED*** [callback] The command result callback
   * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
   */
  this.connect = MongoClient.connect;
***REMOVED***

var define = MongoClient.define = new Define('MongoClient', MongoClient, false);

/**
 * Connect to MongoDB using a url as documented at
 *
 *  docs.mongodb.org/manual/reference/connection-string/
 *
 * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
 *
 * @method
 * @static
 * @param ***REMOVED***string***REMOVED*** url The connection URI string
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.uri_decode_auth=false] Uri decode the user name and password for authentication
 * @param ***REMOVED***object***REMOVED*** [options.db=null] A hash of options to set on the db object, see **Db constructor**
 * @param ***REMOVED***object***REMOVED*** [options.server=null] A hash of options to set on the server objects, see **Server** constructor**
 * @param ***REMOVED***object***REMOVED*** [options.replSet=null] A hash of options to set on the replSet object, see **ReplSet** constructor**
 * @param ***REMOVED***object***REMOVED*** [options.mongos=null] A hash of options to set on the mongos object, see **Mongos** constructor**
 * @param ***REMOVED***object***REMOVED*** [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
 * @param ***REMOVED***MongoClient~connectCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
MongoClient.connect = function(url, options, callback) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1);
  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;
  options = args.length ? args.shift() : null;
  options = options || ***REMOVED******REMOVED***;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // Return a promise
  if(typeof callback != 'function') ***REMOVED***
    return new promiseLibrary(function(resolve, reject) ***REMOVED***
      connect(url, options, function(err, db) ***REMOVED***
        if(err) return reject(err);
        resolve(db);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  // Fallback to callback based connect
  connect(url, options, callback);
***REMOVED***

define.staticMethod('connect', ***REMOVED***callback: true, promise:true***REMOVED***);

var mergeOptions = function(target, source, flatten) ***REMOVED***
  for(var name in source) ***REMOVED***
    if(source[name] && typeof source[name] == 'object' && flatten) ***REMOVED***
      target = mergeOptions(target, source[name], flatten);
    ***REMOVED*** else ***REMOVED***
      target[name] = source[name];
    ***REMOVED***
  ***REMOVED***

  return target;
***REMOVED***

var createUnifiedOptions = function(finalOptions, options) ***REMOVED***
  var childOptions = ['mongos', 'server', 'db'
    , 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];
  var noMerge = [];

  for(var name in options) ***REMOVED***
    if(noMerge.indexOf(name.toLowerCase()) != -1) ***REMOVED***
      finalOptions[name] = options[name];
    ***REMOVED*** else if(childOptions.indexOf(name.toLowerCase()) != -1) ***REMOVED***
      finalOptions = mergeOptions(finalOptions, options[name], false);
    ***REMOVED*** else ***REMOVED***
      if(options[name] && typeof options[name] == 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) ***REMOVED***
        finalOptions = mergeOptions(finalOptions, options[name], true);
      ***REMOVED*** else ***REMOVED***
        finalOptions[name] = options[name];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return finalOptions;
***REMOVED***

function translateOptions(options) ***REMOVED***
  // If we have a readPreference passed in by the db options
  if(typeof options.readPreference == 'string' || typeof options.read_preference == 'string') ***REMOVED***
    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
  ***REMOVED***

  // Do we have readPreference tags, add them
  if(options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) ***REMOVED***
    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
  ***REMOVED***

  // Do we have maxStalenessSeconds
  if(options.maxStalenessSeconds) ***REMOVED***
    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
  ***REMOVED***

  // Set the socket and connection timeouts
  if(options.socketTimeoutMS == null) options.socketTimeoutMS = 30000;
  if(options.connectTimeoutMS == null) options.connectTimeoutMS = 30000;

  // Create server instances
  return options.servers.map(function(serverObj) ***REMOVED***
    return serverObj.domain_socket ?
      new Server(serverObj.domain_socket, 27017, options)
    : new Server(serverObj.host, serverObj.port, options);
  ***REMOVED***);
***REMOVED***

function createReplicaset(options, callback) ***REMOVED***
  // Set default options
  var servers = translateOptions(options);
  // Create Db instance
  new Db(options.dbName, new ReplSet(servers, options), options).open(callback);
***REMOVED***

function createMongos(options, callback) ***REMOVED***
  // Set default options
  var servers = translateOptions(options);
  // Create Db instance
  new Db(options.dbName, new Mongos(servers, options), options).open(callback);
***REMOVED***

function createServer(options, callback) ***REMOVED***
  // Set default options
  var servers = translateOptions(options);
  // Create Db instance
  new Db(options.dbName, servers[0], options).open(function(err, db) ***REMOVED***
    if(err) return callback(err);
    // Check if we are really speaking to a mongos
    var ismaster = db.serverConfig.lastIsMaster();

    // Do we actually have a mongos
    if(ismaster && ismaster.msg == 'isdbgrid') ***REMOVED***
      // Destroy the current connection
      db.close();
      // Create mongos connection instead
      return createMongos(options, callback);
    ***REMOVED***

    // Otherwise callback
    callback(err, db);
  ***REMOVED***);
***REMOVED***

function connectHandler(options, callback) ***REMOVED***
  return function (err, db) ***REMOVED***
    if(err) ***REMOVED***
      return process.nextTick(function() ***REMOVED***
        try ***REMOVED***
          callback(err, null);
        ***REMOVED*** catch (err) ***REMOVED***
          if(db) db.close();
          throw err
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    // No authentication just reconnect
    if(!options.auth) ***REMOVED***
      return process.nextTick(function() ***REMOVED***
        try ***REMOVED***
          callback(err, db);
        ***REMOVED*** catch (err) ***REMOVED***
          if(db) db.close();
          throw err
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED***

    // What db to authenticate against
    var authentication_db = db;
    if(options.authSource) ***REMOVED***
      authentication_db = db.db(options.authSource);
    ***REMOVED***

    // Authenticate
    authentication_db.authenticate(options.user, options.password, options, function(err, success)***REMOVED***
      if(success)***REMOVED***
        process.nextTick(function() ***REMOVED***
          try ***REMOVED***
            callback(null, db);
          ***REMOVED*** catch (err) ***REMOVED***
            if(db) db.close();
            throw err
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        if(db) db.close();
        process.nextTick(function() ***REMOVED***
          try ***REMOVED***
            callback(err ? err : new Error('Could not authenticate user ' + options.auth[0]), null);
          ***REMOVED*** catch (err) ***REMOVED***
            if(db) db.close();
            throw err
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/*
 * Connect using MongoClient
 */
var connect = function(url, options, callback) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  options = shallowClone(options);

  // If callback is null throw an exception
  if(callback == null) ***REMOVED***
    throw new Error("no callback function provided");
  ***REMOVED***

  // Get a logger for MongoClient
  var logger = Logger('MongoClient', options);

  // Parse the string
  var object = parse(url, options);
  var _finalOptions = createUnifiedOptions(***REMOVED******REMOVED***, object);
  _finalOptions = mergeOptions(_finalOptions, object, false);
  _finalOptions = createUnifiedOptions(_finalOptions, options);

  // Check if we have connection and socket timeout set
  if(_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 30000;
  if(_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;

  // Failure modes
  if(object.servers.length == 0) ***REMOVED***
    throw new Error("connection string must contain at least one seed host");
  ***REMOVED***

  function connectCallback(err, db) ***REMOVED***
    if(err && err.message == 'no mongos proxies found in seed list') ***REMOVED***
      if(logger.isWarn()) ***REMOVED***
        logger.warn(f('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));
      ***REMOVED***

      // Return a more specific error message for MongoClient.connect
      return callback(new MongoError('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));
    ***REMOVED***

    // Return the error and db instance
    callback(err, db);
  ***REMOVED***

  // Do we have a replicaset then skip discovery and go straight to connectivity
  if(_finalOptions.replicaSet || _finalOptions.rs_name) ***REMOVED***
    return createReplicaset(_finalOptions, connectHandler(_finalOptions, connectCallback));
  ***REMOVED*** else if(object.servers.length > 1) ***REMOVED***
    return createMongos(_finalOptions, connectHandler(_finalOptions, connectCallback));
  ***REMOVED*** else ***REMOVED***
    return createServer(_finalOptions, connectHandler(_finalOptions, connectCallback));
  ***REMOVED***
***REMOVED***

module.exports = MongoClient
