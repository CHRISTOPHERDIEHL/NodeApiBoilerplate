"use strict";

var EventEmitter = require('events').EventEmitter
  , inherits = require('util').inherits
  , f = require('util').format
  , ServerCapabilities = require('./topology_base').ServerCapabilities
  , MongoError = require('mongodb-core').MongoError
  , CMongos = require('mongodb-core').Mongos
  , Cursor = require('./cursor')
  , AggregationCursor = require('./aggregation_cursor')
  , CommandCursor = require('./command_cursor')
  , Define = require('./metadata')
  , Server = require('./server')
  , Store = require('./topology_base').Store
  , MAX_JS_INT = require('./utils').MAX_JS_INT
  , translateOptions = require('./utils').translateOptions
  , filterOptions = require('./utils').filterOptions
  , mergeOptions = require('./utils').mergeOptions
  , os = require('os');

// Get package.json variable
var driverVersion = require(__dirname + '/../package.json').version;
var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
var type = os.type();
var name = process.platform;
var architecture = process.arch;
var release = os.release();

/**
 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
 * used to construct connections.
 *
 * **Mongos Should not be used, use MongoClient.connect**
 * @example
 * var Db = require('mongodb').Db,
 *   Mongos = require('mongodb').Mongos,
 *   Server = require('mongodb').Server,
 *   test = require('assert');
 * // Connect using Mongos
 * var server = new Server('localhost', 27017);
 * var db = new Db('test', new Mongos([server]));
 * db.open(function(err, db) ***REMOVED***
 *   // Get an additional db
 *   db.close();
 * ***REMOVED***);
 */

 // Allowed parameters
 var legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS'
   , 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate'
   , 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries'
   , 'store', 'auto_reconnect', 'autoReconnect', 'emitError'
   , 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS'
   , 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled'
   , 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];

/**
 * Creates a new Mongos instance
 * @class
 * @deprecated
 * @param ***REMOVED***Server[]***REMOVED*** servers A seedlist of servers participating in the replicaset.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***booelan***REMOVED*** [options.ha=true] Turn on high availability monitoring.
 * @param ***REMOVED***number***REMOVED*** [options.haInterval=5000] Time between each replicaset status check.
 * @param ***REMOVED***number***REMOVED*** [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
 * @param ***REMOVED***number***REMOVED*** [options.acceptableLatencyMS=15] Cutoff latency point in MS for MongoS proxy selection
 * @param ***REMOVED***boolean***REMOVED*** [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
 * @param ***REMOVED***boolean|function***REMOVED*** [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
 * @param ***REMOVED***object***REMOVED*** [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***array***REMOVED*** [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***(Buffer|string)***REMOVED*** [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
 * @param ***REMOVED***string***REMOVED*** [options.servername=null] String containing the server name requested via TLS SNI.
 * @param ***REMOVED***object***REMOVED*** [options.socketOptions=null] Socket options
 * @param ***REMOVED***boolean***REMOVED*** [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
 * @param ***REMOVED***number***REMOVED*** [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
 * @param ***REMOVED***boolean***REMOVED*** [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
 * @fires Mongos#connect
 * @fires Mongos#ha
 * @fires Mongos#joined
 * @fires Mongos#left
 * @fires Mongos#fullsetup
 * @fires Mongos#open
 * @fires Mongos#close
 * @fires Mongos#error
 * @fires Mongos#timeout
 * @fires Mongos#parseError
 * @property ***REMOVED***string***REMOVED*** parserType the parser type used (c++ or js).
 * @return ***REMOVED***Mongos***REMOVED*** a Mongos instance.
 */
var Mongos = function(servers, options) ***REMOVED***
  if(!(this instanceof Mongos)) return new Mongos(servers, options);
  options = options || ***REMOVED******REMOVED***;
  var self = this;

  // Filter the options
  options = filterOptions(options, legalOptionNames);

  // Ensure all the instances are Server
  for(var i = 0; i < servers.length; i++) ***REMOVED***
    if(!(servers[i] instanceof Server)) ***REMOVED***
      throw MongoError.create(***REMOVED***message: "all seed list instances must be of the Server type", driver:true***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  // Stored options
  var storeOptions = ***REMOVED***
      force: false
    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
  ***REMOVED***

  // Shared global store
  var store = options.store || new Store(self, storeOptions);

  // Set up event emitter
  EventEmitter.call(this);

  // Build seed list
  var seedlist = servers.map(function(x) ***REMOVED***
    return ***REMOVED***host: x.host, port: x.port***REMOVED***
  ***REMOVED***);

  // Get the reconnect option
  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;

  // Clone options
  var clonedOptions = mergeOptions(***REMOVED******REMOVED***, ***REMOVED***
    disconnectHandler: store,
    cursorFactory: Cursor,
    reconnect: reconnect,
    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
    size: typeof options.poolSize == 'number' ? options.poolSize : 5
  ***REMOVED***);

  // Translate any SSL options and other connectivity options
  clonedOptions = translateOptions(clonedOptions, options);

  // Socket options
  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0
    ? options.socketOptions : options;

  // Translate all the options to the mongodb-core ones
  clonedOptions = translateOptions(clonedOptions, socketOptions);
  if(typeof clonedOptions.keepAlive == 'number') ***REMOVED***
    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
  ***REMOVED***

  // Build default client information
  this.clientInfo = ***REMOVED***
    driver: ***REMOVED***
      name: "nodejs",
      version: driverVersion
    ***REMOVED***,
    os: ***REMOVED***
      type: type,
      name: name,
      architecture: architecture,
      version: release
    ***REMOVED***,
    platform: nodejsversion
  ***REMOVED***

  // Build default client information
  clonedOptions.clientInfo = this.clientInfo;
  // Do we have an application specific string
  if(options.appname) ***REMOVED***
    clonedOptions.clientInfo.application = ***REMOVED*** name: options.appname ***REMOVED***;
  ***REMOVED***

  // Create the Mongos
  var mongos = new CMongos(seedlist, clonedOptions)
  // Server capabilities
  var sCapabilities = null;

  // Internal state
  this.s = ***REMOVED***
    // Create the Mongos
      mongos: mongos
    // Server capabilities
    , sCapabilities: sCapabilities
    // Debug turned on
    , debug: clonedOptions.debug
    // Store option defaults
    , storeOptions: storeOptions
    // Cloned options
    , clonedOptions: clonedOptions
    // Actual store of callbacks
    , store: store
    // Options
    , options: options
  ***REMOVED***
***REMOVED***

var define = Mongos.define = new Define('Mongos', Mongos, false);

/**
 * @ignore
 */
inherits(Mongos, EventEmitter);

// Last ismaster
Object.defineProperty(Mongos.prototype, 'isMasterDoc', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.mongos.lastIsMaster(); ***REMOVED***
***REMOVED***);

Object.defineProperty(Mongos.prototype, 'parserType', ***REMOVED***
  enumerable:true, get: function() ***REMOVED***
    return this.s.mongos.parserType;
  ***REMOVED***
***REMOVED***);

// BSON property
Object.defineProperty(Mongos.prototype, 'bson', ***REMOVED***
  enumerable: true, get: function() ***REMOVED***
    return this.s.mongos.s.bson;
  ***REMOVED***
***REMOVED***);

Object.defineProperty(Mongos.prototype, 'haInterval', ***REMOVED***
  enumerable:true, get: function() ***REMOVED*** return this.s.mongos.s.haInterval; ***REMOVED***
***REMOVED***);

// Connect
Mongos.prototype.connect = function(db, _options, callback) ***REMOVED***
  var self = this;
  if('function' === typeof _options) callback = _options, _options = ***REMOVED******REMOVED***;
  if(_options == null) _options = ***REMOVED******REMOVED***;
  if(!('function' === typeof callback)) callback = null;
  self.s.options = _options;

  // Update bufferMaxEntries
  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;

  // Error handler
  var connectErrorHandler = function() ***REMOVED***
    return function(err) ***REMOVED***
      // Remove all event handlers
      var events = ['timeout', 'error', 'close'];
      events.forEach(function(e) ***REMOVED***
        self.removeListener(e, connectErrorHandler);
      ***REMOVED***);

      self.s.mongos.removeListener('connect', connectErrorHandler);

      // Try to callback
      try ***REMOVED***
        callback(err);
      ***REMOVED*** catch(err) ***REMOVED***
        process.nextTick(function() ***REMOVED*** throw err; ***REMOVED***)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Actual handler
  var errorHandler = function(event) ***REMOVED***
    return function(err) ***REMOVED***
      if(event != 'error') ***REMOVED***
        self.emit(event, err);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Error handler
  var reconnectHandler = function() ***REMOVED***
    self.emit('reconnect');
    self.s.store.execute();
  ***REMOVED***

  // relay the event
  var relay = function(event) ***REMOVED***
    return function(t, server) ***REMOVED***
      self.emit(event, t, server);
    ***REMOVED***
  ***REMOVED***

  // Connect handler
  var connectHandler = function() ***REMOVED***
    // Clear out all the current handlers left over
    ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
      'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
      'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) ***REMOVED***
      self.s.mongos.removeAllListeners(e);
    ***REMOVED***);

    // Set up listeners
    self.s.mongos.once('timeout', errorHandler('timeout'));
    self.s.mongos.once('error', errorHandler('error'));
    self.s.mongos.once('close', errorHandler('close'));

    // Set up SDAM listeners
    self.s.mongos.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
    self.s.mongos.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
    self.s.mongos.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
    self.s.mongos.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
    self.s.mongos.on('serverOpening', relay('serverOpening'));
    self.s.mongos.on('serverClosed', relay('serverClosed'));
    self.s.mongos.on('topologyOpening', relay('topologyOpening'));
    self.s.mongos.on('topologyClosed', relay('topologyClosed'));
    self.s.mongos.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));

    // Set up serverConfig listeners
    self.s.mongos.on('fullsetup', relay('fullsetup'));

    // Emit open event
    self.emit('open', null, self);

    // Return correctly
    try ***REMOVED***
      callback(null, self);
    ***REMOVED*** catch(err) ***REMOVED***
      process.nextTick(function() ***REMOVED*** throw err; ***REMOVED***)
    ***REMOVED***
  ***REMOVED***

  // Set up listeners
  self.s.mongos.once('timeout', connectErrorHandler('timeout'));
  self.s.mongos.once('error', connectErrorHandler('error'));
  self.s.mongos.once('close', connectErrorHandler('close'));
  self.s.mongos.once('connect', connectHandler);
  // Join and leave events
  self.s.mongos.on('joined', relay('joined'));
  self.s.mongos.on('left', relay('left'));

  // Reconnect server
  self.s.mongos.on('reconnect', reconnectHandler);

  // Start connection
  self.s.mongos.connect(_options);
***REMOVED***

// Server capabilities
Mongos.prototype.capabilities = function() ***REMOVED***
  if(this.s.sCapabilities) return this.s.sCapabilities;
  if(this.s.mongos.lastIsMaster() == null) return null;
  this.s.sCapabilities = new ServerCapabilities(this.s.mongos.lastIsMaster());
  return this.s.sCapabilities;
***REMOVED***

define.classMethod('capabilities', ***REMOVED***callback: false, promise:false, returns: [ServerCapabilities]***REMOVED***);

// Command
Mongos.prototype.command = function(ns, cmd, options, callback) ***REMOVED***
  this.s.mongos.command(ns, cmd, options, callback);
***REMOVED***

define.classMethod('command', ***REMOVED***callback: true, promise:false***REMOVED***);

// Insert
Mongos.prototype.insert = function(ns, ops, options, callback) ***REMOVED***
  this.s.mongos.insert(ns, ops, options, function(e, m) ***REMOVED***
    callback(e, m)
  ***REMOVED***);
***REMOVED***

define.classMethod('insert', ***REMOVED***callback: true, promise:false***REMOVED***);

// Update
Mongos.prototype.update = function(ns, ops, options, callback) ***REMOVED***
  this.s.mongos.update(ns, ops, options, callback);
***REMOVED***

define.classMethod('update', ***REMOVED***callback: true, promise:false***REMOVED***);

// Remove
Mongos.prototype.remove = function(ns, ops, options, callback) ***REMOVED***
  this.s.mongos.remove(ns, ops, options, callback);
***REMOVED***

define.classMethod('remove', ***REMOVED***callback: true, promise:false***REMOVED***);

// Destroyed
Mongos.prototype.isDestroyed = function() ***REMOVED***
  return this.s.mongos.isDestroyed();
***REMOVED***

// IsConnected
Mongos.prototype.isConnected = function() ***REMOVED***
  return this.s.mongos.isConnected();
***REMOVED***

define.classMethod('isConnected', ***REMOVED***callback: false, promise:false, returns: [Boolean]***REMOVED***);

// Insert
Mongos.prototype.cursor = function(ns, cmd, options) ***REMOVED***
  options.disconnectHandler = this.s.store;
  return this.s.mongos.cursor(ns, cmd, options);
***REMOVED***

define.classMethod('cursor', ***REMOVED***callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]***REMOVED***);

Mongos.prototype.lastIsMaster = function() ***REMOVED***
  return this.s.mongos.lastIsMaster();
***REMOVED***

Mongos.prototype.close = function(forceClosed) ***REMOVED***
  this.s.mongos.destroy();
  // We need to wash out all stored processes
  if(forceClosed == true) ***REMOVED***
    this.s.storeOptions.force = forceClosed;
    this.s.store.flush();
  ***REMOVED***
***REMOVED***

define.classMethod('close', ***REMOVED***callback: false, promise:false***REMOVED***);

Mongos.prototype.auth = function() ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  this.s.mongos.auth.apply(this.s.mongos, args);
***REMOVED***

define.classMethod('auth', ***REMOVED***callback: true, promise:false***REMOVED***);

Mongos.prototype.logout = function() ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 0);
  this.s.mongos.logout.apply(this.s.mongos, args);
***REMOVED***

define.classMethod('logout', ***REMOVED***callback: true, promise:false***REMOVED***);

/**
 * All raw connections
 * @method
 * @return ***REMOVED***array***REMOVED***
 */
Mongos.prototype.connections = function() ***REMOVED***
  return this.s.mongos.connections();
***REMOVED***

define.classMethod('connections', ***REMOVED***callback: false, promise:false, returns:[Array]***REMOVED***);

/**
 * A mongos connect event, used to verify that the connection is up and running
 *
 * @event Mongos#connect
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * The mongos high availability event
 *
 * @event Mongos#ha
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The stage in the high availability event (start|end)
 * @param ***REMOVED***boolean***REMOVED*** data.norepeat This is a repeating high availability process or a single execution only
 * @param ***REMOVED***number***REMOVED*** data.id The id for this high availability request
 * @param ***REMOVED***object***REMOVED*** data.state An object containing the information about the current replicaset
 */

/**
 * A server member left the mongos set
 *
 * @event Mongos#left
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that left (primary|secondary|arbiter)
 * @param ***REMOVED***Server***REMOVED*** server The server object that left
 */

/**
 * A server member joined the mongos set
 *
 * @event Mongos#joined
 * @type ***REMOVED***function***REMOVED***
 * @param ***REMOVED***string***REMOVED*** type The type of member that joined (primary|secondary|arbiter)
 * @param ***REMOVED***Server***REMOVED*** server The server object that joined
 */

/**
 * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.
 *
 * @event Mongos#fullsetup
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * Mongos open event, emitted when mongos can start processing commands.
 *
 * @event Mongos#open
 * @type ***REMOVED***Mongos***REMOVED***
 */

/**
 * Mongos close event
 *
 * @event Mongos#close
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Mongos error event, emitted if there is an error listener.
 *
 * @event Mongos#error
 * @type ***REMOVED***MongoError***REMOVED***
 */

/**
 * Mongos timeout event
 *
 * @event Mongos#timeout
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * Mongos parseError event
 *
 * @event Mongos#parseError
 * @type ***REMOVED***object***REMOVED***
 */

module.exports = Mongos;
