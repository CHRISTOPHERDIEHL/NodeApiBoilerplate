"use strict";

var checkCollectionName = require('./utils').checkCollectionName
  , ObjectID = require('mongodb-core').BSON.ObjectID
  , Long = require('mongodb-core').BSON.Long
  , Code = require('mongodb-core').BSON.Code
  , f = require('util').format
  , AggregationCursor = require('./aggregation_cursor')
  , MongoError = require('mongodb-core').MongoError
  , shallowClone = require('./utils').shallowClone
  , isObject = require('./utils').isObject
  , toError = require('./utils').toError
  , normalizeHintField = require('./utils').normalizeHintField
  , handleCallback = require('./utils').handleCallback
  , decorateCommand = require('./utils').decorateCommand
  , formattedOrderClause = require('./utils').formattedOrderClause
  , ReadPreference = require('./read_preference')
  , CoreReadPreference = require('mongodb-core').ReadPreference
  , CommandCursor = require('./command_cursor')
  , Define = require('./metadata')
  , Cursor = require('./cursor')
  , unordered = require('./bulk/unordered')
  , ordered = require('./bulk/ordered')
  , assign = require('./utils').assign;

/**
 * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection
 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
 *
 * **COLLECTION Cannot directly be instantiated**
 * @example
 * var MongoClient = require('mongodb').MongoClient,
 *   test = require('assert');
 * // Connection url
 * var url = 'mongodb://localhost:27017/test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, db) ***REMOVED***
 *   // Create a collection we want to drop later
 *   var col = db.collection('createIndexExample1');
 *   // Show that duplicate records got dropped
 *   col.find(***REMOVED******REMOVED***).toArray(function(err, items) ***REMOVED***
 *     test.equal(null, err);
 *     test.equal(4, items.length);
 *     db.close();
 *   ***REMOVED***);
 * ***REMOVED***);
 */

/**
 * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @property ***REMOVED***string***REMOVED*** collectionName Get the collection name.
 * @property ***REMOVED***string***REMOVED*** namespace Get the full collection namespace.
 * @property ***REMOVED***object***REMOVED*** writeConcern The current write concern values.
 * @property ***REMOVED***object***REMOVED*** readConcern The current read concern values.
 * @property ***REMOVED***object***REMOVED*** hint Get current index hint for collection.
 * @return ***REMOVED***Collection***REMOVED*** a Collection instance.
 */
var Collection = function(db, topology, dbName, name, pkFactory, options) ***REMOVED***
  checkCollectionName(name);

  // Unpack variables
  var internalHint = null;
  var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
  var serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;
  var raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
  var promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;
  var promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;
  var promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;
  var readPreference = null;
  var collectionHint = null;
  var namespace = f("%s.%s", dbName, name);

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // Assign the right collection level readPreference
  if(options && options.readPreference) ***REMOVED***
    readPreference = options.readPreference;
  ***REMOVED*** else if(db.options.readPreference) ***REMOVED***
    readPreference = db.options.readPreference;
  ***REMOVED***

  // Set custom primary key factory if provided
  pkFactory = pkFactory == null
    ? ObjectID
    : pkFactory;

  // Internal state
  this.s = ***REMOVED***
    // Set custom primary key factory if provided
      pkFactory: pkFactory
    // Db
    , db: db
    // Topology
    , topology: topology
    // dbName
    , dbName: dbName
    // Options
    , options: options
    // Namespace
    , namespace: namespace
    // Read preference
    , readPreference: readPreference
    // SlaveOK
    , slaveOk: slaveOk
    // Serialize functions
    , serializeFunctions: serializeFunctions
    // Raw
    , raw: raw
    // promoteLongs
    , promoteLongs: promoteLongs
    // promoteValues
    , promoteValues: promoteValues
    // promoteBuffers
    , promoteBuffers: promoteBuffers
    // internalHint
    , internalHint: internalHint
    // collectionHint
    , collectionHint: collectionHint
    // Name
    , name: name
    // Promise library
    , promiseLibrary: promiseLibrary
    // Read Concern
    , readConcern: options.readConcern
  ***REMOVED***
***REMOVED***

var define = Collection.define = new Define('Collection', Collection, false);

Object.defineProperty(Collection.prototype, 'collectionName', ***REMOVED***
  enumerable: true, get: function() ***REMOVED*** return this.s.name; ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'namespace', ***REMOVED***
  enumerable: true, get: function() ***REMOVED*** return this.s.namespace; ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'readConcern', ***REMOVED***
  enumerable: true, get: function() ***REMOVED*** return this.s.readConcern || ***REMOVED***level: 'local'***REMOVED***; ***REMOVED***
***REMOVED***);

Object.defineProperty(Collection.prototype, 'writeConcern', ***REMOVED***
  enumerable:true,
  get: function() ***REMOVED***
    var ops = ***REMOVED******REMOVED***;
    if(this.s.options.w != null) ops.w = this.s.options.w;
    if(this.s.options.j != null) ops.j = this.s.options.j;
    if(this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
    if(this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
    return ops;
  ***REMOVED***
***REMOVED***);

/**
 * @ignore
 */
Object.defineProperty(Collection.prototype, "hint", ***REMOVED***
    enumerable: true
  , get: function () ***REMOVED*** return this.s.collectionHint; ***REMOVED***
  , set: function (v) ***REMOVED*** this.s.collectionHint = normalizeHintField(v); ***REMOVED***
***REMOVED***);

/**
 * Creates a cursor for a query that can be used to iterate over results from MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** query The cursor query object.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Cursor***REMOVED***
 */
Collection.prototype.find = function() ***REMOVED***
  var options
    , args = Array.prototype.slice.call(arguments, 0)
    , has_callback = typeof args[args.length - 1] === 'function'
    , has_weird_callback = typeof args[0] === 'function'
    , callback = has_callback ? args.pop() : (has_weird_callback ? args.shift() : null)
    , len = args.length
    , selector = len >= 1 ? args[0] : ***REMOVED******REMOVED***
    , fields = len >= 2 ? args[1] : undefined;

  if(len === 1 && has_weird_callback) ***REMOVED***
    // backwards compat for callback?, options case
    selector = ***REMOVED******REMOVED***;
    options = args[0];
  ***REMOVED***

  if(len === 2 && fields !== undefined && !Array.isArray(fields)) ***REMOVED***
    var fieldKeys = Object.keys(fields);
    var is_option = false;

    for(var i = 0; i < fieldKeys.length; i++) ***REMOVED***
      if(testForFields[fieldKeys[i]] != null) ***REMOVED***
        is_option = true;
        break;
      ***REMOVED***
    ***REMOVED***

    if(is_option) ***REMOVED***
      options = fields;
      fields = undefined;
    ***REMOVED*** else ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** else if(len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) ***REMOVED***
    var newFields = ***REMOVED******REMOVED***;
    // Rewrite the array
    for(i = 0; i < fields.length; i++) ***REMOVED***
      newFields[fields[i]] = 1;
    ***REMOVED***
    // Set the fields
    fields = newFields;
  ***REMOVED***

  if(3 === len) ***REMOVED***
    options = args[2];
  ***REMOVED***

  // Ensure selector is not null
  selector = selector == null ? ***REMOVED******REMOVED*** : selector;
  // Validate correctness off the selector
  var object = selector;
  if(Buffer.isBuffer(object)) ***REMOVED***
    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
    if(object_size != object.length)  ***REMOVED***
      var error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
      error.name = 'MongoError';
      throw error;
    ***REMOVED***
  ***REMOVED***

  // Validate correctness of the field selector
  object = fields;
  if(Buffer.isBuffer(object)) ***REMOVED***
    object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
    if(object_size != object.length)  ***REMOVED***
      error = new Error("query fields raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
      error.name = 'MongoError';
      throw error;
    ***REMOVED***
  ***REMOVED***

  // Check special case where we are using an objectId
  if(selector != null && selector._bsontype == 'ObjectID') ***REMOVED***
    selector = ***REMOVED***_id:selector***REMOVED***;
  ***REMOVED***

  // If it's a serialized fields field we need to just let it through
  // user be warned it better be good
  if(options && options.fields && !(Buffer.isBuffer(options.fields))) ***REMOVED***
    fields = ***REMOVED******REMOVED***;

    if(Array.isArray(options.fields)) ***REMOVED***
      if(!options.fields.length) ***REMOVED***
        fields['_id'] = 1;
      ***REMOVED*** else ***REMOVED***
        var l = options.fields.length;

        for (i = 0; i < l; i++) ***REMOVED***
          fields[options.fields[i]] = 1;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      fields = options.fields;
    ***REMOVED***
  ***REMOVED***

  if (!options) options = ***REMOVED******REMOVED***;

  var newOptions = ***REMOVED******REMOVED***;
  // Make a shallow copy of options
  for (var key in options) ***REMOVED***
    newOptions[key] = options[key];
  ***REMOVED***

  // Unpack options
  newOptions.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;
  newOptions.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;
  newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.s.raw;
  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
  newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;
  // // If we have overridden slaveOk otherwise use the default db setting
  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;

  // Add read preference if needed
  newOptions = getReadPreference(this, newOptions, this.s.db, this);

  // Set slave ok to true if read preference different from primary
  if(newOptions.readPreference != null
    && (newOptions.readPreference != 'primary' || newOptions.readPreference.mode != 'primary')) ***REMOVED***
    newOptions.slaveOk = true;
  ***REMOVED***

  // Ensure the query is an object
  if(selector != null && typeof selector != 'object') ***REMOVED***
    throw MongoError.create(***REMOVED***message: "query selector must be an object", driver:true ***REMOVED***);
  ***REMOVED***

  // Build the find command
  var findCommand = ***REMOVED***
      find: this.s.namespace
    , limit: newOptions.limit
    , skip: newOptions.skip
    , query: selector
  ***REMOVED***

  // Ensure we use the right await data option
  if(typeof newOptions.awaitdata == 'boolean')  ***REMOVED***
    newOptions.awaitData = newOptions.awaitdata
  ***REMOVED***

  // Translate to new command option noCursorTimeout
  if(typeof newOptions.timeout == 'boolean') newOptions.noCursorTimeout = newOptions.timeout;

  // Merge in options to command
  for(var name in newOptions) ***REMOVED***
    if(newOptions[name] != null) findCommand[name] = newOptions[name];
  ***REMOVED***

  // Format the fields
  var formatFields = function(fields) ***REMOVED***
    var object = ***REMOVED******REMOVED***;
    if(Array.isArray(fields)) ***REMOVED***
      for(var i = 0; i < fields.length; i++) ***REMOVED***
        if(Array.isArray(fields[i])) ***REMOVED***
          object[fields[i][0]] = fields[i][1];
        ***REMOVED*** else ***REMOVED***
          object[fields[i][0]] = 1;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      object = fields;
    ***REMOVED***

    return object;
  ***REMOVED***

  // Special treatment for the fields selector
  if(fields) findCommand.fields = formatFields(fields);

  // Add db object to the new options
  newOptions.db = this.s.db;

  // Add the promise library
  newOptions.promiseLibrary = this.s.promiseLibrary;

  // Set raw if available at collection level
  if(newOptions.raw == null && typeof this.s.raw == 'boolean') newOptions.raw = this.s.raw;
  // Set promoteLongs if available at collection level
  if(newOptions.promoteLongs == null && typeof this.s.promoteLongs == 'boolean') newOptions.promoteLongs = this.s.promoteLongs;
  if(newOptions.promoteValues == null && typeof this.s.promoteValues == 'boolean') newOptions.promoteValues = this.s.promoteValues;
  if(newOptions.promoteBuffers == null && typeof this.s.promoteBuffers == 'boolean') newOptions.promoteBuffers = this.s.promoteBuffers;

  // Sort options
  if(findCommand.sort) ***REMOVED***
    findCommand.sort = formattedOrderClause(findCommand.sort);
  ***REMOVED***

  // Set the readConcern
  if(this.s.readConcern) ***REMOVED***
    findCommand.readConcern = this.s.readConcern;
  ***REMOVED***

  // Decorate find command with collation options
  decorateWithCollation(findCommand, this, options);

  // Create the cursor
  if(typeof callback == 'function') return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, findCommand, newOptions));
  return this.s.topology.cursor(this.s.namespace, findCommand, newOptions);
***REMOVED***

define.classMethod('find', ***REMOVED***callback: false, promise:false, returns: [Cursor]***REMOVED***);

/**
 * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** doc Document to insert.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Collection~insertOneWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.insertOne = function(doc, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  if(Array.isArray(doc) && typeof callback == 'function') ***REMOVED***
    return callback(MongoError.create(***REMOVED***message: 'doc parameter must be an object', driver:true ***REMOVED***));
  ***REMOVED*** else if(Array.isArray(doc)) ***REMOVED***
    return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
      reject(MongoError.create(***REMOVED***message: 'doc parameter must be an object', driver:true ***REMOVED***));
    ***REMOVED***);
  ***REMOVED***

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return insertOne(self, doc, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    insertOne(self, doc, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var insertOne = function(self, doc, options, callback) ***REMOVED***
  insertDocuments(self, [doc], options, function(err, r) ***REMOVED***
    if(callback == null) return;
    if(err && callback) return callback(err);
    // Workaround for pre 2.6 servers
    if(r == null) return callback(null, ***REMOVED***result: ***REMOVED***ok:1***REMOVED******REMOVED***);
    // Add values to top level to ensure crud spec compatibility
    r.insertedCount = r.result.n;
    r.insertedId = doc._id;
    if(callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

var mapInserManyResults = function(docs, r) ***REMOVED***
  var ids = r.getInsertedIds();
  var keys = Object.keys(ids);
  var finalIds = new Array(keys.length);

  for(var i = 0; i < keys.length; i++) ***REMOVED***
    if(ids[keys[i]]._id) ***REMOVED***
      finalIds[ids[keys[i]].index] = ids[keys[i]]._id;
    ***REMOVED***
  ***REMOVED***

  var finalResult = ***REMOVED***
    result: ***REMOVED***ok: 1, n: r.insertedCount***REMOVED***,
    ops: docs,
    insertedCount: r.insertedCount,
    insertedIds: finalIds
  ***REMOVED***;

  if(r.getLastOp()) ***REMOVED***
    finalResult.result.opTime = r.getLastOp();
  ***REMOVED***

  return finalResult;
***REMOVED***

define.classMethod('insertOne', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***object[]***REMOVED*** docs Documents to insert.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Collection~insertWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.insertMany = function(docs, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED***ordered:true***REMOVED***;
  if(!Array.isArray(docs) && typeof callback == 'function') ***REMOVED***
    return callback(MongoError.create(***REMOVED***message: 'docs parameter must be an array of documents', driver:true ***REMOVED***));
  ***REMOVED*** else if(!Array.isArray(docs)) ***REMOVED***
    return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
      reject(MongoError.create(***REMOVED***message: 'docs parameter must be an array of documents', driver:true ***REMOVED***));
    ***REMOVED***);
  ***REMOVED***

  // Get the write concern options
  if(typeof options.checkKeys != 'boolean') ***REMOVED***
    options.checkKeys = true;
  ***REMOVED***

  // If keep going set unordered
  options['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;

  // Set up the force server object id
  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean'
    ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;

  // Do we want to force the server to assign the _id key
  if(forceServerObjectId !== true) ***REMOVED***
    // Add _id if not specified
    for(var i = 0; i < docs.length; i++) ***REMOVED***
      if(docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
    ***REMOVED***
  ***REMOVED***

  // Generate the bulk write operations
  var operations = [***REMOVED***
    insertMany: docs
  ***REMOVED***];

  // Execute using callback
  if(typeof callback == 'function') return bulkWrite(self, operations, options, function(err, r) ***REMOVED***
    if(err) return callback(err, r);
    callback(null, mapInserManyResults(docs, r));
  ***REMOVED***);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    bulkWrite(self, operations, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(mapInserManyResults(docs, r));
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('insertMany', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~BulkWriteOpResult
 * @property ***REMOVED***number***REMOVED*** insertedCount Number of documents inserted.
 * @property ***REMOVED***number***REMOVED*** matchedCount Number of documents matched for update.
 * @property ***REMOVED***number***REMOVED*** modifiedCount Number of documents modified.
 * @property ***REMOVED***number***REMOVED*** deletedCount Number of documents deleted.
 * @property ***REMOVED***number***REMOVED*** upsertedCount Number of documents upserted.
 * @property ***REMOVED***object***REMOVED*** insertedIds Inserted document generated Id's, hash key is the index of the originating operation
 * @property ***REMOVED***object***REMOVED*** upsertedIds Upserted document generated Id's, hash key is the index of the originating operation
 * @property ***REMOVED***object***REMOVED*** result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~bulkWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~BulkWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Perform a bulkWrite operation without a fluent API
 *
 * Legal operation types are
 *
 *  ***REMOVED*** insertOne: ***REMOVED*** document: ***REMOVED*** a: 1 ***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** updateOne: ***REMOVED*** filter: ***REMOVED***a:2***REMOVED***, update: ***REMOVED***$set: ***REMOVED***a:2***REMOVED******REMOVED***, upsert:true ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** updateMany: ***REMOVED*** filter: ***REMOVED***a:2***REMOVED***, update: ***REMOVED***$set: ***REMOVED***a:2***REMOVED******REMOVED***, upsert:true ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** deleteOne: ***REMOVED*** filter: ***REMOVED***c:1***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** deleteMany: ***REMOVED*** filter: ***REMOVED***c:1***REMOVED*** ***REMOVED*** ***REMOVED***
 *
 *  ***REMOVED*** replaceOne: ***REMOVED*** filter: ***REMOVED***c:3***REMOVED***, replacement: ***REMOVED***c:4***REMOVED***, upsert:true***REMOVED******REMOVED***
 *
 * If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***object[]***REMOVED*** operations Bulk operations to perform.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.ordered=true] Execute write operation in ordered or unordered fashion.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Collection~bulkWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.bulkWrite = function(operations, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED***ordered:true***REMOVED***;

  if(!Array.isArray(operations)) ***REMOVED***
    throw MongoError.create(***REMOVED***message: "operations must be an array of documents", driver:true ***REMOVED***);
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return bulkWrite(self, operations, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    bulkWrite(self, operations, options, function(err, r) ***REMOVED***
      if(err && r == null) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var bulkWrite = function(self, operations, options, callback) ***REMOVED***
  // Add ignoreUndfined
  if(self.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = self.s.options.ignoreUndefined;
  ***REMOVED***

  // Create the bulk operation
  var bulk = options.ordered == true || options.ordered == null ? self.initializeOrderedBulkOp(options) : self.initializeUnorderedBulkOp(options);

  // Do we have a collation
  var collation = false;

  // for each op go through and add to the bulk
  try ***REMOVED***
    for(var i = 0; i < operations.length; i++) ***REMOVED***
      // Get the operation type
      var key = Object.keys(operations[i])[0];
      // Check if we have a collation
      if(operations[i][key].collation) ***REMOVED***
        collation = true;
      ***REMOVED***

      // Pass to the raw bulk
      bulk.raw(operations[i]);
    ***REMOVED***
  ***REMOVED*** catch(err) ***REMOVED***
    return callback(err, null);
  ***REMOVED***

  // Final options for write concern
  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
  var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : ***REMOVED******REMOVED***;
  var capabilities = self.s.topology.capabilities();

  // Did the user pass in a collation, check if our write server supports it
  if(collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
    return callback(new MongoError(f('server/primary/mongos does not support collation')));
  ***REMOVED***

  // Execute the bulk
  bulk.execute(writeCon, function(err, r) ***REMOVED***
    // We have connection level error
    if(!r && err) return callback(err, null);
    // We have single error
    if(r && r.hasWriteErrors() && r.getWriteErrorCount() == 1) ***REMOVED***
      return callback(toError(r.getWriteErrorAt(0)), r);
    ***REMOVED***

    r.insertedCount = r.nInserted;
    r.matchedCount = r.nMatched;
    r.modifiedCount = r.nModified || 0;
    r.deletedCount = r.nRemoved;
    r.upsertedCount = r.getUpsertedIds().length;
    r.upsertedIds = ***REMOVED******REMOVED***;
    r.insertedIds = ***REMOVED******REMOVED***;

    // Update the n
    r.n = r.insertedCount;

    // Inserted documents
    var inserted = r.getInsertedIds();
    // Map inserted ids
    for(var i = 0; i < inserted.length; i++) ***REMOVED***
      r.insertedIds[inserted[i].index] = inserted[i]._id;
    ***REMOVED***

    // Upserted documents
    var upserted = r.getUpsertedIds();
    // Map upserted ids
    for(i = 0; i < upserted.length; i++) ***REMOVED***
      r.upsertedIds[upserted[i].index] = upserted[i]._id;
    ***REMOVED***

    // Check if we have write errors
    if(r.hasWriteErrors()) ***REMOVED***
      // Get all the errors
      var errors = r.getWriteErrors();
      // Return the MongoError object
      return callback(toError(***REMOVED***
        message: 'write operation failed', code: errors[0].code, writeErrors: errors
      ***REMOVED***), r);
    ***REMOVED***

    // Check if we have a writeConcern error
    if(r.getWriteConcernError()) ***REMOVED***
      // Return the MongoError object
      return callback(toError(r.getWriteConcernError()), r);
    ***REMOVED***

    // Return the results
    callback(null, r);
  ***REMOVED***);
***REMOVED***

var insertDocuments = function(self, docs, options, callback) ***REMOVED***
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  // Ensure we are operating on an array op docs
  docs = Array.isArray(docs) ? docs : [docs];

  // Get the write concern options
  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
  if(typeof finalOptions.checkKeys != 'boolean') finalOptions.checkKeys = true;

  // If keep going set unordered
  if(finalOptions.keepGoing == true) finalOptions.ordered = false;
  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;

  // Set up the force server object id
  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean'
    ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;

  // Add _id if not specified
  if(forceServerObjectId !== true)***REMOVED***
    for(var i = 0; i < docs.length; i++) ***REMOVED***
      if(docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
    ***REMOVED***
  ***REMOVED***

  // File inserts
  self.s.topology.insert(self.s.namespace, docs, finalOptions, function(err, result) ***REMOVED***
    if(callback == null) return;
    if(err) return handleCallback(callback, err);
    if(result == null) return handleCallback(callback, null, null);
    if(result.result.code) return handleCallback(callback, toError(result.result));
    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Add docs to the list
    result.ops = docs;
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

define.classMethod('bulkWrite', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~WriteOpResult
 * @property ***REMOVED***object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property ***REMOVED***object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***object***REMOVED*** result The command result object.
 */

/**
 * The callback format for inserts
 * @callback Collection~writeOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~WriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~insertWriteOpResult
 * @property ***REMOVED***Number***REMOVED*** insertedCount The total amount of documents inserted.
 * @property ***REMOVED***object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property ***REMOVED***ObjectId[]***REMOVED*** insertedIds All the generated _id's for the inserted documents.
 * @property ***REMOVED***object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***object***REMOVED*** result The raw command result object returned from MongoDB (content might vary by server version).
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents inserted.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~insertOneWriteOpResult
 * @property ***REMOVED***Number***REMOVED*** insertedCount The total amount of documents inserted.
 * @property ***REMOVED***object[]***REMOVED*** ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
 * @property ***REMOVED***ObjectId***REMOVED*** insertedId The driver generated ObjectId for the insert operation.
 * @property ***REMOVED***object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***object***REMOVED*** result The raw command result object returned from MongoDB (content might vary by server version).
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents inserted.
 */

/**
 * The callback format for inserts
 * @callback Collection~insertWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~insertWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * The callback format for inserts
 * @callback Collection~insertOneWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~insertOneWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
 * can be overridden by setting the **forceServerObjectId** flag.
 *
 * @method
 * @param ***REMOVED***(object|object[])***REMOVED*** docs Documents to insert.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.serializeFunctions=false] Serialize functions on any object.
 * @param ***REMOVED***boolean***REMOVED*** [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Collection~insertWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated Use insertOne, insertMany or bulkWrite
 */
Collection.prototype.insert = function(docs, options, callback) ***REMOVED***
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED***ordered:false***REMOVED***;
  docs = !Array.isArray(docs) ? [docs] : docs;

  if(options.keepGoing == true) ***REMOVED***
    options.ordered = false;
  ***REMOVED***

  return this.insertMany(docs, options, callback);
***REMOVED***

define.classMethod('insert', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~updateWriteOpResult
 * @property ***REMOVED***Object***REMOVED*** result The raw result returned from MongoDB, field will vary depending on server version.
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents scanned.
 * @property ***REMOVED***Number***REMOVED*** result.nModified The total count of documents modified.
 * @property ***REMOVED***Object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***Number***REMOVED*** matchedCount The number of documents that matched the filter.
 * @property ***REMOVED***Number***REMOVED*** modifiedCount The number of documents that were modified.
 * @property ***REMOVED***Number***REMOVED*** upsertedCount The number of documents upserted.
 * @property ***REMOVED***Object***REMOVED*** upsertedId The upserted id.
 * @property ***REMOVED***ObjectId***REMOVED*** upsertedId._id The upserted _id returned from the server.
 */

/**
 * The callback format for inserts
 * @callback Collection~updateWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~updateWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Update a single document on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to update
 * @param ***REMOVED***object***REMOVED*** update The update operations to be applied to the document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.updateOne = function(filter, update, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = shallowClone(options)

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return updateOne(self, filter, update, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    updateOne(self, filter, update, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var updateOne = function(self, filter, update, options, callback) ***REMOVED***
  // Set single document update
  options.multi = false;
  // Execute update
  updateDocuments(self, filter, update, options, function(err, r) ***REMOVED***
    if(callback == null) return;
    if(err && callback) return callback(err);
    if(r == null) return callback(null, ***REMOVED***result: ***REMOVED***ok:1***REMOVED******REMOVED***);
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    if(callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

define.classMethod('updateOne', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Replace a document on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to update
 * @param ***REMOVED***object***REMOVED*** doc The Document that replaces the matching document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.replaceOne = function(filter, doc, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = shallowClone(options)

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return replaceOne(self, filter, doc, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    replaceOne(self, filter, doc, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var replaceOne = function(self, filter, doc, options, callback) ***REMOVED***
  // Set single document update
  options.multi = false;

  // Execute update
  updateDocuments(self, filter, doc, options, function(err, r) ***REMOVED***
    if(callback == null) return;
    if(err && callback) return callback(err);
    if(r == null) return callback(null, ***REMOVED***result: ***REMOVED***ok:1***REMOVED******REMOVED***);

    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    r.ops = [doc];
    if(callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

define.classMethod('replaceOne', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Update multiple documents on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to update
 * @param ***REMOVED***object***REMOVED*** update The update operations to be applied to the document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Collection~updateWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.updateMany = function(filter, update, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = shallowClone(options)

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return updateMany(self, filter, update, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    updateMany(self, filter, update, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var updateMany = function(self, filter, update, options, callback) ***REMOVED***
  // Set single document update
  options.multi = true;
  // Execute update
  updateDocuments(self, filter, update, options, function(err, r) ***REMOVED***
    if(callback == null) return;
    if(err && callback) return callback(err);
    if(r == null) return callback(null, ***REMOVED***result: ***REMOVED***ok:1***REMOVED******REMOVED***);
    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
    if(callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

define.classMethod('updateMany', ***REMOVED***callback: true, promise:true***REMOVED***);

var updateDocuments = function(self, selector, document, options, callback) ***REMOVED***
  if('function' === typeof options) callback = options, options = null;
  if(options == null) options = ***REMOVED******REMOVED***;
  if(!('function' === typeof callback)) callback = null;

  // If we are not providing a selector or document throw
  if(selector == null || typeof selector != 'object') return callback(toError("selector must be a valid JavaScript object"));
  if(document == null || typeof document != 'object') return callback(toError("document must be a valid JavaScript object"));

  // Get the write concern options
  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);

  // Do we return the actual result document
  // Either use override on the function, or go back to default on either the collection
  // level or db
  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;

  // Execute the operation
  var op = ***REMOVED***q: selector, u: document***REMOVED***;
  op.upsert = typeof options.upsert == 'boolean' ? options.upsert : false;
  op.multi = typeof options.multi == 'boolean' ? options.multi : false;

  // Have we specified collation
  decorateWithCollation(finalOptions, self, options);

  // Update options
  self.s.topology.update(self.s.namespace, [op], finalOptions, function(err, result) ***REMOVED***
    if(callback == null) return;
    if(err) return handleCallback(callback, err, null);
    if(result == null) return handleCallback(callback, null, null);
    if(result.result.code) return handleCallback(callback, toError(result.result));
    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

/**
 * Updates documents.
 * @method
 * @param ***REMOVED***object***REMOVED*** selector The selector for the update operation.
 * @param ***REMOVED***object***REMOVED*** document The update document.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Update operation is an upsert.
 * @param ***REMOVED***boolean***REMOVED*** [options.multi=false] Update one/all documents with operation.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use updateOne, updateMany or bulkWrite
 */
Collection.prototype.update = function(selector, document, options, callback) ***REMOVED***
  var self = this;

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return updateDocuments(self, selector, document, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    updateDocuments(self, selector, document, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('update', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~deleteWriteOpResult
 * @property ***REMOVED***Object***REMOVED*** result The raw result returned from MongoDB, field will vary depending on server version.
 * @property ***REMOVED***Number***REMOVED*** result.ok Is 1 if the command executed correctly.
 * @property ***REMOVED***Number***REMOVED*** result.n The total count of documents deleted.
 * @property ***REMOVED***Object***REMOVED*** connection The connection object used for the operation.
 * @property ***REMOVED***Number***REMOVED*** deletedCount The number of documents deleted.
 */

/**
 * The callback format for inserts
 * @callback Collection~deleteWriteOpCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~deleteWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Delete a document on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the document to remove
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.deleteOne = function(filter, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = shallowClone(options);

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return deleteOne(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    deleteOne(self, filter, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var deleteOne = function(self, filter, options, callback) ***REMOVED***
  options.single = true;
  removeDocuments(self, filter, options, function(err, r) ***REMOVED***
    if(callback == null) return;
    if(err && callback) return callback(err);
    if(r == null) return callback(null, ***REMOVED***result: ***REMOVED***ok:1***REMOVED******REMOVED***);
    r.deletedCount = r.result.n;
    if(callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

define.classMethod('deleteOne', ***REMOVED***callback: true, promise:true***REMOVED***);

Collection.prototype.removeOne = Collection.prototype.deleteOne;

define.classMethod('removeOne', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Delete multiple documents on MongoDB
 * @method
 * @param ***REMOVED***object***REMOVED*** filter The Filter used to select the documents to remove
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Collection~deleteWriteOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.deleteMany = function(filter, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = shallowClone(options);

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return deleteMany(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    deleteMany(self, filter, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var deleteMany = function(self, filter, options, callback) ***REMOVED***
  options.single = false;

  removeDocuments(self, filter, options, function(err, r) ***REMOVED***
    if(callback == null) return;
    if(err && callback) return callback(err);
    if(r == null) return callback(null, ***REMOVED***result: ***REMOVED***ok:1***REMOVED******REMOVED***);
    r.deletedCount = r.result.n;
    if(callback) callback(null, r);
  ***REMOVED***);
***REMOVED***

var removeDocuments = function(self, selector, options, callback) ***REMOVED***
  if(typeof options == 'function') ***REMOVED***
    callback = options, options = ***REMOVED******REMOVED***;
  ***REMOVED*** else if (typeof selector === 'function') ***REMOVED***
    callback = selector;
    options = ***REMOVED******REMOVED***;
    selector = ***REMOVED******REMOVED***;
  ***REMOVED***

  // Create an empty options object if the provided one is null
  options = options || ***REMOVED******REMOVED***;

  // Get the write concern options
  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);

  // If selector is null set empty
  if(selector == null) selector = ***REMOVED******REMOVED***;

  // Build the op
  var op = ***REMOVED***q: selector, limit: 0***REMOVED***;
  if(options.single) op.limit = 1;

  // Have we specified collation
  decorateWithCollation(finalOptions, self, options);

  // Execute the remove
  self.s.topology.remove(self.s.namespace, [op], finalOptions, function(err, result) ***REMOVED***
    if(callback == null) return;
    if(err) return handleCallback(callback, err, null);
    if(result == null) return handleCallback(callback, null, null);
    if(result.result.code) return handleCallback(callback, toError(result.result));
    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
    // Return the results
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

define.classMethod('deleteMany', ***REMOVED***callback: true, promise:true***REMOVED***);

Collection.prototype.removeMany = Collection.prototype.deleteMany;

define.classMethod('removeMany', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Remove documents.
 * @method
 * @param ***REMOVED***object***REMOVED*** selector The selector for the update operation.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.single=false] Removes the first document found.
 * @param ***REMOVED***Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use deleteOne, deleteMany or bulkWrite
 */
Collection.prototype.remove = function(selector, options, callback) ***REMOVED***
  var self = this;

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return removeDocuments(self, selector, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    removeDocuments(self, selector, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('remove', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic
 * operators and update instead for more efficient operations.
 * @method
 * @param ***REMOVED***object***REMOVED*** doc Document to save
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Collection~writeOpCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use insertOne, insertMany, updateOne or updateMany
 */
Collection.prototype.save = function(doc, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Add ignoreUndfined
  if(this.s.options.ignoreUndefined) ***REMOVED***
    options = shallowClone(options);
    options.ignoreUndefined = this.s.options.ignoreUndefined;
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return save(self, doc, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    save(self, doc, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var save = function(self, doc, options, callback) ***REMOVED***
  // Get the write concern options
  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
  // Establish if we need to perform an insert or update
  if(doc._id != null) ***REMOVED***
    finalOptions.upsert = true;
    return updateDocuments(self, ***REMOVED***_id: doc._id***REMOVED***, doc, finalOptions, callback);
  ***REMOVED***

  // Insert the document
  insertDocuments(self, [doc], options, function(err, r) ***REMOVED***
    if(callback == null) return;
    if(doc == null) return handleCallback(callback, null, null);
    if(err) return handleCallback(callback, err, null);
    handleCallback(callback, null, r);
  ***REMOVED***);
***REMOVED***

define.classMethod('save', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The callback format for results
 * @callback Collection~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Fetches the first document that matches the query
 * @method
 * @param ***REMOVED***object***REMOVED*** query Query for find Operation
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.limit=0] Sets the limit of documents returned in the query.
 * @param ***REMOVED***(array|object)***REMOVED*** [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
 * @param ***REMOVED***object***REMOVED*** [options.fields=null] The fields to return in the query. Object of fields to include or exclude (not both), ***REMOVED***'a':1***REMOVED***
 * @param ***REMOVED***number***REMOVED*** [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
 * @param ***REMOVED***Object***REMOVED*** [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, ***REMOVED***'_id':1***REMOVED***
 * @param ***REMOVED***boolean***REMOVED*** [options.explain=false] Explain the query instead of returning the data.
 * @param ***REMOVED***boolean***REMOVED*** [options.snapshot=false] Snapshot query.
 * @param ***REMOVED***boolean***REMOVED*** [options.timeout=false] Specify if the cursor can timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.tailable=false] Specify if the cursor is tailable.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnKey=false] Only return the index key.
 * @param ***REMOVED***number***REMOVED*** [options.maxScan=null] Limit the number of items to scan.
 * @param ***REMOVED***number***REMOVED*** [options.min=null] Set index bounds.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] Set index bounds.
 * @param ***REMOVED***boolean***REMOVED*** [options.showDiskLoc=false] Show disk location of results.
 * @param ***REMOVED***string***REMOVED*** [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***boolean***REMOVED*** [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOne = function() ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  var callback = args.pop();
  if(typeof callback != 'function') args.push(callback);

  // Execute using callback
  if(typeof callback == 'function') return findOne(self, args, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    findOne(self, args, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var findOne = function(self, args, callback) ***REMOVED***
  var cursor = self.find.apply(self, args).limit(-1).batchSize(1);
  // Return the item
  cursor.next(function(err, item) ***REMOVED***
    if(err != null) return handleCallback(callback, toError(err), null);
    handleCallback(callback, null, item);
  ***REMOVED***);
***REMOVED***

define.classMethod('findOne', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The callback format for the collection method, must be used if strict is specified
 * @callback Collection~collectionResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection***REMOVED*** collection The collection instance.
 */

/**
 * Rename the collection.
 *
 * @method
 * @param ***REMOVED***string***REMOVED*** newName New name of of the collection.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropTarget=false] Drop the target name collection if it previously exists.
 * @param ***REMOVED***Collection~collectionResultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.rename = function(newName, opt, callback) ***REMOVED***
  var self = this;
  if(typeof opt == 'function') callback = opt, opt = ***REMOVED******REMOVED***;
  opt = assign(***REMOVED******REMOVED***, opt, ***REMOVED***readPreference: ReadPreference.PRIMARY***REMOVED***);

  // Execute using callback
  if(typeof callback == 'function') return rename(self, newName, opt, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    rename(self, newName, opt, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var rename = function(self, newName, opt, callback) ***REMOVED***
  // Check the collection name
  checkCollectionName(newName);
  // Build the command
  var renameCollection = f("%s.%s", self.s.dbName, self.s.name);
  var toCollection =  f("%s.%s", self.s.dbName, newName);
  var dropTarget = typeof opt.dropTarget == 'boolean' ? opt.dropTarget : false;
  var cmd = ***REMOVED***'renameCollection':renameCollection, 'to':toCollection, 'dropTarget':dropTarget***REMOVED***;

  // Decorate command with writeConcern if supported
  decorateWithWriteConcern(cmd, self, opt);

  // Execute against admin
  self.s.db.admin().command(cmd, opt, function(err, doc) ***REMOVED***
    if(err) return handleCallback(callback, err, null);
    // We have an error
    if(doc.errmsg) return handleCallback(callback, toError(doc), null);
    try ***REMOVED***
      return handleCallback(callback, null, new Collection(self.s.db, self.s.topology, self.s.dbName, newName, self.s.pkFactory, self.s.options));
    ***REMOVED*** catch(err) ***REMOVED***
      return handleCallback(callback, toError(err), null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.classMethod('rename', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.drop = function(options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return self.s.db.dropCollection(self.s.name, options, callback);
  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.dropCollection(self.s.name, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('drop', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Returns the options of the collection.
 *
 * @method
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.options = function(callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return options(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    options(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var options = function(self, callback) ***REMOVED***
  self.s.db.listCollections(***REMOVED***name: self.s.name***REMOVED***).toArray(function(err, collections) ***REMOVED***
    if(err) return handleCallback(callback, err);
    if(collections.length == 0) ***REMOVED***
      return handleCallback(callback, MongoError.create(***REMOVED***message: f("collection %s not found", self.s.namespace), driver:true ***REMOVED***));
    ***REMOVED***

    handleCallback(callback, err, collections[0].options || null);
  ***REMOVED***);
***REMOVED***

define.classMethod('options', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Returns if the collection is a capped collection
 *
 * @method
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The results callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.isCapped = function(callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return isCapped(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    isCapped(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var isCapped = function(self, callback) ***REMOVED***
  self.options(function(err, document) ***REMOVED***
    if(err) return handleCallback(callback, err);
    handleCallback(callback, null, document && document.capped);
  ***REMOVED***);
***REMOVED***

define.classMethod('isCapped', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Creates an index on the db and collection collection.
 * @method
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***string***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***object***REMOVED*** [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.createIndex = function(fieldOrSpec, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  options = typeof callback === 'function' ? options : callback;
  options = options == null ? ***REMOVED******REMOVED*** : options;

  // Execute using callback
  if(typeof callback == 'function') return createIndex(self, fieldOrSpec, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    createIndex(self, fieldOrSpec, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var createIndex = function(self, fieldOrSpec, options, callback) ***REMOVED***
  self.s.db.createIndex(self.s.name, fieldOrSpec, options, callback);
***REMOVED***

define.classMethod('createIndex', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Creates multiple indexes in the collection, this method is only supported for
 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
 * @method
 * @param ***REMOVED***array***REMOVED*** indexSpecs An array of index specifications to be created
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.createIndexes = function(indexSpecs, callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return createIndexes(self, indexSpecs, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    createIndexes(self, indexSpecs, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var createIndexes = function(self, indexSpecs, callback) ***REMOVED***
  var capabilities = self.s.topology.capabilities();

  // Ensure we generate the correct name if the parameter is not set
  for(var i = 0; i < indexSpecs.length; i++) ***REMOVED***
    if(indexSpecs[i].name == null) ***REMOVED***
      var keys = [];

      // Did the user pass in a collation, check if our write server supports it
      if(indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) ***REMOVED***
        return callback(new MongoError(f('server/primary/mongos does not support collation')));
      ***REMOVED***

      for(var name in indexSpecs[i].key) ***REMOVED***
        keys.push(f('%s_%s', name, indexSpecs[i].key[name]));
      ***REMOVED***

      // Set the name
      indexSpecs[i].name = keys.join('_');
    ***REMOVED***
  ***REMOVED***

  // Execute the index
  self.s.db.command(***REMOVED***
    createIndexes: self.s.name, indexes: indexSpecs
  ***REMOVED***, ***REMOVED*** readPreference: ReadPreference.PRIMARY ***REMOVED***, callback);
***REMOVED***

define.classMethod('createIndexes', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Drops an index from this collection.
 * @method
 * @param ***REMOVED***string***REMOVED*** indexName Name of the index to drop.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.dropIndex = function(indexName, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  // Run only against primary
  options.readPreference = ReadPreference.PRIMARY;

  // Execute using callback
  if(typeof callback == 'function') return dropIndex(self, indexName, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    dropIndex(self, indexName, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var dropIndex = function(self, indexName, options, callback) ***REMOVED***
  // Delete index command
  var cmd = ***REMOVED***'dropIndexes':self.s.name, 'index':indexName***REMOVED***;

  // Decorate command with writeConcern if supported
  decorateWithWriteConcern(cmd, self, options);

  // Execute command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if(typeof callback != 'function') return;
    if(err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

define.classMethod('dropIndex', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Drops all indexes from this collection.
 * @method
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.dropIndexes = function(options, callback) ***REMOVED***
  var self = this;

  // Do we have options
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return dropIndexes(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    dropIndexes(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var dropIndexes = function(self, options, callback) ***REMOVED***
  self.dropIndex('*', options, function(err) ***REMOVED***
    if(err) return handleCallback(callback, err, false);
    handleCallback(callback, null, true);
  ***REMOVED***);
***REMOVED***

define.classMethod('dropIndexes', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Drops all indexes from this collection.
 * @method
 * @deprecated use dropIndexes
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** callback The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no [callback] passed
 */
Collection.prototype.dropAllIndexes = Collection.prototype.dropIndexes;

define.classMethod('dropAllIndexes', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Reindex all indexes on the collection
 * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
 * @method
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.reIndex = function(options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return reIndex(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    reIndex(self, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var reIndex = function(self, options, callback) ***REMOVED***
  // Reindex
  var cmd = ***REMOVED***'reIndex':self.s.name***REMOVED***;

  // Decorate command with writeConcern if supported
  decorateWithWriteConcern(cmd, self, options);

  // Execute the command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if(callback == null) return;
    if(err) return handleCallback(callback, err, null);
    handleCallback(callback, null, result.ok ? true : false);
  ***REMOVED***);
***REMOVED***

define.classMethod('reIndex', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Get the list of all indexes information for the collection.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @return ***REMOVED***CommandCursor***REMOVED***
 */
Collection.prototype.listIndexes = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Clone the options
  options = shallowClone(options);
  // Determine the read preference in the options.
  options = getReadPreference(this, options, this.s.db, this);
  // Set the CommandCursor constructor
  options.cursorFactory = CommandCursor;
  // Set the promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  if(!this.s.topology.capabilities()) ***REMOVED***
    throw new MongoError('cannot connect to server');
  ***REMOVED***

  // We have a list collections command
  if(this.s.topology.capabilities().hasListIndexesCommand) ***REMOVED***
    // Cursor options
    var cursor = options.batchSize ? ***REMOVED***batchSize: options.batchSize***REMOVED*** : ***REMOVED******REMOVED***
    // Build the command
    var command = ***REMOVED*** listIndexes: this.s.name, cursor: cursor ***REMOVED***;
    // Execute the cursor
    cursor = this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options);
    // Do we have a readPreference, apply it
    if(options.readPreference) cursor.setReadPreference(options.readPreference);
    // Return the cursor
    return cursor;
  ***REMOVED***

  // Get the namespace
  var ns = f('%s.system.indexes', this.s.dbName);
  // Get the query
  cursor = this.s.topology.cursor(ns, ***REMOVED***find: ns, query: ***REMOVED***ns: this.s.namespace***REMOVED******REMOVED***, options);
  // Do we have a readPreference, apply it
  if(options.readPreference) cursor.setReadPreference(options.readPreference);
  // Set the passed in batch size if one was provided
  if(options.batchSize) cursor = cursor.batchSize(options.batchSize);
  // Return the cursor
  return cursor;
***REMOVED***;

define.classMethod('listIndexes', ***REMOVED***callback: false, promise:false, returns: [CommandCursor]***REMOVED***);

/**
 * Ensures that an index exists, if it does not it creates it
 * @method
 * @deprecated use createIndexes instead
 * @param ***REMOVED***(string|object)***REMOVED*** fieldOrSpec Defines the index.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Creates an unique index.
 * @param ***REMOVED***boolean***REMOVED*** [options.sparse=false] Creates a sparse index.
 * @param ***REMOVED***boolean***REMOVED*** [options.background=false] Creates the index in the background, yielding whenever possible.
 * @param ***REMOVED***boolean***REMOVED*** [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
 * @param ***REMOVED***number***REMOVED*** [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
 * @param ***REMOVED***number***REMOVED*** [options.v=null] Specify the format version of the indexes.
 * @param ***REMOVED***number***REMOVED*** [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
 * @param ***REMOVED***number***REMOVED*** [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.ensureIndex = function(fieldOrSpec, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return ensureIndex(self, fieldOrSpec, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    ensureIndex(self, fieldOrSpec, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var ensureIndex = function(self, fieldOrSpec, options, callback) ***REMOVED***
  self.s.db.ensureIndex(self.s.name, fieldOrSpec, options, callback);
***REMOVED***

define.classMethod('ensureIndex', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Checks if one or more indexes exist on the collection, fails on first non-existing index
 * @method
 * @param ***REMOVED***(string|array)***REMOVED*** indexes One or more index names to check.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexExists = function(indexes, callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return indexExists(self, indexes, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    indexExists(self, indexes, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var indexExists = function(self, indexes, callback) ***REMOVED***
  self.indexInformation(function(err, indexInformation) ***REMOVED***
    // If we have an error return
    if(err != null) return handleCallback(callback, err, null);
    // Let's check for the index names
    if(!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null);
    // Check in list of indexes
    for(var i = 0; i < indexes.length; i++) ***REMOVED***
      if(indexInformation[indexes[i]] == null) ***REMOVED***
        return handleCallback(callback, null, false);
      ***REMOVED***
    ***REMOVED***

    // All keys found return true
    return handleCallback(callback, null, true);
  ***REMOVED***);
***REMOVED***

define.classMethod('indexExists', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieves this collections index info.
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.full=false] Returns the full raw index information.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexInformation = function(options, callback) ***REMOVED***
  var self = this;
  // Unpack calls
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return indexInformation(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    indexInformation(self, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var indexInformation = function(self, options, callback) ***REMOVED***
  self.s.db.indexInformation(self.s.name, options, callback);
***REMOVED***

define.classMethod('indexInformation', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The callback format for results
 * @callback Collection~countCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***number***REMOVED*** result The count of documents that matched the query.
 */

/**
 * Count number of matching documents in the db to a query.
 * @method
 * @param ***REMOVED***object***REMOVED*** query The query for the count.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***boolean***REMOVED*** [options.limit=null] The limit of documents to count.
 * @param ***REMOVED***boolean***REMOVED*** [options.skip=null] The number of documents to skip for the count.
 * @param ***REMOVED***string***REMOVED*** [options.hint=null] An index name hint for the query.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***Collection~countCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.count = function(query, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  var queryOption = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  var optionsOption = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return count(self, queryOption, optionsOption, callback);

  // Check if query is empty
  query = query || ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    count(self, query, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var count = function(self, query, options, callback) ***REMOVED***
  var skip = options.skip;
  var limit = options.limit;
  var hint = options.hint;
  var maxTimeMS = options.maxTimeMS;

  // Final query
  var cmd = ***REMOVED***
    'count': self.s.name, 'query': query
  ***REMOVED***;

  // Add limit, skip and maxTimeMS if defined
  if(typeof skip == 'number') cmd.skip = skip;
  if(typeof limit == 'number') cmd.limit = limit;
  if(typeof maxTimeMS == 'number') cmd.maxTimeMS = maxTimeMS;
  if(hint) options.hint = hint;

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Do we have a readConcern specified
  if(self.s.readConcern) ***REMOVED***
    cmd.readConcern = self.s.readConcern;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(cmd, self, options);

  // Execute command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if(err) return handleCallback(callback, err);
    handleCallback(callback, null, result.n);
  ***REMOVED***);
***REMOVED***

define.classMethod('count', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * The distinct command returns returns a list of distinct values for the given key across a collection.
 * @method
 * @param ***REMOVED***string***REMOVED*** key Field of the document to find distinct values for.
 * @param ***REMOVED***object***REMOVED*** query The query for filtering the set of documents to which we apply the distinct filter.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.distinct = function(key, query, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  var queryOption = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;
  var optionsOption = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return distinct(self, key, queryOption, optionsOption, callback);

  // Ensure the query and options are set
  query = query || ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    distinct(self, key, query, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var distinct = function(self, key, query, options, callback) ***REMOVED***
  // maxTimeMS option
  var maxTimeMS = options.maxTimeMS;

  // Distinct command
  var cmd = ***REMOVED***
    'distinct': self.s.name, 'key': key, 'query': query
  ***REMOVED***;

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Add maxTimeMS if defined
  if(typeof maxTimeMS == 'number')
    cmd.maxTimeMS = maxTimeMS;

  // Do we have a readConcern specified
  if(self.s.readConcern) ***REMOVED***
    cmd.readConcern = self.s.readConcern;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(cmd, self, options);

  // Execute the command
  self.s.db.command(cmd, options, function(err, result) ***REMOVED***
    if(err) return handleCallback(callback, err);
    handleCallback(callback, null, result.values);
  ***REMOVED***);
***REMOVED***

define.classMethod('distinct', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieve all the indexes on the collection.
 * @method
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.indexes = function(callback) ***REMOVED***
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return indexes(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    indexes(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var indexes = function(self, callback) ***REMOVED***
  self.s.db.indexInformation(self.s.name, ***REMOVED***full:true***REMOVED***, callback);
***REMOVED***

define.classMethod('indexes', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Get all the collection statistics.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***number***REMOVED*** [options.scale=null] Divide the returned sizes by scale value.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.stats = function(options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return stats(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    stats(self, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var stats = function(self, options, callback) ***REMOVED***
  // Build command object
  var commandObject = ***REMOVED***
    collStats:self.s.name
  ***REMOVED***

  // Check if we have the scale value
  if(options['scale'] != null) commandObject['scale'] = options['scale'];

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Execute the command
  self.s.db.command(commandObject, options, callback);
***REMOVED***

define.classMethod('stats', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * @typedef ***REMOVED***Object***REMOVED*** Collection~findAndModifyWriteOpResult
 * @property ***REMOVED***object***REMOVED*** value Document returned from findAndModify command.
 * @property ***REMOVED***object***REMOVED*** lastErrorObject The raw lastErrorObject returned from the command.
 * @property ***REMOVED***Number***REMOVED*** ok Is 1 if the command executed correctly.
 */

/**
 * The callback format for inserts
 * @callback Collection~findAndModifyCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Collection~findAndModifyWriteOpResult***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] Limits the fields to return for all matching documents.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndDelete = function(filter, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Basic validation
  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');

  // Execute using callback
  if(typeof callback == 'function') return findOneAndDelete(self, filter, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;

    findOneAndDelete(self, filter, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var findOneAndDelete = function(self, filter, options, callback) ***REMOVED***
  // Final options
  var finalOptions = shallowClone(options);
  finalOptions['fields'] = options.projection;
  finalOptions['remove'] = true;
  // Execute find and Modify
  self.findAndModify(
      filter
    , options.sort
    , null
    , finalOptions
    , callback
  );
***REMOVED***

define.classMethod('findOneAndDelete', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** replacement Document replacing the matching document.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] Limits the fields to return for all matching documents.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Upsert the document if it does not exist.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Basic validation
  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
  if(replacement == null || typeof replacement != 'object') throw toError('replacement parameter must be an object');

  // Execute using callback
  if(typeof callback == 'function') return findOneAndReplace(self, filter, replacement, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;

    findOneAndReplace(self, filter, replacement, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var findOneAndReplace = function(self, filter, replacement, options, callback) ***REMOVED***
  // Final options
  var finalOptions = shallowClone(options);
  finalOptions['fields'] = options.projection;
  finalOptions['update'] = true;
  finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
  finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;

  // Execute findAndModify
  self.findAndModify(
      filter
    , options.sort
    , replacement
    , finalOptions
    , callback
  );
***REMOVED***

define.classMethod('findOneAndReplace', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** filter Document selection filter.
 * @param ***REMOVED***object***REMOVED*** update Update operations to be performed on the document
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***object***REMOVED*** [options.projection=null] Limits the fields to return for all matching documents.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Upsert the document if it does not exist.
 * @param ***REMOVED***boolean***REMOVED*** [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The collection result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Basic validation
  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
  if(update == null || typeof update != 'object') throw toError('update parameter must be an object');

  // Execute using callback
  if(typeof callback == 'function') return findOneAndUpdate(self, filter, update, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;

    findOneAndUpdate(self, filter, update, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var findOneAndUpdate = function(self, filter, update, options, callback) ***REMOVED***
  // Final options
  var finalOptions = shallowClone(options);
  finalOptions['fields'] = options.projection;
  finalOptions['update'] = true;
  finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
  finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;

  // Execute findAndModify
  self.findAndModify(
      filter
    , options.sort
    , update
    , finalOptions
    , callback
  );
***REMOVED***

define.classMethod('findOneAndUpdate', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Find and update a document.
 * @method
 * @param ***REMOVED***object***REMOVED*** query Query object to locate the object to modify.
 * @param ***REMOVED***array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param ***REMOVED***object***REMOVED*** doc The fields/vals to be updated.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.remove=false] Set to true to remove the object before returning.
 * @param ***REMOVED***boolean***REMOVED*** [options.upsert=false] Perform an upsert operation.
 * @param ***REMOVED***boolean***REMOVED*** [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
 * @param ***REMOVED***object***REMOVED*** [options.fields=null] Object containing the field projection for the result returned from the operation.
 * @param ***REMOVED***Collection~findAndModifyCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
 */
Collection.prototype.findAndModify = function(query, sort, doc, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  sort = args.length ? args.shift() || [] : [];
  doc = args.length ? args.shift() : null;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Clone options
  options = shallowClone(options);
  // Force read preference primary
  options.readPreference = ReadPreference.PRIMARY;

  // Execute using callback
  if(typeof callback == 'function') return findAndModify(self, query, sort, doc, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    options = options || ***REMOVED******REMOVED***;

    findAndModify(self, query, sort, doc, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var findAndModify = function(self, query, sort, doc, options, callback) ***REMOVED***
  // Create findAndModify command object
  var queryObject = ***REMOVED***
     'findandmodify': self.s.name
   , 'query': query
  ***REMOVED***;

  sort = formattedOrderClause(sort);
  if(sort) ***REMOVED***
    queryObject.sort = sort;
  ***REMOVED***

  queryObject.new = options.new ? true : false;
  queryObject.remove = options.remove ? true : false;
  queryObject.upsert = options.upsert ? true : false;

  if(options.fields) ***REMOVED***
    queryObject.fields = options.fields;
  ***REMOVED***

  if(doc && !options.remove) ***REMOVED***
    queryObject.update = doc;
  ***REMOVED***

  if(options.maxTimeMS)
    queryObject.maxTimeMS = options.maxTimeMS;

  // Either use override on the function, or go back to default on either the collection
  // level or db
  if(options['serializeFunctions'] != null) ***REMOVED***
    options['serializeFunctions'] = options['serializeFunctions'];
  ***REMOVED*** else ***REMOVED***
    options['serializeFunctions'] = self.s.serializeFunctions;
  ***REMOVED***

  // No check on the documents
  options.checkKeys = false;

  // Get the write concern settings
  var finalOptions = writeConcern(options, self.s.db, self, options);

  // Decorate the findAndModify command with the write Concern
  if(finalOptions.writeConcern) ***REMOVED***
    queryObject.writeConcern = finalOptions.writeConcern;
  ***REMOVED***

  // Have we specified bypassDocumentValidation
  if(typeof finalOptions.bypassDocumentValidation == 'boolean') ***REMOVED***
    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(queryObject, self, options);

  // Execute the command
  self.s.db.command(queryObject
    , options, function(err, result) ***REMOVED***
      if(err) return handleCallback(callback, err, null);
      return handleCallback(callback, null, result);
  ***REMOVED***);
***REMOVED***

define.classMethod('findAndModify', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Find and remove a document.
 * @method
 * @param ***REMOVED***object***REMOVED*** query Query object to locate the object to modify.
 * @param ***REMOVED***array***REMOVED*** sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 * @deprecated use findOneAndDelete instead
 */
Collection.prototype.findAndRemove = function(query, sort, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  sort = args.length ? args.shift() || [] : [];
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return findAndRemove(self, query, sort, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    findAndRemove(self, query, sort, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var findAndRemove = function(self, query, sort, options, callback) ***REMOVED***
  // Add the remove option
  options['remove'] = true;
  // Execute the callback
  self.findAndModify(query, sort, null, options, callback);
***REMOVED***

define.classMethod('findAndRemove', ***REMOVED***callback: true, promise:true***REMOVED***);

function decorateWithWriteConcern(command, self, options) ***REMOVED***
  // Do we support collation 3.4 and higher
  var capabilities = self.s.topology.capabilities();
  // Do we support write concerns 3.4 and higher
  if(capabilities && capabilities.commandsTakeWriteConcern) ***REMOVED***
    // Get the write concern settings
    var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
    // Add the write concern to the command
    if(finalOptions.writeConcern) ***REMOVED***
      command.writeConcern = finalOptions.writeConcern;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function decorateWithCollation(command, self, options) ***REMOVED***
  // Do we support collation 3.4 and higher
  var capabilities = self.s.topology.capabilities();
  // Do we support write concerns 3.4 and higher
  if(capabilities && capabilities.commandsTakeCollation) ***REMOVED***
    if(options.collation && typeof options.collation == 'object') ***REMOVED***
      command.collation = options.collation;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2
 * @method
 * @param ***REMOVED***object***REMOVED*** pipeline Array containing all the aggregation framework commands for the execution.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.cursor=null] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
 * @param ***REMOVED***number***REMOVED*** [options.cursor.batchSize=null] The batchSize for the cursor
 * @param ***REMOVED***boolean***REMOVED*** [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
 * @param ***REMOVED***boolean***REMOVED*** [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return document results as raw BSON buffers.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
 * @param ***REMOVED***boolean***REMOVED*** [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
 * @param ***REMOVED***object***REMOVED*** [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** callback The command result callback
 * @return ***REMOVED***(null|AggregationCursor)***REMOVED***
 */
Collection.prototype.aggregate = function(pipeline, options, callback) ***REMOVED***
  var self = this;

  if(Array.isArray(pipeline)) ***REMOVED***
    // Set up callback if one is provided
    if(typeof options == 'function') ***REMOVED***
      callback = options;
      options = ***REMOVED******REMOVED***;
    ***REMOVED***

    // If we have no options or callback we are doing
    // a cursor based aggregation
    if(options == null && callback == null) ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // Aggregation pipeline passed as arguments on the method
    var args = Array.prototype.slice.call(arguments, 0);
    // Get the callback
    callback = args.pop();
    // Get the possible options object
    var opts = args[args.length - 1];
    // If it contains any of the admissible options pop it of the args
    options = opts && (opts.readPreference
      || opts.explain || opts.cursor || opts.out
      || opts.maxTimeMS || opts.allowDiskUse) ? args.pop() : ***REMOVED******REMOVED***;
      // Left over arguments is the pipeline
    pipeline = args;
  ***REMOVED***

  // Ignore readConcern option
  var ignoreReadConcern = false;

  // Build the command
  var command = ***REMOVED*** aggregate : this.s.name, pipeline : pipeline***REMOVED***;

  // If out was specified
  if(typeof options.out == 'string') ***REMOVED***
    pipeline.push(***REMOVED***$out: options.out***REMOVED***);
    // Ignore read concern
    ignoreReadConcern = true;
  ***REMOVED*** else if(pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) ***REMOVED***
    ignoreReadConcern = true;
  ***REMOVED***

  // Decorate command with writeConcern if out has been specified
  if(pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) ***REMOVED***
    decorateWithWriteConcern(command, self, options);
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(command, self, options);

  // If we have bypassDocumentValidation set
  if(typeof options.bypassDocumentValidation == 'boolean') ***REMOVED***
    command.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // Do we have a readConcern specified
  if(!ignoreReadConcern && this.s.readConcern) ***REMOVED***
    command.readConcern = this.s.readConcern;
  ***REMOVED***

  // If we have allowDiskUse defined
  if(options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
  if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(this, options, this.s.db, this);

  // If explain has been specified add it
  if(options.explain) command.explain = options.explain;

  // Validate that cursor options is valid
  if(options.cursor != null && typeof options.cursor != 'object') ***REMOVED***
    throw toError('cursor options must be an object');
  ***REMOVED***

  // promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  // Set the AggregationCursor constructor
  options.cursorFactory = AggregationCursor;
  if(typeof callback != 'function') ***REMOVED***
    if(!this.s.topology.capabilities()) ***REMOVED***
      throw new MongoError('cannot connect to server');
    ***REMOVED***

    if(this.s.topology.capabilities().hasAggregationCursor) ***REMOVED***
      options.cursor = options.cursor || ***REMOVED*** batchSize : 1000 ***REMOVED***;
      command.cursor = options.cursor;
    ***REMOVED***

    // Allow disk usage command
    if(typeof options.allowDiskUse == 'boolean') command.allowDiskUse = options.allowDiskUse;
    if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;

    // Execute the cursor
    return this.s.topology.cursor(this.s.namespace, command, options);
  ***REMOVED***

  // We do not allow cursor
  if(options.cursor) ***REMOVED***
    return this.s.topology.cursor(this.s.namespace, command, options);
  ***REMOVED***

  // Execute the command
  this.s.db.command(command, options, function(err, result) ***REMOVED***
    if(err) ***REMOVED***
      handleCallback(callback, err);
    ***REMOVED*** else if(result['err'] || result['errmsg']) ***REMOVED***
      handleCallback(callback, toError(result));
    ***REMOVED*** else if(typeof result == 'object' && result['serverPipeline']) ***REMOVED***
      handleCallback(callback, null, result['serverPipeline']);
    ***REMOVED*** else if(typeof result == 'object' && result['stages']) ***REMOVED***
      handleCallback(callback, null, result['stages']);
    ***REMOVED*** else ***REMOVED***
      handleCallback(callback, null, result.result);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.classMethod('aggregate', ***REMOVED***callback: true, promise:false***REMOVED***);

/**
 * The callback format for results
 * @callback Collection~parallelCollectionScanCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***Cursor[]***REMOVED*** cursors A list of cursors returned allowing for parallel reading of collection.
 */

/**
 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are
 * no ordering guarantees for returned results.
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.batchSize=null] Set the batchSize for the getMoreCommand when iterating over the query results.
 * @param ***REMOVED***number***REMOVED*** [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)
 * @param ***REMOVED***boolean***REMOVED*** [options.raw=false] Return all BSON documents as Raw Buffer documents.
 * @param ***REMOVED***Collection~parallelCollectionScanCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.parallelCollectionScan = function(options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED***numCursors: 1***REMOVED***;
  // Set number of cursors to 1
  options.numCursors = options.numCursors || 1;
  options.batchSize = options.batchSize || 1000;

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(this, options, this.s.db, this);

  // Add a promiseLibrary
  options.promiseLibrary = this.s.promiseLibrary;

  // Execute using callback
  if(typeof callback == 'function') return parallelCollectionScan(self, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    parallelCollectionScan(self, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var parallelCollectionScan = function(self, options, callback) ***REMOVED***
  // Create command object
  var commandObject = ***REMOVED***
      parallelCollectionScan: self.s.name
    , numCursors: options.numCursors
  ***REMOVED***

  // Do we have a readConcern specified
  if(self.s.readConcern) ***REMOVED***
    commandObject.readConcern = self.s.readConcern;
  ***REMOVED***

  // Store the raw value
  var raw = options.raw;
  delete options['raw'];

  // Execute the command
  self.s.db.command(commandObject, options, function(err, result) ***REMOVED***
    if(err) return handleCallback(callback, err, null);
    if(result == null) return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);

    var cursors = [];
    // Add the raw back to the option
    if(raw) options.raw = raw;
    // Create command cursors for each item
    for(var i = 0; i < result.cursors.length; i++) ***REMOVED***
      var rawId = result.cursors[i].cursor.id
      // Convert cursorId to Long if needed
      var cursorId = typeof rawId == 'number' ? Long.fromNumber(rawId) : rawId;
      // Add a command cursor
      cursors.push(self.s.topology.cursor(self.s.namespace, cursorId, options));
    ***REMOVED***

    handleCallback(callback, null, cursors);
  ***REMOVED***);
***REMOVED***

define.classMethod('parallelCollectionScan', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Execute the geoNear command to search for items in the collection
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** x Point to search on the x axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***number***REMOVED*** y Point to search on the y axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.num=null] Max number of results to return.
 * @param ***REMOVED***number***REMOVED*** [options.minDistance=null] Include results starting at minDistance from a point (2.6 or higher)
 * @param ***REMOVED***number***REMOVED*** [options.maxDistance=null] Include results up to maxDistance from the point.
 * @param ***REMOVED***number***REMOVED*** [options.distanceMultiplier=null] Include a value to multiply the distances with allowing for range conversions.
 * @param ***REMOVED***object***REMOVED*** [options.query=null] Filter the results by a query.
 * @param ***REMOVED***boolean***REMOVED*** [options.spherical=false] Perform query using a spherical model.
 * @param ***REMOVED***boolean***REMOVED*** [options.uniqueDocs=false] The closest location in a document to the center of the search region will always be returned MongoDB > 2.X.
 * @param ***REMOVED***boolean***REMOVED*** [options.includeLocs=false] Include the location data fields in the top level of the results MongoDB > 2.X.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.geoNear = function(x, y, options, callback) ***REMOVED***
  var self = this;
  var point = typeof(x) == 'object' && x
    , args = Array.prototype.slice.call(arguments, point?1:2);

  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return geoNear(self, x, y, point, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    geoNear(self, x, y, point, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var geoNear = function(self, x, y, point, options, callback) ***REMOVED***
  // Build command object
  var commandObject = ***REMOVED***
    geoNear:self.s.name,
    near: point || [x, y]
  ***REMOVED***

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Exclude readPreference and existing options to prevent user from
  // shooting themselves in the foot
  var exclude = ***REMOVED***
    readPreference: true,
    geoNear: true,
    near: true
  ***REMOVED***;

  // Filter out any excluded objects
  commandObject = decorateCommand(commandObject, options, exclude);

  // Do we have a readConcern specified
  if(self.s.readConcern) ***REMOVED***
    commandObject.readConcern = self.s.readConcern;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(commandObject, self, options);

  // Execute the command
  self.s.db.command(commandObject, options, function (err, res) ***REMOVED***
    if(err) return handleCallback(callback, err);
    if(res.err || res.errmsg) return handleCallback(callback, toError(res));
    // should we only be returning res.results here? Not sure if the user
    // should see the other return information
    handleCallback(callback, null, res);
  ***REMOVED***);
***REMOVED***

define.classMethod('geoNear', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Execute a geo search using a geo haystack index on a collection.
 *
 * @method
 * @param ***REMOVED***number***REMOVED*** x Point to search on the x axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***number***REMOVED*** y Point to search on the y axis, ensure the indexes are ordered in the same order.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.maxDistance=null] Include results up to maxDistance from the point.
 * @param ***REMOVED***object***REMOVED*** [options.search=null] Filter the results by a query.
 * @param ***REMOVED***number***REMOVED*** [options.limit=false] Max number of results to return.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.geoHaystackSearch = function(x, y, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return geoHaystackSearch(self, x, y, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    geoHaystackSearch(self, x, y, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var geoHaystackSearch = function(self, x, y, options, callback) ***REMOVED***
  // Build command object
  var commandObject = ***REMOVED***
    geoSearch: self.s.name,
    near: [x, y]
  ***REMOVED***

  // Remove read preference from hash if it exists
  commandObject = decorateCommand(commandObject, options, ***REMOVED***readPreference: true***REMOVED***);

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // Do we have a readConcern specified
  if(self.s.readConcern) ***REMOVED***
    commandObject.readConcern = self.s.readConcern;
  ***REMOVED***

  // Execute the command
  self.s.db.command(commandObject, options, function (err, res) ***REMOVED***
    if(err) return handleCallback(callback, err);
    if(res.err || res.errmsg) handleCallback(callback, toError(res));
    // should we only be returning res.results here? Not sure if the user
    // should see the other return information
    handleCallback(callback, null, res);
  ***REMOVED***);
***REMOVED***

define.classMethod('geoHaystackSearch', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Group function helper
 * @ignore
 */
// var groupFunction = function () ***REMOVED***
//   var c = db[ns].find(condition);
//   var map = new Map();
//   var reduce_function = reduce;
//
//   while (c.hasNext()) ***REMOVED***
//     var obj = c.next();
//     var key = ***REMOVED******REMOVED***;
//
//     for (var i = 0, len = keys.length; i < len; ++i) ***REMOVED***
//       var k = keys[i];
//       key[k] = obj[k];
//     ***REMOVED***
//
//     var aggObj = map.get(key);
//
//     if (aggObj == null) ***REMOVED***
//       var newObj = Object.extend(***REMOVED******REMOVED***, key);
//       aggObj = Object.extend(newObj, initial);
//       map.put(key, aggObj);
//     ***REMOVED***
//
//     reduce_function(obj, aggObj);
//   ***REMOVED***
//
//   return ***REMOVED*** "result": map.values() ***REMOVED***;
// ***REMOVED***.toString();
var groupFunction = 'function () ***REMOVED***\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) ***REMOVED***\nvar obj = c.next();\nvar key = ***REMOVED******REMOVED***;\n\nfor (var i = 0, len = keys.length; i < len; ++i) ***REMOVED***\nvar k = keys[i];\nkey[k] = obj[k];\n***REMOVED***\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) ***REMOVED***\nvar newObj = Object.extend(***REMOVED******REMOVED***, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n***REMOVED***\n\nreduce_function(obj, aggObj);\n***REMOVED***\n\nreturn ***REMOVED*** "result": map.values() ***REMOVED***;\n***REMOVED***';

/**
 * Run a group command across a collection
 *
 * @method
 * @param ***REMOVED***(object|array|function|code)***REMOVED*** keys An object, array or function expressing the keys to group by.
 * @param ***REMOVED***object***REMOVED*** condition An optional condition that must be true for a row to be considered.
 * @param ***REMOVED***object***REMOVED*** initial Initial value of the aggregation counter object.
 * @param ***REMOVED***(function|Code)***REMOVED*** reduce The reduce function aggregates (reduces) the objects iterated
 * @param ***REMOVED***(function|Code)***REMOVED*** finalize An optional function to be run on each item in the result set just before the item is returned.
 * @param ***REMOVED***boolean***REMOVED*** command Specify if you wish to run using the internal group command or using eval, default is true.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.group = function(keys, condition, initial, reduce, finalize, command, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 3);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  // Fetch all commands
  reduce = args.length ? args.shift() : null;
  finalize = args.length ? args.shift() : null;
  command = args.length ? args.shift() : null;
  options = args.length ? args.shift() || ***REMOVED******REMOVED*** : ***REMOVED******REMOVED***;

  // Make sure we are backward compatible
  if(!(typeof finalize == 'function')) ***REMOVED***
    command = finalize;
    finalize = null;
  ***REMOVED***

  if (!Array.isArray(keys) && keys instanceof Object && typeof(keys) !== 'function' && !(keys._bsontype == 'Code')) ***REMOVED***
    keys = Object.keys(keys);
  ***REMOVED***

  if(typeof reduce === 'function') ***REMOVED***
    reduce = reduce.toString();
  ***REMOVED***

  if(typeof finalize === 'function') ***REMOVED***
    finalize = finalize.toString();
  ***REMOVED***

  // Set up the command as default
  command = command == null ? true : command;

  // Execute using callback
  if(typeof callback == 'function') return group(self, keys, condition, initial, reduce, finalize, command, options, callback);
  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    group(self, keys, condition, initial, reduce, finalize, command, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var group = function(self, keys, condition, initial, reduce, finalize, command, options, callback) ***REMOVED***
  // Execute using the command
  if(command) ***REMOVED***
    var reduceFunction = reduce && reduce._bsontype == 'Code'
        ? reduce
        : new Code(reduce);

    var selector = ***REMOVED***
      group: ***REMOVED***
          'ns': self.s.name
        , '$reduce': reduceFunction
        , 'cond': condition
        , 'initial': initial
        , 'out': "inline"
      ***REMOVED***
    ***REMOVED***;

    // if finalize is defined
    if(finalize != null) selector.group['finalize'] = finalize;
    // Set up group selector
    if ('function' === typeof keys || (keys && keys._bsontype == 'Code')) ***REMOVED***
      selector.group.$keyf = keys && keys._bsontype == 'Code'
        ? keys
        : new Code(keys);
    ***REMOVED*** else ***REMOVED***
      var hash = ***REMOVED******REMOVED***;
      keys.forEach(function (key) ***REMOVED***
        hash[key] = 1;
      ***REMOVED***);
      selector.group.key = hash;
    ***REMOVED***

    options = shallowClone(options);
    // Ensure we have the right read preference inheritance
    options = getReadPreference(self, options, self.s.db, self);

    // Do we have a readConcern specified
    if(self.s.readConcern) ***REMOVED***
      selector.readConcern = self.s.readConcern;
    ***REMOVED***

    // Have we specified collation
    decorateWithCollation(selector, self, options);

    // Execute command
    self.s.db.command(selector, options, function(err, result) ***REMOVED***
      if(err) return handleCallback(callback, err, null);
      handleCallback(callback, null, result.retval);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    // Create execution scope
    var scope = reduce != null && reduce._bsontype == 'Code'
      ? reduce.scope
      : ***REMOVED******REMOVED***;

    scope.ns = self.s.name;
    scope.keys = keys;
    scope.condition = condition;
    scope.initial = initial;

    // Pass in the function text to execute within mongodb.
    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');

    self.s.db.eval(new Code(groupfn, scope), function (err, results) ***REMOVED***
      if (err) return handleCallback(callback, err, null);
      handleCallback(callback, null, results.result || results);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

define.classMethod('group', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Functions that are passed as scope args must
 * be converted to Code instances.
 * @ignore
 */
function processScope (scope) ***REMOVED***
  if(!isObject(scope) || scope._bsontype == 'ObjectID') ***REMOVED***
    return scope;
  ***REMOVED***

  var keys = Object.keys(scope);
  var i = keys.length;
  var key;
  var new_scope = ***REMOVED******REMOVED***;

  while (i--) ***REMOVED***
    key = keys[i];
    if ('function' == typeof scope[key]) ***REMOVED***
      new_scope[key] = new Code(String(scope[key]));
    ***REMOVED*** else ***REMOVED***
      new_scope[key] = processScope(scope[key]);
    ***REMOVED***
  ***REMOVED***

  return new_scope;
***REMOVED***

/**
 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
 *
 * @method
 * @param ***REMOVED***(function|string)***REMOVED*** map The mapping function.
 * @param ***REMOVED***(function|string)***REMOVED*** reduce The reduce function.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***object***REMOVED*** [options.out=null] Sets the output target for the map reduce job. ****REMOVED***inline:1***REMOVED*** | ***REMOVED***replace:'collectionName'***REMOVED*** | ***REMOVED***merge:'collectionName'***REMOVED*** | ***REMOVED***reduce:'collectionName'***REMOVED****
 * @param ***REMOVED***object***REMOVED*** [options.query=null] Query filter object.
 * @param ***REMOVED***object***REMOVED*** [options.sort=null] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
 * @param ***REMOVED***number***REMOVED*** [options.limit=null] Number of objects to return from collection.
 * @param ***REMOVED***boolean***REMOVED*** [options.keeptemp=false] Keep temporary data.
 * @param ***REMOVED***(function|string)***REMOVED*** [options.finalize=null] Finalize function.
 * @param ***REMOVED***object***REMOVED*** [options.scope=null] Can pass in variables that can be access from map/reduce/finalize.
 * @param ***REMOVED***boolean***REMOVED*** [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
 * @param ***REMOVED***boolean***REMOVED*** [options.verbose=false] Provide statistics on job execution time.
 * @param ***REMOVED***boolean***REMOVED*** [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
 * @param ***REMOVED***Collection~resultCallback***REMOVED*** [callback] The command result callback
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Collection.prototype.mapReduce = function(map, reduce, options, callback) ***REMOVED***
  var self = this;
  if('function' === typeof options) callback = options, options = ***REMOVED******REMOVED***;
  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
  if(null == options.out) ***REMOVED***
    throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
  ***REMOVED***

  if('function' === typeof map) ***REMOVED***
    map = map.toString();
  ***REMOVED***

  if('function' === typeof reduce) ***REMOVED***
    reduce = reduce.toString();
  ***REMOVED***

  if('function' === typeof options.finalize) ***REMOVED***
    options.finalize = options.finalize.toString();
  ***REMOVED***

  // Execute using callback
  if(typeof callback == 'function') return mapReduce(self, map, reduce, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    mapReduce(self, map, reduce, options, function(err, r, r1) ***REMOVED***
      if(err) return reject(err);
      if(!r1) return resolve(r);
      resolve(***REMOVED***results: r, stats: r1***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

var mapReduce = function(self, map, reduce, options, callback) ***REMOVED***
  var mapCommandHash = ***REMOVED***
      mapreduce: self.s.name
    , map: map
    , reduce: reduce
  ***REMOVED***;

  // Add any other options passed in
  for(var n in options) ***REMOVED***
    if('scope' == n) ***REMOVED***
      mapCommandHash[n] = processScope(options[n]);
    ***REMOVED*** else ***REMOVED***
      mapCommandHash[n] = options[n];
    ***REMOVED***
  ***REMOVED***

  options = shallowClone(options);
  // Ensure we have the right read preference inheritance
  options = getReadPreference(self, options, self.s.db, self);

  // If we have a read preference and inline is not set as output fail hard
  if((options.readPreference != false && options.readPreference != 'primary')
    && options['out'] && (options['out'].inline != 1 && options['out'] != 'inline')) ***REMOVED***
      // Force readPreference to primary
      options.readPreference = 'primary';
      // Decorate command with writeConcern if supported
      decorateWithWriteConcern(mapCommandHash, self, options);
  ***REMOVED*** else if(self.s.readConcern) ***REMOVED***
    mapCommandHash.readConcern = self.s.readConcern;
  ***REMOVED***

  // Is bypassDocumentValidation specified
  if(typeof options.bypassDocumentValidation == 'boolean') ***REMOVED***
    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
  ***REMOVED***

  // Have we specified collation
  decorateWithCollation(mapCommandHash, self, options);

  // Execute command
  self.s.db.command(mapCommandHash, ***REMOVED***readPreference:options.readPreference***REMOVED***, function (err, result) ***REMOVED***
    if(err) return handleCallback(callback, err);
    // Check if we have an error
    if(1 != result.ok || result.err || result.errmsg) ***REMOVED***
      return handleCallback(callback, toError(result));
    ***REMOVED***

    // Create statistics value
    var stats = ***REMOVED******REMOVED***;
    if(result.timeMillis) stats['processtime'] = result.timeMillis;
    if(result.counts) stats['counts'] = result.counts;
    if(result.timing) stats['timing'] = result.timing;

    // invoked with inline?
    if(result.results) ***REMOVED***
      // If we wish for no verbosity
      if(options['verbose'] == null || !options['verbose']) ***REMOVED***
        return handleCallback(callback, null, result.results);
      ***REMOVED***

      return handleCallback(callback, null, result.results, stats);
    ***REMOVED***

    // The returned collection
    var collection = null;

    // If we have an object it's a different db
    if(result.result != null && typeof result.result == 'object') ***REMOVED***
      var doc = result.result;
      collection = self.s.db.db(doc.db).collection(doc.collection);
    ***REMOVED*** else ***REMOVED***
      // Create a collection object that wraps the result collection
      collection = self.s.db.collection(result.result)
    ***REMOVED***

    // If we wish for no verbosity
    if(options['verbose'] == null || !options['verbose']) ***REMOVED***
      return handleCallback(callback, err, collection);
    ***REMOVED***

    // Return stats as third set of values
    handleCallback(callback, err, collection, stats);
  ***REMOVED***);
***REMOVED***

define.classMethod('mapReduce', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @return ***REMOVED***UnorderedBulkOperation***REMOVED***
 */
Collection.prototype.initializeUnorderedBulkOp = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  options.promiseLibrary = this.s.promiseLibrary;
  return unordered(this.s.topology, this, options);
***REMOVED***

define.classMethod('initializeUnorderedBulkOp', ***REMOVED***callback: false, promise:false, returns: [ordered.UnorderedBulkOperation]***REMOVED***);

/**
 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
 *
 * @method
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***OrderedBulkOperation***REMOVED*** callback The command result callback
 * @return ***REMOVED***null***REMOVED***
 */
Collection.prototype.initializeOrderedBulkOp = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  options.promiseLibrary = this.s.promiseLibrary;
  return ordered(this.s.topology, this, options);
***REMOVED***

define.classMethod('initializeOrderedBulkOp', ***REMOVED***callback: false, promise:false, returns: [ordered.OrderedBulkOperation]***REMOVED***);

// Get write concern
var writeConcern = function(target, db, col, options) ***REMOVED***
  if(options.w != null || options.j != null || options.fsync != null) ***REMOVED***
    var opts = ***REMOVED******REMOVED***;
    if(options.w != null) opts.w = options.w;
    if(options.wtimeout != null) opts.wtimeout = options.wtimeout;
    if(options.j != null) opts.j = options.j;
    if(options.fsync != null) opts.fsync = options.fsync;
    target.writeConcern = opts;
  ***REMOVED*** else if(col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) ***REMOVED***
    target.writeConcern = col.writeConcern;
  ***REMOVED*** else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) ***REMOVED***
    target.writeConcern = db.writeConcern;
  ***REMOVED***

  return target
***REMOVED***

// Figure out the read preference
var getReadPreference = function(self, options, db) ***REMOVED***
  var r = null
  if(options.readPreference) ***REMOVED***
    r = options.readPreference
  ***REMOVED*** else if(self.s.readPreference) ***REMOVED***
    r = self.s.readPreference
  ***REMOVED*** else if(db.s.readPreference) ***REMOVED***
    r = db.s.readPreference;
  ***REMOVED***

  if(r instanceof ReadPreference) ***REMOVED***
    options.readPreference = new CoreReadPreference(r.mode, r.tags, ***REMOVED***maxStalenessSeconds: r.maxStalenessSeconds***REMOVED***);
  ***REMOVED*** else if(typeof r == 'string') ***REMOVED***
    options.readPreference = new CoreReadPreference(r);
  ***REMOVED*** else if(r && !(r instanceof ReadPreference) && typeof r == 'object') ***REMOVED***
    var mode = r.mode || r.preference;
    if (mode && typeof mode == 'string') ***REMOVED***
      options.readPreference = new CoreReadPreference(mode, r.tags, ***REMOVED***maxStalenessSeconds: r.maxStalenessSeconds***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  return options;
***REMOVED***

var testForFields = ***REMOVED***
    limit: 1, sort: 1, fields:1, skip: 1, hint: 1, explain: 1, snapshot: 1, timeout: 1, tailable: 1, tailableRetryInterval: 1
  , numberOfRetries: 1, awaitdata: 1, awaitData: 1, exhaust: 1, batchSize: 1, returnKey: 1, maxScan: 1, min: 1, max: 1, showDiskLoc: 1
  , comment: 1, raw: 1, readPreference: 1, partial: 1, read: 1, dbName: 1, oplogReplay: 1, connection: 1, maxTimeMS: 1, transforms: 1
  , collation: 1
***REMOVED***

module.exports = Collection;
