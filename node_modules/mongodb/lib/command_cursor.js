"use strict";

var inherits = require('util').inherits
  , ReadPreference = require('./read_preference')
  , MongoError = require('mongodb-core').MongoError
  , Readable = require('stream').Readable || require('readable-stream').Readable
  , Define = require('./metadata')
  , CoreCursor = require('./cursor')
  , CoreReadPreference = require('mongodb-core').ReadPreference;

/**
 * @fileOverview The **CommandCursor** class is an internal class that embodies a
 * generalized cursor based on a MongoDB command allowing for iteration over the
 * results returned. It supports one by one document iteration, conversion to an
 * array or can be iterated as a Node 0.10.X or higher stream
 *
 * **CommandCursor Cannot directly be instantiated**
 * @example
 * var MongoClient = require('mongodb').MongoClient,
 *   test = require('assert');
 * // Connection url
 * var url = 'mongodb://localhost:27017/test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, db) ***REMOVED***
 *   // Create a collection we want to drop later
 *   var col = db.collection('listCollectionsExample1');
 *   // Insert a bunch of documents
 *   col.insert([***REMOVED***a:1, b:1***REMOVED***
 *     , ***REMOVED***a:2, b:2***REMOVED***, ***REMOVED***a:3, b:3***REMOVED***
 *     , ***REMOVED***a:4, b:4***REMOVED***], ***REMOVED***w:1***REMOVED***, function(err, result) ***REMOVED***
 *     test.equal(null, err);
 *
 *     // List the database collections available
 *     db.listCollections().toArray(function(err, items) ***REMOVED***
 *       test.equal(null, err);
 *       db.close();
 *     ***REMOVED***);
 *   ***REMOVED***);
 * ***REMOVED***);
 */

/**
 * Namespace provided by the browser.
 * @external Readable
 */

/**
 * Creates a new Command Cursor instance (INTERNAL TYPE, do not instantiate directly)
 * @class CommandCursor
 * @extends external:Readable
 * @fires CommandCursor#data
 * @fires CommandCursor#end
 * @fires CommandCursor#close
 * @fires CommandCursor#readable
 * @return ***REMOVED***CommandCursor***REMOVED*** an CommandCursor instance.
 */
var CommandCursor = function(bson, ns, cmd, options, topology, topologyOptions) ***REMOVED***
  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
  var state = CommandCursor.INIT;
  var streamOptions = ***REMOVED******REMOVED***;

  // MaxTimeMS
  var maxTimeMS = null;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // Set up
  Readable.call(this, ***REMOVED***objectMode: true***REMOVED***);

  // Internal state
  this.s = ***REMOVED***
    // MaxTimeMS
      maxTimeMS: maxTimeMS
    // State
    , state: state
    // Stream options
    , streamOptions: streamOptions
    // BSON
    , bson: bson
    // Namespae
    , ns: ns
    // Command
    , cmd: cmd
    // Options
    , options: options
    // Topology
    , topology: topology
    // Topology Options
    , topologyOptions: topologyOptions
    // Promise library
    , promiseLibrary: promiseLibrary
  ***REMOVED***
***REMOVED***

/**
 * CommandCursor stream data event, fired for each document in the cursor.
 *
 * @event CommandCursor#data
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * CommandCursor stream end event
 *
 * @event CommandCursor#end
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * CommandCursor stream close event
 *
 * @event CommandCursor#close
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * CommandCursor stream readable event
 *
 * @event CommandCursor#readable
 * @type ***REMOVED***null***REMOVED***
 */

// Inherit from Readable
inherits(CommandCursor, Readable);

// Set the methods to inherit from prototype
var methodsToInherit = ['_next', 'next', 'each', 'forEach', 'toArray'
  , 'rewind', 'bufferedCount', 'readBufferedDocuments', 'close', 'isClosed', 'kill'
  , '_find', '_getmore', '_killcursor', 'isDead', 'explain', 'isNotified', 'isKilled'];

// Only inherit the types we need
for(var i = 0; i < methodsToInherit.length; i++) ***REMOVED***
  CommandCursor.prototype[methodsToInherit[i]] = CoreCursor.prototype[methodsToInherit[i]];
***REMOVED***

var define = CommandCursor.define = new Define('CommandCursor', CommandCursor, true);

/**
 * Set the ReadPreference for the cursor.
 * @method
 * @param ***REMOVED***(string|ReadPreference)***REMOVED*** readPreference The new read preference for the cursor.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Cursor***REMOVED***
 */
CommandCursor.prototype.setReadPreference = function(r) ***REMOVED***
  if(this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create(***REMOVED***message: "Cursor is closed", driver:true***REMOVED***);
  if(this.s.state != CommandCursor.INIT) throw MongoError.create(***REMOVED***message: 'cannot change cursor readPreference after cursor has been accessed', driver:true***REMOVED***);

  if(r instanceof ReadPreference) ***REMOVED***
    this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags, ***REMOVED***maxStalenessSeconds: r.maxStalenessSeconds***REMOVED***);
  ***REMOVED*** else if(typeof r == 'string') ***REMOVED***
    this.s.options.readPreference = new CoreReadPreference(r);
  ***REMOVED*** else if(r instanceof CoreReadPreference) ***REMOVED***
    this.s.options.readPreference = r;
  ***REMOVED***

  return this;
***REMOVED***

define.classMethod('setReadPreference', ***REMOVED***callback: false, promise:false, returns: [CommandCursor]***REMOVED***);

/**
 * Set the batch size for the cursor.
 * @method
 * @param ***REMOVED***number***REMOVED*** value The batchSize for the cursor.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***CommandCursor***REMOVED***
 */
CommandCursor.prototype.batchSize = function(value) ***REMOVED***
  if(this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create(***REMOVED***message: "Cursor is closed", driver:true***REMOVED***);
  if(typeof value != 'number') throw MongoError.create(***REMOVED***message: "batchSize requires an integer", driver:true***REMOVED***);
  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
  this.setCursorBatchSize(value);
  return this;
***REMOVED***

define.classMethod('batchSize', ***REMOVED***callback: false, promise:false, returns: [CommandCursor]***REMOVED***);

/**
 * Add a maxTimeMS stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** value The state maxTimeMS value.
 * @return ***REMOVED***CommandCursor***REMOVED***
 */
CommandCursor.prototype.maxTimeMS = function(value) ***REMOVED***
  if(this.s.topology.lastIsMaster().minWireVersion > 2) ***REMOVED***
    this.s.cmd.maxTimeMS = value;
  ***REMOVED***
  return this;
***REMOVED***

define.classMethod('maxTimeMS', ***REMOVED***callback: false, promise:false, returns: [CommandCursor]***REMOVED***);

CommandCursor.prototype.get = CommandCursor.prototype.toArray;

define.classMethod('get', ***REMOVED***callback: true, promise:false***REMOVED***);

// Inherited methods
define.classMethod('toArray', ***REMOVED***callback: true, promise:true***REMOVED***);
define.classMethod('each', ***REMOVED***callback: true, promise:false***REMOVED***);
define.classMethod('forEach', ***REMOVED***callback: true, promise:false***REMOVED***);
define.classMethod('next', ***REMOVED***callback: true, promise:true***REMOVED***);
define.classMethod('close', ***REMOVED***callback: true, promise:true***REMOVED***);
define.classMethod('isClosed', ***REMOVED***callback: false, promise:false, returns: [Boolean]***REMOVED***);
define.classMethod('rewind', ***REMOVED***callback: false, promise:false***REMOVED***);
define.classMethod('bufferedCount', ***REMOVED***callback: false, promise:false, returns: [Number]***REMOVED***);
define.classMethod('readBufferedDocuments', ***REMOVED***callback: false, promise:false, returns: [Array]***REMOVED***);

/**
 * Get the next available document from the cursor, returns null if no more documents are available.
 * @function CommandCursor.prototype.next
 * @param ***REMOVED***CommandCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * The callback format for results
 * @callback CommandCursor~toArrayResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object[]***REMOVED*** documents All the documents the satisfy the cursor.
 */

/**
 * Returns an array of documents. The caller is responsible for making sure that there
 * is enough memory to store the results. Note that the array only contain partial
 * results when this cursor had been previouly accessed.
 * @method CommandCursor.prototype.toArray
 * @param ***REMOVED***CommandCursor~toArrayResultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * The callback format for results
 * @callback CommandCursor~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***(object|null)***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Iterates over all the documents for this cursor. As with *****REMOVED***cursor.toArray***REMOVED*****,
 * not all of the elements will be iterated if this cursor had been previouly accessed.
 * In that case, *****REMOVED***cursor.rewind***REMOVED***** can be used to reset the cursor. However, unlike
 * *****REMOVED***cursor.toArray***REMOVED*****, the cursor will only hold a maximum of batch size elements
 * at any given time if batch size is specified. Otherwise, the caller is responsible
 * for making sure that the entire result can fit the memory.
 * @method CommandCursor.prototype.each
 * @param ***REMOVED***CommandCursor~resultCallback***REMOVED*** callback The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * Close the cursor, sending a KillCursor command and emitting close.
 * @method CommandCursor.prototype.close
 * @param ***REMOVED***CommandCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * Is the cursor closed
 * @method CommandCursor.prototype.isClosed
 * @return ***REMOVED***boolean***REMOVED***
 */

/**
 * Clone the cursor
 * @function CommandCursor.prototype.clone
 * @return ***REMOVED***CommandCursor***REMOVED***
 */

/**
 * Resets the cursor
 * @function CommandCursor.prototype.rewind
 * @return ***REMOVED***CommandCursor***REMOVED***
 */

/**
 * The callback format for the forEach iterator method
 * @callback CommandCursor~iteratorCallback
 * @param ***REMOVED***Object***REMOVED*** doc An emitted document for the iterator
 */

/**
 * The callback error format for the forEach iterator method
 * @callback CommandCursor~endCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 */

/*
 * Iterates over all the documents for this cursor using the iterator, callback pattern.
 * @method CommandCursor.prototype.forEach
 * @param ***REMOVED***CommandCursor~iteratorCallback***REMOVED*** iterator The iteration callback.
 * @param ***REMOVED***CommandCursor~endCallback***REMOVED*** callback The end callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***null***REMOVED***
 */

CommandCursor.INIT = 0;
CommandCursor.OPEN = 1;
CommandCursor.CLOSED = 2;

module.exports = CommandCursor;
