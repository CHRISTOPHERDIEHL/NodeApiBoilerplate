"use strict";

var inherits = require('util').inherits
  , MongoError = require('mongodb-core').MongoError
  , Readable = require('stream').Readable || require('readable-stream').Readable
  , Define = require('./metadata')
  , CoreCursor = require('./cursor');

/**
 * @fileOverview The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query. It supports
 * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X
 * or higher stream
 *
 * **AGGREGATIONCURSOR Cannot directly be instantiated**
 * @example
 * var MongoClient = require('mongodb').MongoClient,
 *   test = require('assert');
 * // Connection url
 * var url = 'mongodb://localhost:27017/test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, db) ***REMOVED***
 *   // Create a collection we want to drop later
 *   var col = db.collection('createIndexExample1');
 *   // Insert a bunch of documents
 *   col.insert([***REMOVED***a:1, b:1***REMOVED***
 *     , ***REMOVED***a:2, b:2***REMOVED***, ***REMOVED***a:3, b:3***REMOVED***
 *     , ***REMOVED***a:4, b:4***REMOVED***], ***REMOVED***w:1***REMOVED***, function(err, result) ***REMOVED***
 *     test.equal(null, err);
 *     // Show that duplicate records got dropped
 *     col.aggregation(***REMOVED******REMOVED***, ***REMOVED***cursor: ***REMOVED******REMOVED******REMOVED***).toArray(function(err, items) ***REMOVED***
 *       test.equal(null, err);
 *       test.equal(4, items.length);
 *       db.close();
 *     ***REMOVED***);
 *   ***REMOVED***);
 * ***REMOVED***);
 */

/**
 * Namespace provided by the browser.
 * @external Readable
 */

/**
 * Creates a new Aggregation Cursor instance (INTERNAL TYPE, do not instantiate directly)
 * @class AggregationCursor
 * @extends external:Readable
 * @fires AggregationCursor#data
 * @fires AggregationCursor#end
 * @fires AggregationCursor#close
 * @fires AggregationCursor#readable
 * @return ***REMOVED***AggregationCursor***REMOVED*** an AggregationCursor instance.
 */
var AggregationCursor = function(bson, ns, cmd, options, topology, topologyOptions) ***REMOVED***
  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
  var state = AggregationCursor.INIT;
  var streamOptions = ***REMOVED******REMOVED***;

  // MaxTimeMS
  var maxTimeMS = null;

  // Get the promiseLibrary
  var promiseLibrary = options.promiseLibrary;

  // No promise library selected fall back
  if(!promiseLibrary) ***REMOVED***
    promiseLibrary = typeof global.Promise == 'function' ?
      global.Promise : require('es6-promise').Promise;
  ***REMOVED***

  // Set up
  Readable.call(this, ***REMOVED***objectMode: true***REMOVED***);

  // Internal state
  this.s = ***REMOVED***
    // MaxTimeMS
      maxTimeMS: maxTimeMS
    // State
    , state: state
    // Stream options
    , streamOptions: streamOptions
    // BSON
    , bson: bson
    // Namespae
    , ns: ns
    // Command
    , cmd: cmd
    // Options
    , options: options
    // Topology
    , topology: topology
    // Topology Options
    , topologyOptions: topologyOptions
    // Promise library
    , promiseLibrary: promiseLibrary
  ***REMOVED***
***REMOVED***

/**
 * AggregationCursor stream data event, fired for each document in the cursor.
 *
 * @event AggregationCursor#data
 * @type ***REMOVED***object***REMOVED***
 */

/**
 * AggregationCursor stream end event
 *
 * @event AggregationCursor#end
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * AggregationCursor stream close event
 *
 * @event AggregationCursor#close
 * @type ***REMOVED***null***REMOVED***
 */

/**
 * AggregationCursor stream readable event
 *
 * @event AggregationCursor#readable
 * @type ***REMOVED***null***REMOVED***
 */

// Inherit from Readable
inherits(AggregationCursor, Readable);

// Extend the Cursor
for(var name in CoreCursor.prototype) ***REMOVED***
  AggregationCursor.prototype[name] = CoreCursor.prototype[name];
***REMOVED***

var define = AggregationCursor.define = new Define('AggregationCursor', AggregationCursor, true);

/**
 * Set the batch size for the cursor.
 * @method
 * @param ***REMOVED***number***REMOVED*** value The batchSize for the cursor.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.batchSize = function(value) ***REMOVED***
  if(this.s.state == AggregationCursor.CLOSED || this.isDead()) throw MongoError.create(***REMOVED***message: "Cursor is closed", driver:true ***REMOVED***);
  if(typeof value != 'number') throw MongoError.create(***REMOVED***message: "batchSize requires an integer", drvier:true ***REMOVED***);
  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
  this.setCursorBatchSize(value);
  return this;
***REMOVED***

define.classMethod('batchSize', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a geoNear stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The geoNear stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.geoNear = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$geoNear: document***REMOVED***);
  return this;
***REMOVED***

define.classMethod('geoNear', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a group stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The group stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.group = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$group: document***REMOVED***);
  return this;
***REMOVED***

define.classMethod('group', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a limit stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** value The state limit value.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.limit = function(value) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$limit: value***REMOVED***);
  return this;
***REMOVED***

define.classMethod('limit', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a match stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The match stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.match = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$match: document***REMOVED***);
  return this;
***REMOVED***

define.classMethod('match', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a maxTimeMS stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** value The state maxTimeMS value.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.maxTimeMS = function(value) ***REMOVED***
  if(this.s.topology.lastIsMaster().minWireVersion > 2) ***REMOVED***
    this.s.cmd.maxTimeMS = value;
  ***REMOVED***
  return this;
***REMOVED***

define.classMethod('maxTimeMS', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a out stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** destination The destination name.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.out = function(destination) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$out: destination***REMOVED***);
  return this;
***REMOVED***

define.classMethod('out', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a project stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The project stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.project = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$project: document***REMOVED***);
  return this;
***REMOVED***

define.classMethod('project', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a lookup stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The lookup stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.lookup = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$lookup: document***REMOVED***);
  return this;
***REMOVED***

define.classMethod('lookup', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a redact stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The redact stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.redact = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$redact: document***REMOVED***);
  return this;
***REMOVED***

define.classMethod('redact', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a skip stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** value The state skip value.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.skip = function(value) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$skip: value***REMOVED***);
  return this;
***REMOVED***

define.classMethod('skip', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a sort stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***object***REMOVED*** document The sort stage document.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.sort = function(document) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$sort: document***REMOVED***);
  return this;
***REMOVED***

define.classMethod('sort', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

/**
 * Add a unwind stage to the aggregation pipeline
 * @method
 * @param ***REMOVED***number***REMOVED*** field The unwind field name.
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */
AggregationCursor.prototype.unwind = function(field) ***REMOVED***
  this.s.cmd.pipeline.push(***REMOVED***$unwind: field***REMOVED***);
  return this;
***REMOVED***

define.classMethod('unwind', ***REMOVED***callback: false, promise:false, returns: [AggregationCursor]***REMOVED***);

AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;

// Inherited methods
define.classMethod('toArray', ***REMOVED***callback: true, promise:true***REMOVED***);
define.classMethod('each', ***REMOVED***callback: true, promise:false***REMOVED***);
define.classMethod('forEach', ***REMOVED***callback: true, promise:false***REMOVED***);
define.classMethod('next', ***REMOVED***callback: true, promise:true***REMOVED***);
define.classMethod('close', ***REMOVED***callback: true, promise:true***REMOVED***);
define.classMethod('isClosed', ***REMOVED***callback: false, promise:false, returns: [Boolean]***REMOVED***);
define.classMethod('rewind', ***REMOVED***callback: false, promise:false***REMOVED***);
define.classMethod('bufferedCount', ***REMOVED***callback: false, promise:false, returns: [Number]***REMOVED***);
define.classMethod('readBufferedDocuments', ***REMOVED***callback: false, promise:false, returns: [Array]***REMOVED***);

/**
 * Get the next available document from the cursor, returns null if no more documents are available.
 * @function AggregationCursor.prototype.next
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * The callback format for results
 * @callback AggregationCursor~toArrayResultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object[]***REMOVED*** documents All the documents the satisfy the cursor.
 */

/**
 * Returns an array of documents. The caller is responsible for making sure that there
 * is enough memory to store the results. Note that the array only contain partial
 * results when this cursor had been previouly accessed. In that case,
 * cursor.rewind() can be used to reset the cursor.
 * @method AggregationCursor.prototype.toArray
 * @param ***REMOVED***AggregationCursor~toArrayResultCallback***REMOVED*** [callback] The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * The callback format for results
 * @callback AggregationCursor~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***(object|null)***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Iterates over all the documents for this cursor. As with *****REMOVED***cursor.toArray***REMOVED*****,
 * not all of the elements will be iterated if this cursor had been previouly accessed.
 * In that case, *****REMOVED***cursor.rewind***REMOVED***** can be used to reset the cursor. However, unlike
 * *****REMOVED***cursor.toArray***REMOVED*****, the cursor will only hold a maximum of batch size elements
 * at any given time if batch size is specified. Otherwise, the caller is responsible
 * for making sure that the entire result can fit the memory.
 * @method AggregationCursor.prototype.each
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** callback The result callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***null***REMOVED***
 */

/**
 * Close the cursor, sending a AggregationCursor command and emitting close.
 * @method AggregationCursor.prototype.close
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * Is the cursor closed
 * @method AggregationCursor.prototype.isClosed
 * @return ***REMOVED***boolean***REMOVED***
 */

/**
 * Execute the explain for the cursor
 * @method AggregationCursor.prototype.explain
 * @param ***REMOVED***AggregationCursor~resultCallback***REMOVED*** [callback] The result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */

/**
 * Clone the cursor
 * @function AggregationCursor.prototype.clone
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */

/**
 * Resets the cursor
 * @function AggregationCursor.prototype.rewind
 * @return ***REMOVED***AggregationCursor***REMOVED***
 */

/**
 * The callback format for the forEach iterator method
 * @callback AggregationCursor~iteratorCallback
 * @param ***REMOVED***Object***REMOVED*** doc An emitted document for the iterator
 */

/**
 * The callback error format for the forEach iterator method
 * @callback AggregationCursor~endCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 */

/*
 * Iterates over all the documents for this cursor using the iterator, callback pattern.
 * @method AggregationCursor.prototype.forEach
 * @param ***REMOVED***AggregationCursor~iteratorCallback***REMOVED*** iterator The iteration callback.
 * @param ***REMOVED***AggregationCursor~endCallback***REMOVED*** callback The end callback.
 * @throws ***REMOVED***MongoError***REMOVED***
 * @return ***REMOVED***null***REMOVED***
 */

AggregationCursor.INIT = 0;
AggregationCursor.OPEN = 1;
AggregationCursor.CLOSED = 2;

module.exports = AggregationCursor;
