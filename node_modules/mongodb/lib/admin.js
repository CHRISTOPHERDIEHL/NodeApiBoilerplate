"use strict";

var toError = require('./utils').toError,
  Define = require('./metadata'),
  shallowClone = require('./utils').shallowClone;

/**
 * @fileOverview The **Admin** class is an internal class that allows convenient access to
 * the admin functionality and commands for MongoDB.
 *
 * **ADMIN Cannot directly be instantiated**
 * @example
 * var MongoClient = require('mongodb').MongoClient,
 *   test = require('assert');
 * // Connection url
 * var url = 'mongodb://localhost:27017/test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, db) ***REMOVED***
 *   // Use the admin database for the operation
 *   var adminDb = db.admin();
 *
 *   // List all the available databases
 *   adminDb.listDatabases(function(err, dbs) ***REMOVED***
 *     test.equal(null, err);
 *     test.ok(dbs.databases.length > 0);
 *     db.close();
 *   ***REMOVED***);
 * ***REMOVED***);
 */

/**
 * Create a new Admin instance (INTERNAL TYPE, do not instantiate directly)
 * @class
 * @return ***REMOVED***Admin***REMOVED*** a collection instance.
 */
var Admin = function(db, topology, promiseLibrary) ***REMOVED***
  if(!(this instanceof Admin)) return new Admin(db, topology);

  // Internal state
  this.s = ***REMOVED***
      db: db
    , topology: topology
    , promiseLibrary: promiseLibrary
  ***REMOVED***
***REMOVED***

var define = Admin.define = new Define('Admin', Admin, false);

/**
 * The callback format for results
 * @callback Admin~resultCallback
 * @param ***REMOVED***MongoError***REMOVED*** error An error instance representing the error during the execution.
 * @param ***REMOVED***object***REMOVED*** result The result object if the command was executed successfully.
 */

/**
 * Execute a command
 * @method
 * @param ***REMOVED***object***REMOVED*** command The command hash
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(ReadPreference|string)***REMOVED*** [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
 * @param ***REMOVED***number***REMOVED*** [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.command = function(command, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() : ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand(command, options, function(err, doc) ***REMOVED***
    return callback != null ? callback(err, doc) : null;
  ***REMOVED***);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.executeDbAdminCommand(command, options, function(err, doc) ***REMOVED***
      if(err) return reject(err);
      resolve(doc);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('command', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieve the server information for the current
 * instance of the db client
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.buildInfo = function(callback) ***REMOVED***
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return this.serverInfo(callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.serverInfo(function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('buildInfo', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieve the server information for the current
 * instance of the db client
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.serverInfo = function(callback) ***REMOVED***
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand(***REMOVED***buildinfo:1***REMOVED***, function(err, doc) ***REMOVED***
    if(err != null) return callback(err, null);
    callback(null, doc);
  ***REMOVED***);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.executeDbAdminCommand(***REMOVED***buildinfo:1***REMOVED***, function(err, doc) ***REMOVED***
      if(err) return reject(err);
      resolve(doc);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('serverInfo', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieve this db's server status.
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.serverStatus = function(callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return serverStatus(self, callback)

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    serverStatus(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var serverStatus = function(self, callback) ***REMOVED***
  self.s.db.executeDbAdminCommand(***REMOVED***serverStatus: 1***REMOVED***, function(err, doc) ***REMOVED***
    if(err == null && doc.ok === 1) ***REMOVED***
      callback(null, doc);
    ***REMOVED*** else ***REMOVED***
      if(err) return callback(err, false);
      return callback(toError(doc), false);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.classMethod('serverStatus', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrieve the current profiling Level for MongoDB
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.profilingLevel = function(callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return profilingLevel(self, callback)

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    profilingLevel(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var profilingLevel = function(self, callback) ***REMOVED***
  self.s.db.executeDbAdminCommand(***REMOVED***profile:-1***REMOVED***, function(err, doc) ***REMOVED***
    if(err == null && doc.ok === 1) ***REMOVED***
      var was = doc.was;
      if(was == 0) return callback(null, "off");
      if(was == 1) return callback(null, "slow_only");
      if(was == 2) return callback(null, "all");
        return callback(new Error("Error: illegal profiling level value " + was), null);
    ***REMOVED*** else ***REMOVED***
      err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

define.classMethod('profilingLevel', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Ping the MongoDB server and retrieve results
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.ping = function(options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);

  // Execute using callback
  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand(***REMOVED***ping: 1***REMOVED***, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.executeDbAdminCommand(***REMOVED***ping: 1***REMOVED***, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('ping', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Authenticate a user against the server.
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***string***REMOVED*** [password] The password.
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.authenticate = function(username, password, options, callback) ***REMOVED***
  var self = this;
  if(typeof options == 'function') callback = options, options = ***REMOVED******REMOVED***;
  options = shallowClone(options);
  options.authdb = 'admin';

  // Execute using callback
  if(typeof callback == 'function') return this.s.db.authenticate(username, password, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.authenticate(username, password, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('authenticate', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Logout user from server, fire off on all connections and remove all auth info
 * @method
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.logout = function(callback) ***REMOVED***
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return this.s.db.logout(***REMOVED***dbName: 'admin'***REMOVED***, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.logout(***REMOVED***dbName: 'admin'***REMOVED***, function(err) ***REMOVED***
      if(err) return reject(err);
      resolve(true);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('logout', ***REMOVED***callback: true, promise:true***REMOVED***);

// Get write concern
var writeConcern = function(options, db) ***REMOVED***
  options = shallowClone(options);

  // If options already contain write concerns return it
  if(options.w || options.wtimeout || options.j || options.fsync) ***REMOVED***
    return options;
  ***REMOVED***

  // Set db write concern if available
  if(db.writeConcern) ***REMOVED***
    if(options.w) options.w = db.writeConcern.w;
    if(options.wtimeout) options.wtimeout = db.writeConcern.wtimeout;
    if(options.j) options.j = db.writeConcern.j;
    if(options.fsync) options.fsync = db.writeConcern.fsync;
  ***REMOVED***

  // Return modified options
  return options;
***REMOVED***

/**
 * Add a user to the database.
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***string***REMOVED*** password The password.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.fsync=false] Specify a file sync write concern.
 * @param ***REMOVED***object***REMOVED*** [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
 * @param ***REMOVED***object[]***REMOVED*** [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.addUser = function(username, password, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() : ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  // Get the options
  options = writeConcern(options, self.s.db)
  // Set the db name to admin
  options.dbName = 'admin';

  // Execute using callback
  if(typeof callback == 'function')
    return self.s.db.addUser(username, password, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.addUser(username, password, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('addUser', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Remove a user from a database
 * @method
 * @param ***REMOVED***string***REMOVED*** username The username.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***(number|string)***REMOVED*** [options.w=null] The write concern.
 * @param ***REMOVED***number***REMOVED*** [options.wtimeout=null] The write concern timeout.
 * @param ***REMOVED***boolean***REMOVED*** [options.j=false] Specify a journal write concern.
 * @param ***REMOVED***boolean***REMOVED*** [options.fsync=false] Specify a file sync write concern.
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.removeUser = function(username, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() : ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;
  // Get the options
  options = writeConcern(options, self.s.db)
  // Set the db name
  options.dbName = 'admin';

  // Execute using callback
  if(typeof callback == 'function')
    return self.s.db.removeUser(username, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.removeUser(username, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('removeUser', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Set the current profiling level of MongoDB
 *
 * @param ***REMOVED***string***REMOVED*** level The new profiling level (off, slow_only, all).
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.setProfilingLevel = function(level, callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return setProfilingLevel(self, level, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    setProfilingLevel(self, level, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var setProfilingLevel = function(self, level, callback) ***REMOVED***
  var command = ***REMOVED******REMOVED***;
  var profile = 0;

  if(level == "off") ***REMOVED***
    profile = 0;
  ***REMOVED*** else if(level == "slow_only") ***REMOVED***
    profile = 1;
  ***REMOVED*** else if(level == "all") ***REMOVED***
    profile = 2;
  ***REMOVED*** else ***REMOVED***
    return callback(new Error("Error: illegal profiling level value " + level));
  ***REMOVED***

  // Set up the profile number
  command['profile'] = profile;

  self.s.db.executeDbAdminCommand(command, function(err, doc) ***REMOVED***
    if(err == null && doc.ok === 1)
      return callback(null, level);
    return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
  ***REMOVED***);
***REMOVED***

define.classMethod('setProfilingLevel', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Retrive the current profiling information for MongoDB
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.profilingInfo = function(callback) ***REMOVED***
  var self = this;

  // Execute using callback
  if(typeof callback == 'function') return profilingInfo(self, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    profilingInfo(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var profilingInfo = function(self, callback) ***REMOVED***
  try ***REMOVED***
    self.s.topology.cursor("admin.system.profile", ***REMOVED*** find: 'system.profile', query: ***REMOVED******REMOVED******REMOVED***, ***REMOVED******REMOVED***).toArray(callback);
  ***REMOVED*** catch (err) ***REMOVED***
    return callback(err, null);
  ***REMOVED***
***REMOVED***

define.classMethod('profilingLevel', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Validate an existing collection
 *
 * @param ***REMOVED***string***REMOVED*** collectionName The name of the collection to validate.
 * @param ***REMOVED***object***REMOVED*** [options=null] Optional settings.
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.validateCollection = function(collectionName, options, callback) ***REMOVED***
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  callback = args.pop();
  if(typeof callback != 'function') args.push(callback);
  options = args.length ? args.shift() : ***REMOVED******REMOVED***;
  options = options || ***REMOVED******REMOVED***;

  // Execute using callback
  if(typeof callback == 'function')
    return validateCollection(self, collectionName, options, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    validateCollection(self, collectionName, options, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var validateCollection = function(self, collectionName, options, callback) ***REMOVED***
  var command = ***REMOVED***validate: collectionName***REMOVED***;
  var keys = Object.keys(options);

  // Decorate command with extra options
  for(var i = 0; i < keys.length; i++) ***REMOVED***
    if(options.hasOwnProperty(keys[i])) ***REMOVED***
      command[keys[i]] = options[keys[i]];
    ***REMOVED***
  ***REMOVED***

  self.s.db.command(command, function(err, doc) ***REMOVED***
    if(err != null) return callback(err, null);

    if(doc.ok === 0)
      return callback(new Error("Error with validate command"), null);
    if(doc.result != null && doc.result.constructor != String)
      return callback(new Error("Error with validation data"), null);
    if(doc.result != null && doc.result.match(/exception|corrupt/) != null)
      return callback(new Error("Error: invalid collection " + collectionName), null);
    if(doc.valid != null && !doc.valid)
      return callback(new Error("Error: invalid collection " + collectionName), null);

    return callback(null, doc);
  ***REMOVED***);
***REMOVED***

define.classMethod('validateCollection', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * List the available databases
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.listDatabases = function(callback) ***REMOVED***
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return self.s.db.executeDbAdminCommand(***REMOVED***listDatabases:1***REMOVED***, ***REMOVED******REMOVED***, callback);

  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    self.s.db.executeDbAdminCommand(***REMOVED***listDatabases:1***REMOVED***, ***REMOVED******REMOVED***, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

define.classMethod('listDatabases', ***REMOVED***callback: true, promise:true***REMOVED***);

/**
 * Get ReplicaSet status
 *
 * @param ***REMOVED***Admin~resultCallback***REMOVED*** [callback] The command result callback.
 * @return ***REMOVED***Promise***REMOVED*** returns Promise if no callback passed
 */
Admin.prototype.replSetGetStatus = function(callback) ***REMOVED***
  var self = this;
  // Execute using callback
  if(typeof callback == 'function') return replSetGetStatus(self, callback);
  // Return a Promise
  return new this.s.promiseLibrary(function(resolve, reject) ***REMOVED***
    replSetGetStatus(self, function(err, r) ***REMOVED***
      if(err) return reject(err);
      resolve(r);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

var replSetGetStatus = function(self, callback) ***REMOVED***
  self.s.db.executeDbAdminCommand(***REMOVED***replSetGetStatus:1***REMOVED***, function(err, doc) ***REMOVED***
    if(err == null && doc.ok === 1)
      return callback(null, doc);
    if(err) return callback(err, false);
    callback(toError(doc), false);
  ***REMOVED***);
***REMOVED***

define.classMethod('replSetGetStatus', ***REMOVED***callback: true, promise:true***REMOVED***);

module.exports = Admin;
