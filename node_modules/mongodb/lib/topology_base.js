"use strict";

var MongoError = require('mongodb-core').MongoError
  , f = require('util').format;

// The store of ops
var Store = function(topology, storeOptions) ***REMOVED***
  var self = this;
  var storedOps = [];
  storeOptions = storeOptions || ***REMOVED***force:false, bufferMaxEntries: -1***REMOVED***

  // Internal state
  this.s = ***REMOVED***
      storedOps: storedOps
    , storeOptions: storeOptions
    , topology: topology
  ***REMOVED***

  Object.defineProperty(this, 'length', ***REMOVED***
    enumerable:true, get: function() ***REMOVED*** return self.s.storedOps.length; ***REMOVED***
  ***REMOVED***);
***REMOVED***

Store.prototype.add = function(opType, ns, ops, options, callback) ***REMOVED***
  if(this.s.storeOptions.force) ***REMOVED***
    return callback(MongoError.create(***REMOVED***message: "db closed by application", driver:true***REMOVED***));
  ***REMOVED***

  if(this.s.storeOptions.bufferMaxEntries == 0) ***REMOVED***
    return callback(MongoError.create(***REMOVED***message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true ***REMOVED***));
  ***REMOVED***

  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) ***REMOVED***
    while(this.s.storedOps.length > 0) ***REMOVED***
      var op = this.s.storedOps.shift();
      op.c(MongoError.create(***REMOVED***message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true ***REMOVED***));
    ***REMOVED***

    return;
  ***REMOVED***

  this.s.storedOps.push(***REMOVED***t: opType, n: ns, o: ops, op: options, c: callback***REMOVED***)
***REMOVED***

Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) ***REMOVED***
  if(this.s.storeOptions.force) ***REMOVED***
    return callback(MongoError.create(***REMOVED***message: "db closed by application", driver:true ***REMOVED***));
  ***REMOVED***

  if(this.s.storeOptions.bufferMaxEntries == 0) ***REMOVED***
    return callback(MongoError.create(***REMOVED***message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true ***REMOVED***));
  ***REMOVED***

  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) ***REMOVED***
    while(this.s.storedOps.length > 0) ***REMOVED***
      var op = this.s.storedOps.shift();
      op.c(MongoError.create(***REMOVED***message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true ***REMOVED***));
    ***REMOVED***

    return;
  ***REMOVED***

  this.s.storedOps.push(***REMOVED***t: opType, m: method, o: object, p: params, c: callback***REMOVED***)
***REMOVED***

Store.prototype.flush = function(err) ***REMOVED***
  while(this.s.storedOps.length > 0) ***REMOVED***
    this.s.storedOps.shift().c(err || MongoError.create(***REMOVED***message: f("no connection available for operation"), driver:true ***REMOVED***));
  ***REMOVED***
***REMOVED***

var primaryOptions = ['primary', 'primaryPreferred', 'nearest', 'secondaryPreferred'];
var secondaryOptions = ['secondary', 'secondaryPreferred'];

Store.prototype.execute = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Get current ops
  var ops = this.s.storedOps;
  // Reset the ops
  this.s.storedOps = [];

  // Unpack options
  var executePrimary = typeof options.executePrimary === 'boolean'
    ? options.executePrimary : true;
  var executeSecondary = typeof options.executeSecondary === 'boolean'
    ? options.executeSecondary : true;

  // Execute all the stored ops
  while(ops.length > 0) ***REMOVED***
    var op = ops.shift();

    if(op.t == 'cursor') ***REMOVED***
      if(executePrimary && executeSecondary) ***REMOVED***
        op.o[op.m].apply(op.o, op.p);
      ***REMOVED*** else if(executePrimary && op.o.options
        && op.o.options.readPreference
        && primaryOptions.indexOf(op.o.options.readPreference.mode) != -1) ***REMOVED***
          op.o[op.m].apply(op.o, op.p);
      ***REMOVED*** else if(!executePrimary && executeSecondary && op.o.options
        && op.o.options.readPreference
        && secondaryOptions.indexOf(op.o.options.readPreference.mode) != -1) ***REMOVED***
          op.o[op.m].apply(op.o, op.p);
      ***REMOVED***
    ***REMOVED*** else if(op.t == 'auth') ***REMOVED***
      this.s.topology[op.t].apply(this.s.topology, op.o);
    ***REMOVED*** else ***REMOVED***
      if(executePrimary && executeSecondary) ***REMOVED***
        this.s.topology[op.t](op.n, op.o, op.op, op.c);
      ***REMOVED*** else if(executePrimary && op.op && op.op.readPreference
        && primaryOptions.indexOf(op.op.readPreference.mode) != -1) ***REMOVED***
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
      ***REMOVED*** else if(!executePrimary && executeSecondary && op.op && op.op.readPreference
        && secondaryOptions.indexOf(op.op.readPreference.mode) != -1) ***REMOVED***
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

Store.prototype.all = function() ***REMOVED***
  return this.s.storedOps;
***REMOVED***

// Server capabilities
var ServerCapabilities = function(ismaster) ***REMOVED***
  var setup_get_property = function(object, name, value) ***REMOVED***
    Object.defineProperty(object, name, ***REMOVED***
        enumerable: true
      , get: function () ***REMOVED*** return value; ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  // Capabilities
  var aggregationCursor = false;
  var writeCommands = false;
  var textSearch = false;
  var authCommands = false;
  var listCollections = false;
  var listIndexes = false;
  var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;
  var commandsTakeWriteConcern = false;
  var commandsTakeCollation = false;

  if(ismaster.minWireVersion >= 0) ***REMOVED***
    textSearch = true;
  ***REMOVED***

  if(ismaster.maxWireVersion >= 1) ***REMOVED***
    aggregationCursor = true;
    authCommands = true;
  ***REMOVED***

  if(ismaster.maxWireVersion >= 2) ***REMOVED***
    writeCommands = true;
  ***REMOVED***

  if(ismaster.maxWireVersion >= 3) ***REMOVED***
    listCollections = true;
    listIndexes = true;
  ***REMOVED***

  if(ismaster.maxWireVersion >= 5) ***REMOVED***
    commandsTakeWriteConcern = true;
    commandsTakeCollation = true;
  ***REMOVED***

  // If no min or max wire version set to 0
  if(ismaster.minWireVersion == null) ***REMOVED***
    ismaster.minWireVersion = 0;
  ***REMOVED***

  if(ismaster.maxWireVersion == null) ***REMOVED***
    ismaster.maxWireVersion = 0;
  ***REMOVED***

  // Map up read only parameters
  setup_get_property(this, "hasAggregationCursor", aggregationCursor);
  setup_get_property(this, "hasWriteCommands", writeCommands);
  setup_get_property(this, "hasTextSearch", textSearch);
  setup_get_property(this, "hasAuthCommands", authCommands);
  setup_get_property(this, "hasListCollectionsCommand", listCollections);
  setup_get_property(this, "hasListIndexesCommand", listIndexes);
  setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
  setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
  setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
  setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
  setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
***REMOVED***

exports.Store = Store;
exports.ServerCapabilities = ServerCapabilities;
