// Load modules

var Hoek = require('hoek');


// Declare internals

var internals = ***REMOVED******REMOVED***;


exports = module.exports = internals.Topo = function () ***REMOVED***

    this._items = [];
    this.nodes = [];
***REMOVED***;


internals.Topo.prototype.add = function (nodes, options) ***REMOVED***

    var self = this;

    options = options || ***REMOVED******REMOVED***;

    // Validate rules

    var before = [].concat(options.before || []);
    var after = [].concat(options.after || []);
    var group = options.group || '?';
    var sort = options.sort || 0;                   // Used for merging only

    Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);
    Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');
    Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);
    Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');

    ([].concat(nodes)).forEach(function (node, i) ***REMOVED***

        var item = ***REMOVED***
            seq: self._items.length,
            sort: sort,
            before: before,
            after: after,
            group: group,
            node: node
        ***REMOVED***;

        self._items.push(item);
    ***REMOVED***);

    // Insert event

    var error = this._sort();
    Hoek.assert(!error, 'item', (group !== '?' ? 'added into group ' + group : ''), 'created a dependencies error');

    return this.nodes;
***REMOVED***;


internals.Topo.prototype.merge = function (others) ***REMOVED***

    others = [].concat(others);
    for (var o = 0, ol = others.length; o < ol; ++o) ***REMOVED***
        var other = others[o];
        if (other) ***REMOVED***
            for (var i = 0, il = other._items.length; i < il; ++i) ***REMOVED***
                var item = Hoek.shallow(other._items[i]);
                this._items.push(item);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    // Sort items

    this._items.sort(internals.mergeSort);
    for (i = 0, il = this._items.length; i < il; ++i) ***REMOVED***
        this._items[i].seq = i;
    ***REMOVED***

    var error = this._sort();
    Hoek.assert(!error, 'merge created a dependencies error');

    return this.nodes;
***REMOVED***;


internals.mergeSort = function (a, b) ***REMOVED***

    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);
***REMOVED***;


internals.Topo.prototype._sort = function () ***REMOVED***

    // Construct graph

    var groups = ***REMOVED******REMOVED***;
    var graph = ***REMOVED******REMOVED***;
    var graphAfters = ***REMOVED******REMOVED***;

    for (var i = 0, il = this._items.length; i < il; ++i) ***REMOVED***
        var item = this._items[i];
        var seq = item.seq;                         // Unique across all items
        var group = item.group;

        // Determine Groups

        groups[group] = groups[group] || [];
        groups[group].push(seq);

        // Build intermediary graph using 'before'

        graph[seq] = item.before;

        // Build second intermediary graph with 'after'

        var after = item.after;
        for (var j = 0, jl = after.length; j < jl; ++j) ***REMOVED***
            graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
        ***REMOVED***
    ***REMOVED***

    // Expand intermediary graph

    var graphNodes = Object.keys(graph);
    for (i = 0, il = graphNodes.length; i < il; ++i) ***REMOVED***
        var node = graphNodes[i];
        var expandedGroups = [];

        var graphNodeItems = Object.keys(graph[node]);
        for (j = 0, jl = graphNodeItems.length; j < jl; ++j) ***REMOVED***
            group = graph[node][graphNodeItems[j]];
            groups[group] = groups[group] || [];

            for (var k = 0, kl = groups[group].length; k < kl; ++k) ***REMOVED***

                expandedGroups.push(groups[group][k]);
            ***REMOVED***
        ***REMOVED***
        graph[node] = expandedGroups;
    ***REMOVED***

    // Merge intermediary graph using graphAfters into final graph

    var afterNodes = Object.keys(graphAfters);
    for (i = 0, il = afterNodes.length; i < il; ++i) ***REMOVED***
        group = afterNodes[i];

        if (groups[group]) ***REMOVED***
            for (j = 0, jl = groups[group].length; j < jl; ++j) ***REMOVED***
                node = groups[group][j];
                graph[node] = graph[node].concat(graphAfters[group]);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    // Compile ancestors

    var children;
    var ancestors = ***REMOVED******REMOVED***;
    graphNodes = Object.keys(graph);
    for (i = 0, il = graphNodes.length; i < il; ++i) ***REMOVED***
        node = graphNodes[i];
        children = graph[node];

        for (j = 0, jl = children.length; j < jl; ++j) ***REMOVED***
            ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);
        ***REMOVED***
    ***REMOVED***

    // Topo sort

    var visited = ***REMOVED******REMOVED***;
    var sorted = [];

    for (i = 0, il = this._items.length; i < il; ++i) ***REMOVED***
        var next = i;

        if (ancestors[i]) ***REMOVED***
            next = null;
            for (j = 0, jl = this._items.length; j < jl; ++j) ***REMOVED***
                if (visited[j] === true) ***REMOVED***
                    continue;
                ***REMOVED***

                if (!ancestors[j]) ***REMOVED***
                    ancestors[j] = [];
                ***REMOVED***

                var shouldSeeCount = ancestors[j].length;
                var seenCount = 0;
                for (var l = 0, ll = shouldSeeCount; l < ll; ++l) ***REMOVED***
                    if (sorted.indexOf(ancestors[j][l]) >= 0) ***REMOVED***
                        ++seenCount;
                    ***REMOVED***
                ***REMOVED***

                if (seenCount === shouldSeeCount) ***REMOVED***
                    next = j;
                    break;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        if (next !== null) ***REMOVED***
            next = next.toString();         // Normalize to string TODO: replace with seq
            visited[next] = true;
            sorted.push(next);
        ***REMOVED***
    ***REMOVED***

    if (sorted.length !== this._items.length) ***REMOVED***
        return new Error('Invalid dependencies');
    ***REMOVED***

    var seqIndex = ***REMOVED******REMOVED***;
    for (i = 0, il = this._items.length; i < il; ++i) ***REMOVED***

        item = this._items[i];
        seqIndex[item.seq] = item;
    ***REMOVED***

    var sortedNodes = [];
    this._items = sorted.map(function (value) ***REMOVED***

        var sortedItem = seqIndex[value];
        sortedNodes.push(sortedItem.node);
        return sortedItem;
    ***REMOVED***);

    this.nodes = sortedNodes;
***REMOVED***;
