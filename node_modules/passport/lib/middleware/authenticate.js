/**
 * Module dependencies.
 */
var http = require('http')
  , IncomingMessageExt = require('../http/request')
  , AuthenticationError = require('../errors/authenticationerror');


/**
 * Authenticates requests.
 *
 * Applies the `name`ed strategy (or strategies) to the incoming request, in
 * order to authenticate the request.  If authentication is successful, the user
 * will be logged in and populated at `req.user` and a session will be
 * established by default.  If authentication fails, an unauthorized response
 * will be sent.
 *
 * Options:
 *   - `session`          Save login state in session, defaults to _true_
 *   - `successRedirect`  After successful login, redirect to given URL
 *   - `failureRedirect`  After failed login, redirect to given URL
 *   - `assignProperty`   Assign the object provided by the verify callback to given property
 *
 * An optional `callback` can be supplied to allow the application to overrride
 * the default manner in which authentication attempts are handled.  The
 * callback has the following signature, where `user` will be set to the
 * authenticated user on a successful authentication attempt, or `false`
 * otherwise.  An optional `info` argument will be passed, containing additional
 * details provided by the strategy's verify callback.
 *
 *     app.get('/protected', function(req, res, next) ***REMOVED***
 *       passport.authenticate('local', function(err, user, info) ***REMOVED***
 *         if (err) ***REMOVED*** return next(err) ***REMOVED***
 *         if (!user) ***REMOVED*** return res.redirect('/signin') ***REMOVED***
 *         res.redirect('/account');
 *       ***REMOVED***)(req, res, next);
 *     ***REMOVED***);
 *
 * Note that if a callback is supplied, it becomes the application's
 * responsibility to log-in the user, establish a session, and otherwise perform
 * the desired operations.
 *
 * Examples:
 *
 *     passport.authenticate('local', ***REMOVED*** successRedirect: '/', failureRedirect: '/login' ***REMOVED***);
 *
 *     passport.authenticate('basic', ***REMOVED*** session: false ***REMOVED***);
 *
 *     passport.authenticate('twitter');
 *
 * @param ***REMOVED***String|Array***REMOVED*** name
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Function***REMOVED***
 * @api public
 */
module.exports = function authenticate(passport, name, options, callback) ***REMOVED***
  if (typeof options == 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  
  var multi = true;
  
  // Cast `name` to an array, allowing authentication to pass through a chain of
  // strategies.  The first strategy to succeed, redirect, or error will halt
  // the chain.  Authentication failures will proceed through each strategy in
  // series, ultimately failing if all strategies fail.
  //
  // This is typically used on API endpoints to allow clients to authenticate
  // using their preferred choice of Basic, Digest, token-based schemes, etc.
  // It is not feasible to construct a chain of multiple strategies that involve
  // redirection (for example both Facebook and Twitter), since the first one to
  // redirect will halt the chain.
  if (!Array.isArray(name)) ***REMOVED***
    name = [ name ];
    multi = false;
  ***REMOVED***
  
  return function authenticate(req, res, next) ***REMOVED***
    if (http.IncomingMessage.prototype.logIn
        && http.IncomingMessage.prototype.logIn !== IncomingMessageExt.logIn) ***REMOVED***
      require('../framework/connect').__monkeypatchNode();
    ***REMOVED***
    
    
    // accumulator for failures from each strategy in the chain
    var failures = [];
    
    function allFailed() ***REMOVED***
      if (callback) ***REMOVED***
        if (!multi) ***REMOVED***
          return callback(null, false, failures[0].challenge, failures[0].status);
        ***REMOVED*** else ***REMOVED***
          var challenges = failures.map(function(f) ***REMOVED*** return f.challenge; ***REMOVED***);
          var statuses = failures.map(function(f) ***REMOVED*** return f.status; ***REMOVED***);
          return callback(null, false, challenges, statuses);
        ***REMOVED***
      ***REMOVED***
      
      // Strategies are ordered by priority.  For the purpose of flashing a
      // message, the first failure will be displayed.
      var failure = failures[0] || ***REMOVED******REMOVED***
        , challenge = failure.challenge || ***REMOVED******REMOVED***
        , msg;
    
      if (options.failureFlash) ***REMOVED***
        var flash = options.failureFlash;
        if (typeof flash == 'string') ***REMOVED***
          flash = ***REMOVED*** type: 'error', message: flash ***REMOVED***;
        ***REMOVED***
        flash.type = flash.type || 'error';
      
        var type = flash.type || challenge.type || 'error';
        msg = flash.message || challenge.message || challenge;
        if (typeof msg == 'string') ***REMOVED***
          req.flash(type, msg);
        ***REMOVED***
      ***REMOVED***
      if (options.failureMessage) ***REMOVED***
        msg = options.failureMessage;
        if (typeof msg == 'boolean') ***REMOVED***
          msg = challenge.message || challenge;
        ***REMOVED***
        if (typeof msg == 'string') ***REMOVED***
          req.session.messages = req.session.messages || [];
          req.session.messages.push(msg);
        ***REMOVED***
      ***REMOVED***
      if (options.failureRedirect) ***REMOVED***
        return res.redirect(options.failureRedirect);
      ***REMOVED***
    
      // When failure handling is not delegated to the application, the default
      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate
      // header will be set according to the strategies in use (see
      // actions#fail).  If multiple strategies failed, each of their challenges
      // will be included in the response.
      var rchallenge = []
        , rstatus, status;
      
      for (var j = 0, len = failures.length; j < len; j++) ***REMOVED***
        failure = failures[j];
        challenge = failure.challenge;
        status = failure.status;
          
        rstatus = rstatus || status;
        if (typeof challenge == 'string') ***REMOVED***
          rchallenge.push(challenge);
        ***REMOVED***
      ***REMOVED***
    
      res.statusCode = rstatus || 401;
      if (res.statusCode == 401 && rchallenge.length) ***REMOVED***
        res.setHeader('WWW-Authenticate', rchallenge);
      ***REMOVED***
      if (options.failWithError) ***REMOVED***
        return next(new AuthenticationError(http.STATUS_CODES[res.statusCode], rstatus));
      ***REMOVED***
      res.end(http.STATUS_CODES[res.statusCode]);
    ***REMOVED***
    
    (function attempt(i) ***REMOVED***
      var layer = name[i];
      // If no more strategies exist in the chain, authentication has failed.
      if (!layer) ***REMOVED*** return allFailed(); ***REMOVED***
    
      // Get the strategy, which will be used as prototype from which to create
      // a new instance.  Action functions will then be bound to the strategy
      // within the context of the HTTP request/response pair.
      var prototype = passport._strategy(layer);
      if (!prototype) ***REMOVED*** return next(new Error('Unknown authentication strategy "' + layer + '"')); ***REMOVED***
    
      var strategy = Object.create(prototype);
      
      
      // ----- BEGIN STRATEGY AUGMENTATION -----
      // Augment the new strategy instance with action functions.  These action
      // functions are bound via closure the the request/response pair.  The end
      // goal of the strategy is to invoke *one* of these action methods, in
      // order to indicate successful or failed authentication, redirect to a
      // third-party identity provider, etc.
      
      /**
       * Authenticate `user`, with optional `info`.
       *
       * Strategies should call this function to successfully authenticate a
       * user.  `user` should be an object supplied by the application after it
       * has been given an opportunity to verify credentials.  `info` is an
       * optional argument containing additional user information.  This is
       * useful for third-party authentication strategies to pass profile
       * details.
       *
       * @param ***REMOVED***Object***REMOVED*** user
       * @param ***REMOVED***Object***REMOVED*** info
       * @api public
       */
      strategy.success = function(user, info) ***REMOVED***
        if (callback) ***REMOVED***
          return callback(null, user, info);
        ***REMOVED***
      
        info = info || ***REMOVED******REMOVED***;
        var msg;
      
        if (options.successFlash) ***REMOVED***
          var flash = options.successFlash;
          if (typeof flash == 'string') ***REMOVED***
            flash = ***REMOVED*** type: 'success', message: flash ***REMOVED***;
          ***REMOVED***
          flash.type = flash.type || 'success';
        
          var type = flash.type || info.type || 'success';
          msg = flash.message || info.message || info;
          if (typeof msg == 'string') ***REMOVED***
            req.flash(type, msg);
          ***REMOVED***
        ***REMOVED***
        if (options.successMessage) ***REMOVED***
          msg = options.successMessage;
          if (typeof msg == 'boolean') ***REMOVED***
            msg = info.message || info;
          ***REMOVED***
          if (typeof msg == 'string') ***REMOVED***
            req.session.messages = req.session.messages || [];
            req.session.messages.push(msg);
          ***REMOVED***
        ***REMOVED***
        if (options.assignProperty) ***REMOVED***
          req[options.assignProperty] = user;
          return next();
        ***REMOVED***
      
        req.logIn(user, options, function(err) ***REMOVED***
          if (err) ***REMOVED*** return next(err); ***REMOVED***
          
          function complete() ***REMOVED***
            if (options.successReturnToOrRedirect) ***REMOVED***
              var url = options.successReturnToOrRedirect;
              if (req.session && req.session.returnTo) ***REMOVED***
                url = req.session.returnTo;
                delete req.session.returnTo;
              ***REMOVED***
              return res.redirect(url);
            ***REMOVED***
            if (options.successRedirect) ***REMOVED***
              return res.redirect(options.successRedirect);
            ***REMOVED***
            next();
          ***REMOVED***
          
          if (options.authInfo !== false) ***REMOVED***
            passport.transformAuthInfo(info, req, function(err, tinfo) ***REMOVED***
              if (err) ***REMOVED*** return next(err); ***REMOVED***
              req.authInfo = tinfo;
              complete();
            ***REMOVED***);
          ***REMOVED*** else ***REMOVED***
            complete();
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***;
      
      /**
       * Fail authentication, with optional `challenge` and `status`, defaulting
       * to 401.
       *
       * Strategies should call this function to fail an authentication attempt.
       *
       * @param ***REMOVED***String***REMOVED*** challenge
       * @param ***REMOVED***Number***REMOVED*** status
       * @api public
       */
      strategy.fail = function(challenge, status) ***REMOVED***
        if (typeof challenge == 'number') ***REMOVED***
          status = challenge;
          challenge = undefined;
        ***REMOVED***
        
        // push this failure into the accumulator and attempt authentication
        // using the next strategy
        failures.push(***REMOVED*** challenge: challenge, status: status ***REMOVED***);
        attempt(i + 1);
      ***REMOVED***;
      
      /**
       * Redirect to `url` with optional `status`, defaulting to 302.
       *
       * Strategies should call this function to redirect the user (via their
       * user agent) to a third-party website for authentication.
       *
       * @param ***REMOVED***String***REMOVED*** url
       * @param ***REMOVED***Number***REMOVED*** status
       * @api public
       */
      strategy.redirect = function(url, status) ***REMOVED***
        // NOTE: Do not use `res.redirect` from Express, because it can't decide
        //       what it wants.
        //
        //       Express 2.x: res.redirect(url, status)
        //       Express 3.x: res.redirect(status, url) -OR- res.redirect(url, status)
        //         - as of 3.14.0, deprecated warnings are issued if res.redirect(url, status)
        //           is used
        //       Express 4.x: res.redirect(status, url)
        //         - all versions (as of 4.8.7) continue to accept res.redirect(url, status)
        //           but issue deprecated versions
        
        res.statusCode = status || 302;
        res.setHeader('Location', url);
        res.setHeader('Content-Length', '0');
        res.end();
      ***REMOVED***;
      
      /**
       * Pass without making a success or fail decision.
       *
       * Under most circumstances, Strategies should not need to call this
       * function.  It exists primarily to allow previous authentication state
       * to be restored, for example from an HTTP session.
       *
       * @api public
       */
      strategy.pass = function() ***REMOVED***
        next();
      ***REMOVED***;
      
      /**
       * Internal error while performing authentication.
       *
       * Strategies should call this function when an internal error occurs
       * during the process of performing authentication; for example, if the
       * user directory is not available.
       *
       * @param ***REMOVED***Error***REMOVED*** err
       * @api public
       */
      strategy.error = function(err) ***REMOVED***
        if (callback) ***REMOVED***
          return callback(err);
        ***REMOVED***
        
        next(err);
      ***REMOVED***;
      
      // ----- END STRATEGY AUGMENTATION -----
    
      strategy.authenticate(req, options);
    ***REMOVED***)(0); // attempt
  ***REMOVED***;
***REMOVED***;
