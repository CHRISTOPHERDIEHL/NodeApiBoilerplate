"use strict";

var Insert = require('./commands').Insert
  , Update = require('./commands').Update
  , Remove = require('./commands').Remove
  , copy = require('../connection/utils').copy
  , retrieveBSON = require('../connection/utils').retrieveBSON
  , KillCursor = require('../connection/commands').KillCursor
  , GetMore = require('../connection/commands').GetMore
  , Query = require('../connection/commands').Query
  , f = require('util').format
  , CommandResult = require('../connection/command_result')
  , MongoError = require('../error')
  , getReadPreference = require('./shared').getReadPreference;

var BSON = retrieveBSON(),
  Long = BSON.Long;

// Write concern fields
var writeConcernFields = ['w', 'wtimeout', 'j', 'fsync'];

var WireProtocol = function() ***REMOVED******REMOVED***

//
// Needs to support legacy mass insert as well as ordered/unordered legacy
// emulation
//
WireProtocol.prototype.insert = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Default is ordered execution
  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
  ops = Array.isArray(ops) ? ops :[ops];

  // If we have more than a 1000 ops fails
  if(ops.length > 1000) return callback(new MongoError("exceeded maximum write batch size of 1000"));

  // Write concern
  var writeConcern = options.writeConcern || ***REMOVED***w:1***REMOVED***;

  // We are unordered
  if(!ordered || writeConcern.w == 0) ***REMOVED***
    return executeUnordered('insert', Insert, ismaster, ns, bson, pool, ops, options, callback);
  ***REMOVED***

  return executeOrdered('insert', Insert, ismaster, ns, bson, pool, ops, options, callback);
***REMOVED***

WireProtocol.prototype.update = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Default is ordered execution
  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
  ops = Array.isArray(ops) ? ops :[ops];

  // Write concern
  var writeConcern = options.writeConcern || ***REMOVED***w:1***REMOVED***;

  // We are unordered
  if(!ordered || writeConcern.w == 0) ***REMOVED***
    return executeUnordered('update', Update, ismaster, ns, bson, pool, ops, options, callback);
  ***REMOVED***

  return executeOrdered('update', Update, ismaster, ns, bson, pool, ops, options, callback);
***REMOVED***

WireProtocol.prototype.remove = function(pool, ismaster, ns, bson, ops, options, callback) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Default is ordered execution
  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
  ops = Array.isArray(ops) ? ops :[ops];

  // Write concern
  var writeConcern = options.writeConcern || ***REMOVED***w:1***REMOVED***;

  // We are unordered
  if(!ordered || writeConcern.w == 0) ***REMOVED***
    return executeUnordered('remove', Remove, ismaster, ns, bson, pool, ops, options, callback);
  ***REMOVED***

  return executeOrdered('remove', Remove, ismaster, ns, bson, pool, ops, options, callback);
***REMOVED***

WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callback) ***REMOVED***
  // Create a kill cursor command
  var killCursor = new KillCursor(bson, [cursorId]);
  // Execute the kill cursor command
  if(pool && pool.isConnected()) ***REMOVED***
    pool.write(killCursor, ***REMOVED***
      immediateRelease:true, noResponse: true
    ***REMOVED***);
  ***REMOVED***

  // Callback
  if(typeof callback == 'function') callback(null, null);
***REMOVED***

WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, options, callback) ***REMOVED***
  // Create getMore command
  var getMore = new GetMore(bson, ns, cursorState.cursorId, ***REMOVED***numberToReturn: batchSize***REMOVED***);

  // Query callback
  var queryCallback = function(err, result) ***REMOVED***
    if(err) return callback(err);
    // Get the raw message
    var r = result.message;

    // If we have a timed out query or a cursor that was killed
    if((r.responseFlags & (1 << 0)) != 0) ***REMOVED***
      return callback(new MongoError("cursor does not exist, was killed or timed out"), null);
    ***REMOVED***

    // Ensure we have a Long valie cursor id
    var cursorId = typeof r.cursorId == 'number'
      ? Long.fromNumber(r.cursorId)
      : r.cursorId;

    // Set all the values
    cursorState.documents = r.documents;
    cursorState.cursorId = cursorId;

    // Return
    callback(null, null, r.connection);
  ***REMOVED***

  // If we have a raw query decorate the function
  if(raw) ***REMOVED***
    queryCallback.raw = raw;
  ***REMOVED***

  // Check if we need to promote longs
  if(typeof cursorState.promoteLongs == 'boolean') ***REMOVED***
    queryCallback.promoteLongs = cursorState.promoteLongs;
  ***REMOVED***

  if(typeof cursorState.promoteValues == 'boolean') ***REMOVED***
    queryCallback.promoteValues = cursorState.promoteValues;
  ***REMOVED***

  if(typeof cursorState.promoteBuffers == 'boolean') ***REMOVED***
    queryCallback.promoteBuffers = cursorState.promoteBuffers;
  ***REMOVED***

  // Write out the getMore command
  connection.write(getMore, queryCallback);
***REMOVED***

WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Establish type of command
  if(cmd.find) ***REMOVED***
    return setupClassicFind(bson, ns, cmd, cursorState, topology, options)
  ***REMOVED*** else if(cursorState.cursorId != null) ***REMOVED***
    return;
  ***REMOVED*** else if(cmd) ***REMOVED***
    return setupCommand(bson, ns, cmd, cursorState, topology, options);
  ***REMOVED*** else ***REMOVED***
    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
  ***REMOVED***
***REMOVED***

//
// Execute a find command
var setupClassicFind = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Ensure we have at least some options
  options = options || ***REMOVED******REMOVED***;
  // Get the readPreference
  var readPreference = getReadPreference(cmd, options);
  // Set the optional batchSize
  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
  var numberToReturn = 0;

  // Unpack the limit and batchSize values
  if(cursorState.limit == 0) ***REMOVED***
    numberToReturn = cursorState.batchSize;
  ***REMOVED*** else if(cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || (cursorState.limit > 0 && cursorState.batchSize == 0)) ***REMOVED***
    numberToReturn = cursorState.limit;
  ***REMOVED*** else ***REMOVED***
    numberToReturn = cursorState.batchSize;
  ***REMOVED***

  var numberToSkip = cursorState.skip || 0;
  // Build actual find command
  var findCmd = ***REMOVED******REMOVED***;
  // Using special modifier
  var usesSpecialModifier = false;

  // We have a Mongos topology, check if we need to add a readPreference
  if(topology.type == 'mongos' && readPreference) ***REMOVED***
    findCmd['$readPreference'] = readPreference.toJSON();
    usesSpecialModifier = true;
  ***REMOVED***

  // Add special modifiers to the query
  if(cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
  if(cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
  if(cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
  if(cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
  if(cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
  if(cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
  if(cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
  if(cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
  if(cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
  if(cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;

  if(cmd.explain) ***REMOVED***
	// nToReturn must be 0 (match all) or negative (match N and close cursor)
	// nToReturn > 0 will give explain results equivalent to limit(0)
    numberToReturn = -Math.abs(cmd.limit || 0);
    usesSpecialModifier = true;
    findCmd['$explain'] = true;
  ***REMOVED***

  // If we have a special modifier
  if(usesSpecialModifier) ***REMOVED***
    findCmd['$query'] = cmd.query;
  ***REMOVED*** else ***REMOVED***
    findCmd = cmd.query;
  ***REMOVED***

  // Throw on majority readConcern passed in
  if(cmd.readConcern && cmd.readConcern.level != 'local') ***REMOVED***
    throw new MongoError(f('server find command does not support a readConcern level of %s', cmd.readConcern.level));
  ***REMOVED***

  // Remove readConcern, ensure no failing commands
  if(cmd.readConcern) ***REMOVED***
    cmd = copy(cmd);
    delete cmd['readConcern'];
  ***REMOVED***

  // Set up the serialize and ignoreUndefined fields
  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
    ? options.serializeFunctions : false;
  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
    ? options.ignoreUndefined : false;

  // Build Query object
  var query = new Query(bson, ns, findCmd, ***REMOVED***
      numberToSkip: numberToSkip, numberToReturn: numberToReturn
    , checkKeys: false, returnFieldSelector: cmd.fields
    , serializeFunctions: serializeFunctions, ignoreUndefined: ignoreUndefined
  ***REMOVED***);

  // Set query flags
  query.slaveOk = readPreference.slaveOk();

  // Set up the option bits for wire protocol
  if(typeof cmd.tailable == 'boolean') query.tailable = cmd.tailable;
  if(typeof cmd.oplogReplay == 'boolean') query.oplogReplay = cmd.oplogReplay;
  if(typeof cmd.noCursorTimeout == 'boolean') query.noCursorTimeout = cmd.noCursorTimeout;
  if(typeof cmd.awaitData == 'boolean') query.awaitData = cmd.awaitData;
  if(typeof cmd.partial == 'boolean') query.partial = cmd.partial;
  // Return the query
  return query;
***REMOVED***

//
// Set up a command cursor
var setupCommand = function(bson, ns, cmd, cursorState, topology, options) ***REMOVED***
  // Set empty options object
  options = options || ***REMOVED******REMOVED***
  // Get the readPreference
  var readPreference = getReadPreference(cmd, options);
  // Final query
  var finalCmd = ***REMOVED******REMOVED***;
  for(var name in cmd) ***REMOVED***
    finalCmd[name] = cmd[name];
  ***REMOVED***

  // Build command namespace
  var parts = ns.split(/\./);

  // Throw on majority readConcern passed in
  if(cmd.readConcern && cmd.readConcern.level != 'local') ***REMOVED***
    throw new MongoError(f('server %s command does not support a readConcern level of %s', JSON.stringify(cmd), cmd.readConcern.level));
  ***REMOVED***

  // Remove readConcern, ensure no failing commands
  if(cmd.readConcern) delete cmd['readConcern'];

  // Serialize functions
  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
    ? options.serializeFunctions : false;

  // Set up the serialize and ignoreUndefined fields
  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
    ? options.ignoreUndefined : false;

  // We have a Mongos topology, check if we need to add a readPreference
  if(topology.type == 'mongos'
    && readPreference
    && readPreference.preference != 'primary') ***REMOVED***
    finalCmd = ***REMOVED***
      '$query': finalCmd,
      '$readPreference': readPreference.toJSON()
    ***REMOVED***;
  ***REMOVED***

  // Build Query object
  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, ***REMOVED***
      numberToSkip: 0, numberToReturn: -1
    , checkKeys: false, serializeFunctions: serializeFunctions
    , ignoreUndefined: ignoreUndefined
  ***REMOVED***);

  // Set query flags
  query.slaveOk = readPreference.slaveOk();

  // Return the query
  return query;
***REMOVED***

var hasWriteConcern = function(writeConcern) ***REMOVED***
  if(writeConcern.w
    || writeConcern.wtimeout
    || writeConcern.j == true
    || writeConcern.fsync == true
    || Object.keys(writeConcern).length == 0) ***REMOVED***
    return true;
  ***REMOVED***
  return false;
***REMOVED***

var cloneWriteConcern = function(writeConcern) ***REMOVED***
  var wc = ***REMOVED******REMOVED***;
  if(writeConcern.w != null) wc.w = writeConcern.w;
  if(writeConcern.wtimeout != null) wc.wtimeout = writeConcern.wtimeout;
  if(writeConcern.j != null) wc.j = writeConcern.j;
  if(writeConcern.fsync != null) wc.fsync = writeConcern.fsync;
  return wc;
***REMOVED***

//
// Aggregate up all the results
//
var aggregateWriteOperationResults = function(opType, ops, results, connection) ***REMOVED***
  var finalResult = ***REMOVED*** ok: 1, n: 0 ***REMOVED***
  if(opType == 'update') ***REMOVED***
    finalResult.nModified = 0;
  ***REMOVED***

  // Map all the results coming back
  for(var i = 0; i < results.length; i++) ***REMOVED***
    var result = results[i];
    var op = ops[i];

    if((result.upserted || (result.updatedExisting == false)) && finalResult.upserted == null) ***REMOVED***
      finalResult.upserted = [];
    ***REMOVED***

    // Push the upserted document to the list of upserted values
    if(result.upserted) ***REMOVED***
      finalResult.upserted.push(***REMOVED***index: i, _id: result.upserted***REMOVED***);
    ***REMOVED***

    // We have an upsert where we passed in a _id
    if(result.updatedExisting == false && result.n == 1 && result.upserted == null) ***REMOVED***
      finalResult.upserted.push(***REMOVED***index: i, _id: op.q._id***REMOVED***);
    ***REMOVED*** else if(result.updatedExisting == true) ***REMOVED***
      finalResult.nModified += result.n;
    ***REMOVED***

    // We have an insert command
    if(result.ok == 1 && opType == 'insert' && result.err == null) ***REMOVED***
      finalResult.n = finalResult.n + 1;
    ***REMOVED***

    // We have a command error
    if(result != null && result.ok == 0 || result.err || result.errmsg) ***REMOVED***
      if(result.ok == 0) finalResult.ok = 0;
      finalResult.code = result.code;
      finalResult.errmsg = result.errmsg || result.err || result.errMsg;

      // Check if we have a write error
      if(result.code == 11000
        || result.code == 11001
        || result.code == 12582
        || result.code == 16544
        || result.code == 16538
        || result.code == 16542
        || result.code == 14
        || result.code == 13511) ***REMOVED***
        if(finalResult.writeErrors == null) finalResult.writeErrors = [];
        finalResult.writeErrors.push(***REMOVED***
            index: i
          , code: result.code
          , errmsg: result.errmsg || result.err || result.errMsg
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        finalResult.writeConcernError = ***REMOVED***
            code: result.code
          , errmsg: result.errmsg || result.err || result.errMsg
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if(typeof result.n == 'number') ***REMOVED***
      finalResult.n += result.n;
    ***REMOVED*** else ***REMOVED***
      finalResult.n += 1;
    ***REMOVED***

    // Result as expected
    if(result != null && result.lastOp) finalResult.lastOp = result.lastOp;
  ***REMOVED***

  // Return finalResult aggregated results
  return new CommandResult(finalResult, connection);
***REMOVED***

//
// Execute all inserts in an ordered manner
//
var executeOrdered = function(opType ,command, ismaster, ns, bson, pool, ops, options, callback) ***REMOVED***
  var _ops = ops.slice(0);
  // Collect all the getLastErrors
  var getLastErrors = [];
  // Execute an operation
  var executeOp = function(list, _callback) ***REMOVED***
    // No more items in the list
    if(list.length == 0) ***REMOVED***
      return process.nextTick(function() ***REMOVED***
        _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
      ***REMOVED***);
    ***REMOVED***

    // Get the first operation
    var doc = list.shift();
    // Create an insert command
    var op = new command(Query.getRequestId(), ismaster, bson, ns, [doc], options);
    // Write concern
    var optionWriteConcern = options.writeConcern || ***REMOVED***w:1***REMOVED***;
    // Final write concern
    var writeConcern = cloneWriteConcern(optionWriteConcern);

    // Get the db name
    var db = ns.split('.').shift();

    try ***REMOVED***
      // Add binary message to list of commands to execute
      var commands = [op];

      // Add getLastOrdered
      var getLastErrorCmd = ***REMOVED***getlasterror: 1***REMOVED***;
      // Merge all the fields
      for(var i = 0; i < writeConcernFields.length; i++) ***REMOVED***
        if(writeConcern[writeConcernFields[i]] != null) ***REMOVED***
          getLastErrorCmd[writeConcernFields[i]] = writeConcern[writeConcernFields[i]];
        ***REMOVED***
      ***REMOVED***

      // Create a getLastError command
      var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, ***REMOVED***numberToReturn: -1***REMOVED***);
      // Add getLastError command to list of ops to execute
      commands.push(getLastErrorOp);

      // getLastError callback
      var getLastErrorCallback = function(err, result) ***REMOVED***
        if(err) return callback(err);
        // Get the document
        var doc = result.result;
        // Save the getLastError document
        getLastErrors.push(doc);

        // If we have an error terminate
        if(doc.ok == 0 || doc.err || doc.errmsg) ***REMOVED***
          return callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
        ***REMOVED***

        // Execute the next op in the list
        executeOp(list, callback);
      ***REMOVED***

      // Write both commands out at the same time
      pool.write(commands, getLastErrorCallback);
    ***REMOVED*** catch(err) ***REMOVED***
      // We have a serialization error, rewrite as a write error to have same behavior as modern
      // write commands
      getLastErrors.push(***REMOVED*** ok: 1, errmsg: typeof err == 'string' ? err : err.message, code: 14 ***REMOVED***);
      // Return due to an error
      process.nextTick(function() ***REMOVED***
        _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  // Execute the operations
  executeOp(_ops, callback);
***REMOVED***

var executeUnordered = function(opType, command, ismaster, ns, bson, pool, ops, options, callback) ***REMOVED***
  // Total operations to write
  var totalOps = ops.length;
  // Collect all the getLastErrors
  var getLastErrors = [];
  // Write concern
  var optionWriteConcern = options.writeConcern || ***REMOVED***w:1***REMOVED***;
  // Final write concern
  var writeConcern = cloneWriteConcern(optionWriteConcern);
  // Driver level error
  var error;

  // Execute all the operations
  for(var i = 0; i < ops.length; i++) ***REMOVED***
    // Create an insert command
    var op = new command(Query.getRequestId(), ismaster, bson, ns, [ops[i]], options);
    // Get db name
    var db = ns.split('.').shift();

    try ***REMOVED***
      // Add binary message to list of commands to execute
      var commands = [op];

      // If write concern 0 don't fire getLastError
      if(hasWriteConcern(writeConcern)) ***REMOVED***
        var getLastErrorCmd = ***REMOVED***getlasterror: 1***REMOVED***;
        // Merge all the fields
        for(var j = 0; j < writeConcernFields.length; j++) ***REMOVED***
          if(writeConcern[writeConcernFields[j]] != null)
            getLastErrorCmd[writeConcernFields[j]] = writeConcern[writeConcernFields[j]];
        ***REMOVED***

        // Create a getLastError command
        var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, ***REMOVED***numberToReturn: -1***REMOVED***);
        // Add getLastError command to list of ops to execute
        commands.push(getLastErrorOp);

        // Give the result from getLastError the right index
        var callbackOp = function(_index) ***REMOVED***
          return function(err, result) ***REMOVED***
            if(err) error = err;
            // Update the number of operations executed
            totalOps = totalOps - 1;
            // Save the getLastError document
            if(!err) getLastErrors[_index] = result.result;
            // Check if we are done
            if(totalOps == 0) ***REMOVED***
              process.nextTick(function() ***REMOVED***
                if(error) return callback(error);
                callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
              ***REMOVED***);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***

        // Write both commands out at the same time
        pool.write(commands, callbackOp(i));
      ***REMOVED*** else ***REMOVED***
        pool.write(commands, ***REMOVED***immediateRelease:true, noResponse:true***REMOVED***);
      ***REMOVED***
    ***REMOVED*** catch(err) ***REMOVED***
      // Update the number of operations executed
      totalOps = totalOps - 1;
      // We have a serialization error, rewrite as a write error to have same behavior as modern
      // write commands
      getLastErrors[i] = ***REMOVED*** ok: 1, errmsg: typeof err == 'string' ? err : err.message, code: 14 ***REMOVED***;
      // Check if we are done
      if(totalOps == 0) ***REMOVED***
        callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Empty w:0 return
  if(writeConcern
    && writeConcern.w == 0 && callback) ***REMOVED***
    callback(null, new CommandResult(***REMOVED***ok:1***REMOVED***, null));
  ***REMOVED***
***REMOVED***

module.exports = WireProtocol;
