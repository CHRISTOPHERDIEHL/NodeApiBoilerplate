"use strict"

var os = require('os'),
  f = require('util').format;

/**
 * Emit event if it exists
 * @method
 */
function emitSDAMEvent(self, event, description) ***REMOVED***
  if(self.listeners(event).length > 0) ***REMOVED***
    self.emit(event, description);
  ***REMOVED***
***REMOVED***

// Get package.json variable
var driverVersion = require(__dirname + '/../../package.json').version;
var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
var type = os.type();
var name = process.platform;
var architecture = process.arch;
var release = os.release();

function createClientInfo(options) ***REMOVED***
  // Build default client information
  var clientInfo = options.clientInfo ? clone(options.clientInfo) : ***REMOVED***
    driver: ***REMOVED***
      name: "nodejs-core",
      version: driverVersion
    ***REMOVED***,
    os: ***REMOVED***
      type: type,
      name: name,
      architecture: architecture,
      version: release
    ***REMOVED***
  ***REMOVED***

  // Is platform specified
  if(clientInfo.platform && clientInfo.platform.indexOf('mongodb-core') == -1) ***REMOVED***
    clientInfo.platform = f('%s, mongodb-core: %s', clientInfo.platform, driverVersion);
  ***REMOVED*** else if(!clientInfo.platform)***REMOVED***
    clientInfo.platform = nodejsversion;
  ***REMOVED***

  // Do we have an application specific string
  if(options.appname) ***REMOVED***
    // Cut at 128 bytes
    var buffer = new Buffer(options.appname);
    // Return the truncated appname
    var appname = buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname;
    // Add to the clientInfo
    clientInfo.application = ***REMOVED*** name: appname ***REMOVED***;
  ***REMOVED***

  return clientInfo;
***REMOVED***

function clone(object) ***REMOVED***
  return JSON.parse(JSON.stringify(object));
***REMOVED***

var getPreviousDescription = function(self) ***REMOVED***
  if(!self.s.serverDescription) ***REMOVED***
    self.s.serverDescription = ***REMOVED***
      address: self.name,
      arbiters: [], hosts: [], passives: [], type: 'Unknown'
    ***REMOVED***
  ***REMOVED***

  return self.s.serverDescription;
***REMOVED***

var emitServerDescriptionChanged = function(self, description) ***REMOVED***
  if(self.listeners('serverDescriptionChanged').length > 0) ***REMOVED***
    // Emit the server description changed events
    self.emit('serverDescriptionChanged', ***REMOVED***
      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name,
      previousDescription: getPreviousDescription(self),
      newDescription: description
    ***REMOVED***);

    self.s.serverDescription = description;
  ***REMOVED***
***REMOVED***

var getPreviousTopologyDescription = function(self) ***REMOVED***
  if(!self.s.topologyDescription) ***REMOVED***
    self.s.topologyDescription = ***REMOVED***
      topologyType: 'Unknown',
      servers: [***REMOVED***
        address: self.name, arbiters: [], hosts: [], passives: [], type: 'Unknown'
      ***REMOVED***]
    ***REMOVED***
  ***REMOVED***

  return self.s.topologyDescription;
***REMOVED***

var emitTopologyDescriptionChanged = function(self, description) ***REMOVED***
  if(self.listeners('topologyDescriptionChanged').length > 0) ***REMOVED***
    // Emit the server description changed events
    self.emit('topologyDescriptionChanged', ***REMOVED***
      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name,
      previousDescription: getPreviousTopologyDescription(self),
      newDescription: description
    ***REMOVED***);

    self.s.serverDescription = description;
  ***REMOVED***
***REMOVED***

var changedIsMaster = function(self, currentIsmaster, ismaster) ***REMOVED***
  var currentType = getTopologyType(self, currentIsmaster);
  var newType = getTopologyType(self, ismaster);
  if(newType != currentType) return true;
  return false;
***REMOVED***

var getTopologyType = function(self, ismaster) ***REMOVED***
  if(!ismaster) ***REMOVED***
    ismaster = self.ismaster;
  ***REMOVED***

  if(!ismaster) return 'Unknown';
  if(ismaster.ismaster && !ismaster.hosts) return 'Standalone';
  if(ismaster.ismaster && ismaster.msg == 'isdbgrid') return 'Mongos';
  if(ismaster.ismaster) return 'RSPrimary';
  if(ismaster.secondary) return 'RSSecondary';
  if(ismaster.arbiterOnly) return 'RSArbiter';
  return 'Unknown';
***REMOVED***

var inquireServerState = function(self) ***REMOVED***
  return function(callback) ***REMOVED***
    if(self.s.state == 'destroyed') return;
    // Record response time
    var start = new Date().getTime();

    // emitSDAMEvent
    emitSDAMEvent(self, 'serverHeartbeatStarted', ***REMOVED*** connectionId: self.name ***REMOVED***);

    // Attempt to execute ismaster command
    self.command('admin.$cmd', ***REMOVED*** ismaster:true ***REMOVED***,  ***REMOVED*** monitoring:true ***REMOVED***, function(err, r) ***REMOVED***
      if(!err) ***REMOVED***
        // Legacy event sender
        self.emit('ismaster', r, self);

        // Calculate latencyMS
        var latencyMS = new Date().getTime() - start;

        // Server heart beat event
        emitSDAMEvent(self, 'serverHeartbeatSucceeded', ***REMOVED*** durationMS: latencyMS, reply: r.result, connectionId: self.name ***REMOVED***);

        // Did the server change
        if(changedIsMaster(self, self.s.ismaster, r.result)) ***REMOVED***
          // Emit server description changed if something listening
          emitServerDescriptionChanged(self, ***REMOVED***
            address: self.name, arbiters: [], hosts: [], passives: [], type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)
          ***REMOVED***);
        ***REMOVED***

        // Updat ismaster view
        self.s.ismaster = r.result;

        // Set server response time
        self.s.isMasterLatencyMS = latencyMS;
      ***REMOVED*** else ***REMOVED***
        emitSDAMEvent(self, 'serverHeartbeatFailed', ***REMOVED*** durationMS: latencyMS, failure: err, connectionId: self.name ***REMOVED***);
      ***REMOVED***

      // Peforming an ismaster monitoring callback operation
      if(typeof callback == 'function') ***REMOVED***
        return callback(err, r);
      ***REMOVED***

      // Perform another sweep
      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***

// Object.assign method or polyfille
var assign = Object.assign ? Object.assign : function assign(target) ***REMOVED***
  if (target === undefined || target === null) ***REMOVED***
    throw new TypeError('Cannot convert first argument to object');
  ***REMOVED***

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) ***REMOVED***
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) ***REMOVED***
      continue;
    ***REMOVED***

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) ***REMOVED***
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) ***REMOVED***
        to[nextKey] = nextSource[nextKey];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return to;
***REMOVED***

//
// Clone the options
var cloneOptions = function(options) ***REMOVED***
  var opts = ***REMOVED******REMOVED***;
  for(var name in options) ***REMOVED***
    opts[name] = options[name];
  ***REMOVED***
  return opts;
***REMOVED***

module.exports.inquireServerState = inquireServerState
module.exports.getTopologyType = getTopologyType;
module.exports.emitServerDescriptionChanged = emitServerDescriptionChanged;
module.exports.emitTopologyDescriptionChanged = emitTopologyDescriptionChanged;
module.exports.cloneOptions = cloneOptions;
module.exports.assign = assign;
module.exports.createClientInfo = createClientInfo;
module.exports.clone = clone;
