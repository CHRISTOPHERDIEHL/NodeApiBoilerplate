"use strict"

var inherits = require('util').inherits,
  f = require('util').format,
  EventEmitter = require('events').EventEmitter,
  Logger = require('../connection/logger'),
  ReadPreference = require('./read_preference'),
  MongoError = require('../error');

var TopologyType = ***REMOVED***
  'Single': 'Single', 'ReplicaSetNoPrimary': 'ReplicaSetNoPrimary',
  'ReplicaSetWithPrimary': 'ReplicaSetWithPrimary', 'Sharded': 'Sharded',
  'Unknown': 'Unknown'
***REMOVED***;

var ServerType = ***REMOVED***
  'Standalone': 'Standalone', 'Mongos': 'Mongos', 'PossiblePrimary': 'PossiblePrimary',
  'RSPrimary': 'RSPrimary', 'RSSecondary': 'RSSecondary', 'RSArbiter': 'RSArbiter',
  'RSOther': 'RSOther', 'RSGhost': 'RSGhost', 'Unknown': 'Unknown'
***REMOVED***;

var ReplSetState = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  // Add event listener
  EventEmitter.call(this);
  // Topology state
  this.topologyType = TopologyType.ReplicaSetNoPrimary;
  this.setName = options.setName;

  // Server set
  this.set = ***REMOVED******REMOVED***;

  // Unpacked options
  this.id = options.id;
  this.setName = options.setName;

  // Replicaset logger
  this.logger = options.logger || Logger('ReplSet', options);

  // Server selection index
  this.index = 0;
  // Acceptable latency
  this.acceptableLatency = options.acceptableLatency || 15;

  // heartbeatFrequencyMS
  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;

  // Server side
  this.primary = null;
  this.secondaries = [];
  this.arbiters = [];
  this.passives = [];
  this.ghosts = [];
  // Current unknown hosts
  this.unknownServers = [];
  // In set status
  this.set = ***REMOVED******REMOVED***;
  // Status
  this.maxElectionId = null;
  this.maxSetVersion = 0;
  // Description of the Replicaset
  this.replicasetDescription = ***REMOVED***
    "topologyType": "Unknown", "servers": []
  ***REMOVED***;
***REMOVED***

inherits(ReplSetState, EventEmitter);

ReplSetState.prototype.hasPrimaryAndSecondary = function() ***REMOVED***
  return this.primary != null && this.secondaries.length > 0;
***REMOVED***

ReplSetState.prototype.hasPrimary = function() ***REMOVED***
  return this.primary != null;
***REMOVED***

ReplSetState.prototype.hasSecondary = function() ***REMOVED***
  return this.secondaries.length > 0;
***REMOVED***

ReplSetState.prototype.allServers = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  var servers = this.primary ? [this.primary] : [];
  servers = servers.concat(this.secondaries);
  if(!options.ignoreArbiters) servers = servers.concat(this.arbiters);
  servers = servers.concat(this.passives);
  return servers;
***REMOVED***

ReplSetState.prototype.destroy = function(options) ***REMOVED***
  // Destroy all sockets
  if(this.primary) this.primary.destroy(options);
  this.secondaries.forEach(function(x) ***REMOVED*** x.destroy(options); ***REMOVED***);
  this.arbiters.forEach(function(x) ***REMOVED*** x.destroy(options); ***REMOVED***);
  this.passives.forEach(function(x) ***REMOVED*** x.destroy(options); ***REMOVED***);
  this.ghosts.forEach(function(x) ***REMOVED*** x.destroy(options); ***REMOVED***);
  // Clear out the complete state
  this.secondaries = [];
  this.arbiters = [];
  this.passives = [];
  this.ghosts = [];
  this.unknownServers = [];
  this.set = ***REMOVED******REMOVED***;
***REMOVED***

ReplSetState.prototype.remove = function(server, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  // Only remove if the current server is not connected
  var servers = this.primary ? [this.primary] : [];
  servers = servers.concat(this.secondaries);
  servers = servers.concat(this.arbiters);
  servers = servers.concat(this.passives);

  // Check if it's active and this is just a failed connection attempt
  for(var i = 0; i < servers.length; i++) ***REMOVED***
    if(!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) ***REMOVED***
      return;
    ***REMOVED***
  ***REMOVED***

  // If we have it in the set remove it
  if(this.set[server.name.toLowerCase()]) ***REMOVED***
    this.set[server.name.toLowerCase()].type = ServerType.Unknown;
    this.set[server.name.toLowerCase()].electionId = null;
    this.set[server.name.toLowerCase()].setName = null;
    this.set[server.name.toLowerCase()].setVersion = null;
  ***REMOVED***

  // Remove type
  var removeType = null;

  // Remove from any lists
  if(this.primary && this.primary.equals(server)) ***REMOVED***
    this.primary = null;
    this.topologyType = TopologyType.ReplicaSetNoPrimary;
    removeType = 'primary';
  ***REMOVED***

  // Remove from any other server lists
  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;
  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;
  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;
  removeFrom(server, this.ghosts);
  removeFrom(server, this.unknownServers);

  // Do we have a removeType
  if(removeType) ***REMOVED***
    this.emit('left', removeType, server);
  ***REMOVED***
***REMOVED***

ReplSetState.prototype.update = function(server) ***REMOVED***
  var self = this;
  // Get the current ismaster
  var ismaster = server.lastIsMaster();

  //
  // Add any hosts
  //
  if(ismaster) ***REMOVED***
    // Join all the possible new hosts
    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);

    // Add all hosts as unknownServers
    for(var i = 0; i < hosts.length; i++) ***REMOVED***
      // Add to the list of unknown server
      if(this.unknownServers.indexOf(hosts[i]) == -1
        && (!this.set[hosts[i].toLowerCase()] || this.set[hosts[i].toLowerCase()].type == ServerType.Unknown)) ***REMOVED***
        this.unknownServers.push(hosts[i]);
      ***REMOVED***

      if(!this.set[hosts[i].toLowerCase()]) ***REMOVED***
        this.set[hosts[i].toLowerCase()] = ***REMOVED***
          type: ServerType.Unknown,
          electionId: null,
          setName: null,
          setVersion: null
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  //
  // Unknown server
  //
  if(!ismaster && !inList(ismaster, server, this.unknownServers)) ***REMOVED***
    self.set[server.name.toLowerCase()] = ***REMOVED***
      type: ServerType.Unknown, setVersion: null, electionId: null, setName: null
    ***REMOVED***
    // Update set information about the server instance
    self.set[server.name.toLowerCase()].type = ServerType.Unknown;
    self.set[server.name.toLowerCase()].electionId = ismaster ? ismaster.electionId : ismaster;
    self.set[server.name.toLowerCase()].setName = ismaster ? ismaster.setName : ismaster;
    self.set[server.name.toLowerCase()].setVersion = ismaster ? ismaster.setVersion : ismaster;

    if(self.unknownServers.indexOf(server.name) == -1) ***REMOVED***
      self.unknownServers.push(server.name);
    ***REMOVED***

    // Set the topology
    return false;
  ***REMOVED***

  //
  // Is this a mongos
  //
  if(ismaster && ismaster.msg == 'isdbgrid') ***REMOVED***
    return false;
  ***REMOVED***

  // A RSOther instance
  if((ismaster.setName && ismaster.hidden)
    || (ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive)) ***REMOVED***
    self.set[server.name.toLowerCase()] = ***REMOVED***
      type: ServerType.RSOther, setVersion: null,
      electionId: null, setName: ismaster.setName
    ***REMOVED***
    // Set the topology
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
    if(ismaster.setName) this.setName = ismaster.setName;
    return false;
  ***REMOVED***

  // A RSGhost instance
  if(ismaster.isreplicaset) ***REMOVED***
    self.set[server.name.toLowerCase()] = ***REMOVED***
      type: ServerType.RSGhost, setVersion: null,
      electionId: null, setName: null
    ***REMOVED***

    // Set the topology
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
    if(ismaster.setName) this.setName = ismaster.setName;

    // Set the topology
    return false;
  ***REMOVED***

  //
  // Standalone server, destroy and return
  //
  if(ismaster && ismaster.ismaster && !ismaster.setName) ***REMOVED***
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
    this.remove(server, ***REMOVED***force:true***REMOVED***);
    return false;
  ***REMOVED***

  //
  // Server in maintanance mode
  //
  if(ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) ***REMOVED***
    this.remove(server, ***REMOVED***force:true***REMOVED***);
    return false;
  ***REMOVED***

  //
  // If the .me field does not match the passed in server
  //
  if(ismaster.me && ismaster.me != server.name) ***REMOVED***
    if(this.logger.isWarn()) ***REMOVED***
      this.logger.warn(f('the seedlist server was removed due to its address %s not matching its ismaster.me address %s', server.name, ismaster.me));
    ***REMOVED***

    // Delete from the set
    delete this.set[server.name.toLowerCase()];

    // Set the type of topology we have
    if(this.primary && !this.primary.equals(server)) ***REMOVED***
      this.topologyType = TopologyType.ReplicaSetWithPrimary;
    ***REMOVED*** else ***REMOVED***
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
    ***REMOVED***

    //
    // We have a potential primary
    //
    if(!this.primary && ismaster.primary) ***REMOVED***
      this.set[ismaster.primary.toLowerCase()] = ***REMOVED***
        type: ServerType.PossiblePrimary,
        setName: null,
        electionId: null,
        setVersion: null,
      ***REMOVED***
    ***REMOVED***

    return false;
  ***REMOVED***

  //
  // Primary handling
  //
  if(!this.primary && ismaster.ismaster && ismaster.setName) ***REMOVED***
    var ismasterElectionId = server.lastIsMaster().electionId;
    if(this.setName && this.setName != ismaster.setName) ***REMOVED***
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      return new MongoError(f('setName from ismaster does not match provided connection setName [%s] != [%s]', ismaster.setName, this.setName));
    ***REMOVED***

    if(!this.maxElectionId && ismasterElectionId) ***REMOVED***
      this.maxElectionId = ismasterElectionId;
    ***REMOVED*** else if(this.maxElectionId && ismasterElectionId) ***REMOVED***
      var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
      // Get the electionIds
      var ismasterSetVersion = server.lastIsMaster().setVersion;

      // if(result == 1 || result == 0) ***REMOVED***
      if(result == 1) ***REMOVED***
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      ***REMOVED*** else if(result == 0 && ismasterSetVersion) ***REMOVED***
        if(ismasterSetVersion < this.maxSetVersion) ***REMOVED***
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return false;
        ***REMOVED***
      ***REMOVED***

      this.maxSetVersion = ismasterSetVersion;
      this.maxElectionId = ismasterElectionId;
    ***REMOVED***

    // Hande normalization of server names
    var normalizedHosts = ismaster.hosts.map(function(x) ***REMOVED*** return x.toLowerCase() ***REMOVED***);
    var locationIndex = normalizedHosts.indexOf(server.name.toLowerCase());

    // Validate that the server exists in the host list
    if(locationIndex != -1) ***REMOVED***
      self.primary = server;
      self.set[server.name.toLowerCase()] = ***REMOVED***
        type: ServerType.RSPrimary,
        setVersion: ismaster.setVersion,
        electionId: ismaster.electionId,
        setName: ismaster.setName
      ***REMOVED***

      // Set the topology
      this.topologyType = TopologyType.ReplicaSetWithPrimary;
      if(ismaster.setName) this.setName = ismaster.setName;
      removeFrom(server, self.unknownServers);
      removeFrom(server, self.secondaries);
      removeFrom(server, self.passives);
      self.emit('joined', 'primary', server);
    ***REMOVED*** else ***REMOVED***
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
    ***REMOVED***

    emitTopologyDescriptionChanged(self);
    return true;
  ***REMOVED*** else if(ismaster.ismaster && ismaster.setName) ***REMOVED***
    // Get the electionIds
    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;
    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;
    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;
    ismasterElectionId = server.lastIsMaster().electionId;
    ismasterSetVersion = server.lastIsMaster().setVersion;
    var ismasterSetName = server.lastIsMaster().setName;

    // Is it the same server instance
    if(this.primary.equals(server)
      && currentSetName == ismasterSetName) ***REMOVED***
        return false;
    ***REMOVED***

    // If we do not have the same rs name
    if(currentSetName && currentSetName != ismasterSetName) ***REMOVED***
      if(!this.primary.equals(server)) ***REMOVED***
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
      ***REMOVED*** else ***REMOVED***
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
      ***REMOVED***

      return false;
    ***REMOVED***

    // Check if we need to replace the server
    if(currentElectionId && ismasterElectionId) ***REMOVED***
      result = compareObjectIds(currentElectionId, ismasterElectionId);

      if(result == 1) ***REMOVED***
        return false;
      ***REMOVED*** else if(result == 0 && (currentSetVersion > ismasterSetVersion)) ***REMOVED***
        return false;
      ***REMOVED***
    ***REMOVED*** else if(!currentElectionId && ismasterElectionId
      && ismasterSetVersion) ***REMOVED***
        if(ismasterSetVersion < this.maxSetVersion) ***REMOVED***
          return false;
        ***REMOVED***
    ***REMOVED***

    if(!this.maxElectionId && ismasterElectionId) ***REMOVED***
      this.maxElectionId = ismasterElectionId;
    ***REMOVED*** else if(this.maxElectionId && ismasterElectionId) ***REMOVED***
      result = compareObjectIds(this.maxElectionId, ismasterElectionId);

      if(result == 1) ***REMOVED***
        return false;
      ***REMOVED*** else if(result == 0 && currentSetVersion && ismasterSetVersion) ***REMOVED***
        if(ismasterSetVersion < this.maxSetVersion) ***REMOVED***
          return false;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        if(ismasterSetVersion < this.maxSetVersion) ***REMOVED***
          return false;
        ***REMOVED***
      ***REMOVED***

      this.maxElectionId = ismasterElectionId;
      this.maxSetVersion = ismasterSetVersion;
    ***REMOVED*** else ***REMOVED***
      this.maxSetVersion = ismasterSetVersion;
    ***REMOVED***

    // Modify the entry to unknown
    self.set[self.primary.name.toLowerCase()] = ***REMOVED***
      type: ServerType.Unknown, setVersion: null,
      electionId: null, setName: null
    ***REMOVED***

    // Signal primary left
    self.emit('left', 'primary', this.primary);
    // Destroy the instance
    self.primary.destroy();
    // Set the new instance
    self.primary = server;
    // Set the set information
    self.set[server.name.toLowerCase()] = ***REMOVED***
      type: ServerType.RSPrimary, setVersion: ismaster.setVersion,
      electionId: ismaster.electionId, setName: ismaster.setName
    ***REMOVED***

    // Set the topology
    this.topologyType = TopologyType.ReplicaSetWithPrimary;
    if(ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);
    removeFrom(server, self.secondaries);
    removeFrom(server, self.passives);
    self.emit('joined', 'primary', server);
    emitTopologyDescriptionChanged(self);
    return true;
  ***REMOVED***

  // A possible instance
  if(!this.primary && ismaster.primary) ***REMOVED***
    self.set[ismaster.primary.toLowerCase()] = ***REMOVED***
      type: ServerType.PossiblePrimary, setVersion: null,
      electionId: null, setName: null
    ***REMOVED***
  ***REMOVED***

  //
  // Secondary handling
  //
  if(ismaster.secondary && ismaster.setName
    && !inList(ismaster, server, this.secondaries)
    && this.setName && this.setName == ismaster.setName) ***REMOVED***
    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);
    // Set the topology
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
    if(ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);

    // Remove primary
    if(this.primary && this.primary.name == server.name) ***REMOVED***
      server.destroy();
      this.primary = null;
      self.emit('left', 'primary', server);
    ***REMOVED***

    self.emit('joined', 'secondary', server);
    emitTopologyDescriptionChanged(self);
    return true;
  ***REMOVED***

  //
  // Arbiter handling
  //
  if(ismaster.arbiterOnly && ismaster.setName
    && !inList(ismaster, server, this.arbiters)
    && this.setName && this.setName == ismaster.setName) ***REMOVED***
    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);
    // Set the topology
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
    if(ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);
    self.emit('joined', 'arbiter', server);
    emitTopologyDescriptionChanged(self);
    return true;
  ***REMOVED***

  //
  // Passive handling
  //
  if(ismaster.passive && ismaster.setName
    && !inList(ismaster, server, this.passives)
    && this.setName && this.setName == ismaster.setName) ***REMOVED***
    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);
    // Set the topology
    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
    if(ismaster.setName) this.setName = ismaster.setName;
    removeFrom(server, self.unknownServers);

    // Remove primary
    if(this.primary && this.primary.name == server.name) ***REMOVED***
      server.destroy();
      this.primary = null;
      self.emit('left', 'primary', server);
    ***REMOVED***

    self.emit('joined', 'secondary', server);
    emitTopologyDescriptionChanged(self);
    return true;
  ***REMOVED***

  //
  // Remove the primary
  //
  if(this.set[server.name.toLowerCase()] && this.set[server.name.toLowerCase()].type == ServerType.RSPrimary) ***REMOVED***
    self.emit('left', 'primary', this.primary);
    this.primary.destroy();
    this.primary = null;
    this.topologyType = TopologyType.ReplicaSetNoPrimary;
    return false;
  ***REMOVED***

  this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
  return false;
***REMOVED***

/**
 * Recalculate single server max staleness
 * @method
 */
ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) ***REMOVED***
  // Locate the max secondary lastwrite
  var max = 0;
  // Go over all secondaries
  for(var i = 0; i < this.secondaries.length; i++) ***REMOVED***
    max = Math.max(max, this.secondaries[i].lastWriteDate);
  ***REMOVED***

  // Perform this servers staleness calculation
  if(server.ismaster.maxWireVersion >= 5
    && server.ismaster.secondary
    && this.hasPrimary()) ***REMOVED***
    server.staleness = (server.lastUpdateTime - server.lastWriteDate)
      - (this.primary.lastUpdateTime - this.primary.lastWriteDate)
      + haInterval;
  ***REMOVED*** else if(server.ismaster.maxWireVersion >= 5
    && server.ismaster.secondary)***REMOVED***
    server.staleness = max - server.lastWriteDate + haInterval;
  ***REMOVED***
***REMOVED***

/**
 * Recalculate all the stalness values for secodaries
 * @method
 */
ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) ***REMOVED***
  for(var i = 0; i < this.secondaries.length; i++) ***REMOVED***
    this.updateServerMaxStaleness(this.secondaries[i], haInterval);
  ***REMOVED***
***REMOVED***

/**
 * Pick a server by the passed in ReadPreference
 * @method
 * @param ***REMOVED***ReadPreference***REMOVED*** readPreference The ReadPreference instance to use
 */
ReplSetState.prototype.pickServer = function(readPreference) ***REMOVED***
  // If no read Preference set to primary by default
  readPreference = readPreference || ReadPreference.primary;

  // maxStalenessSeconds is not allowed with a primary read
  if(readPreference.preference == 'primary' && readPreference.maxStalenessSeconds != null) ***REMOVED***
    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');
  ***REMOVED***

  // Check if we have any non compatible servers for maxStalenessSeconds
  var allservers = this.primary ? [this.primary] : [];
  allservers = allservers.concat(this.secondaries);

  // Does any of the servers not support the right wire protocol version
  // for maxStalenessSeconds when maxStalenessSeconds specified on readPreference. Then error out
  if(readPreference.maxStalenessSeconds != null) ***REMOVED***
    for(var i = 0; i < allservers.length; i++) ***REMOVED***
      if(allservers[i].ismaster.maxWireVersion < 5) ***REMOVED***
        return new MongoError('maxStalenessSeconds not supported by at least one of the replicaset members');
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Do we have the nearest readPreference
  if(readPreference.preference == 'nearest' && readPreference.maxStalenessSeconds == null) ***REMOVED***
    return pickNearest(this, readPreference);
  ***REMOVED*** else if(readPreference.preference == 'nearest' && readPreference.maxStalenessSeconds != null) ***REMOVED***
    return pickNearestMaxStalenessSeconds(this, readPreference);
  ***REMOVED***

  // Get all the secondaries
  var secondaries = this.secondaries;

  // Check if we can satisfy and of the basic read Preferences
  if(readPreference.equals(ReadPreference.secondary)
    && secondaries.length == 0) ***REMOVED***
      return new MongoError("no secondary server available");
    ***REMOVED***

  if(readPreference.equals(ReadPreference.secondaryPreferred)
    && secondaries.length == 0
    && this.primary == null) ***REMOVED***
      return new MongoError("no secondary or primary server available");
    ***REMOVED***

  if(readPreference.equals(ReadPreference.primary)
    && this.primary == null) ***REMOVED***
      return new MongoError("no primary server available");
    ***REMOVED***

  // Secondary preferred or just secondaries
  if(readPreference.equals(ReadPreference.secondaryPreferred)
    || readPreference.equals(ReadPreference.secondary)) ***REMOVED***

    if(secondaries.length > 0 && readPreference.maxStalenessSeconds == null) ***REMOVED***
      // Pick nearest of any other servers available
      var server = pickNearest(this, readPreference);
      // No server in the window return primary
      if(server) ***REMOVED***
        return server;
      ***REMOVED***
    ***REMOVED*** else if(secondaries.length > 0 && readPreference.maxStalenessSeconds != null) ***REMOVED***
      // Pick nearest of any other servers available
      server = pickNearestMaxStalenessSeconds(this, readPreference);
      // No server in the window return primary
      if(server) ***REMOVED***
        return server;
      ***REMOVED***
    ***REMOVED***

    if(readPreference.equals(ReadPreference.secondaryPreferred))***REMOVED***
      return this.primary;
    ***REMOVED***

    return null;
  ***REMOVED***

  // Primary preferred
  if(readPreference.equals(ReadPreference.primaryPreferred)) ***REMOVED***
    server = null;

    // We prefer the primary if it's available
    if(this.primary) ***REMOVED***
      return this.primary;
    ***REMOVED***

    // Pick a secondary
    if(secondaries.length > 0 && readPreference.maxStalenessSeconds == null) ***REMOVED***
      server = pickNearest(this, readPreference);
    ***REMOVED*** else if(secondaries.length > 0 && readPreference.maxStalenessSeconds != null) ***REMOVED***
      server = pickNearestMaxStalenessSeconds(this, readPreference);
    ***REMOVED***

    //  Did we find a server
    if(server) return server;
  ***REMOVED***

  // Return the primary
  return this.primary;
***REMOVED***

//
// Filter serves by tags
var filterByTags = function(readPreference, servers) ***REMOVED***
  if(readPreference.tags == null) return servers;
  var filteredServers = [];
  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];

  // Iterate over the tags
  for(var j = 0; j < tagsArray.length; j++) ***REMOVED***
    var tags = tagsArray[j];

    // Iterate over all the servers
    for(var i = 0; i < servers.length; i++) ***REMOVED***
      var serverTag = servers[i].lastIsMaster().tags || ***REMOVED******REMOVED***;

      // Did we find the a matching server
      var found = true;
      // Check if the server is valid
      for(var name in tags) ***REMOVED***
        if(serverTag[name] != tags[name]) ***REMOVED***
          found = false;
        ***REMOVED***
      ***REMOVED***

      // Add to candidate list
      if(found) ***REMOVED***
        filteredServers.push(servers[i]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Returned filtered servers
  return filteredServers;
***REMOVED***

function pickNearestMaxStalenessSeconds(self, readPreference) ***REMOVED***
  // Only get primary and secondaries as seeds
  var servers = [];
  var heartbeatFrequencyMS = self.heartbeatFrequencyMS;

  // Get the maxStalenessMS
  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000;

  // Check if the maxStalenessMS > 90 seconds
  if(maxStalenessMS < 90 * 1000) ***REMOVED***
    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');
  ***REMOVED***

  // Add primary to list if not a secondary read preference
  if(self.primary && readPreference.preference != 'secondary') ***REMOVED***
    servers.push(self.primary);
  ***REMOVED***

  // Add all the secondaries
  for(var i = 0; i < self.secondaries.length; i++) ***REMOVED***
    servers.push(self.secondaries[i]);
  ***REMOVED***

  // Filter by tags
  servers = filterByTags(readPreference, servers);

  //
  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)
  // var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;

  // Filter by latency
  servers = servers.filter(function(s) ***REMOVED***
    return s.staleness <= maxStalenessMS;
  ***REMOVED***);

  // Sort by time
  servers.sort(function(a, b) ***REMOVED***
    // return a.time > b.time;
    return a.lastIsMasterMS > b.lastIsMasterMS
  ***REMOVED***);

  // No servers, default to primary
  if(servers.length == 0) ***REMOVED***
    return null
  ***REMOVED***

  // Ensure index does not overflow the number of available servers
  self.index = self.index % servers.length;

  // Get the server
  var server = servers[self.index];
  // Add to the index
  self.index = self.index + 1;
  // Return the first server of the sorted and filtered list
  return server;
***REMOVED***

function pickNearest(self, readPreference) ***REMOVED***
  // Only get primary and secondaries as seeds
  var servers = [];

  // Add primary to list if not a secondary read preference
  if(self.primary && readPreference.preference != 'secondary') ***REMOVED***
    servers.push(self.primary);
  ***REMOVED***

  // Add all the secondaries
  for(var i = 0; i < self.secondaries.length; i++) ***REMOVED***
    servers.push(self.secondaries[i]);
  ***REMOVED***

  // Filter by tags
  servers = filterByTags(readPreference, servers);

  // Sort by time
  servers.sort(function(a, b) ***REMOVED***
    // return a.time > b.time;
    return a.lastIsMasterMS > b.lastIsMasterMS
  ***REMOVED***);

  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)
  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;

  // Filter by latency
  servers = servers.filter(function(s) ***REMOVED***
    return s.lastIsMasterMS <= lowest + self.acceptableLatency;
  ***REMOVED***);

  // No servers, default to primary
  if(servers.length == 0) ***REMOVED***
    return null
  ***REMOVED***

  // Ensure index does not overflow the number of available servers
  self.index = self.index % servers.length;
  // Get the server
  var server = servers[self.index];
  // Add to the index
  self.index = self.index + 1;
  // Return the first server of the sorted and filtered list
  return server;
***REMOVED***

function inList(ismaster, server, list) ***REMOVED***
  for(var i = 0; i < list.length; i++) ***REMOVED***
    if(list[i].name == server.name) return true;
  ***REMOVED***

  return false;
***REMOVED***

function addToList(self, type, ismaster, server, list) ***REMOVED***
  // Update set information about the server instance
  self.set[server.name.toLowerCase()].type = type;
  self.set[server.name.toLowerCase()].electionId = ismaster ? ismaster.electionId : ismaster;
  self.set[server.name.toLowerCase()].setName = ismaster ? ismaster.setName : ismaster;
  self.set[server.name.toLowerCase()].setVersion = ismaster ? ismaster.setVersion : ismaster;
  // Add to the list
  list.push(server);
***REMOVED***

function compareObjectIds(id1, id2) ***REMOVED***
  var a = new Buffer(id1.toHexString(), 'hex');
  var b = new Buffer(id2.toHexString(), 'hex');

  if(a === b) ***REMOVED***
    return 0;
  ***REMOVED***

  if(typeof Buffer.compare === 'function') ***REMOVED***
    return Buffer.compare(a, b);
  ***REMOVED***

  var x = a.length;
  var y = b.length;
  var len = Math.min(x, y);

  for (var i = 0; i < len; i++) ***REMOVED***
    if (a[i] !== b[i]) ***REMOVED***
      break;
    ***REMOVED***
  ***REMOVED***

  if (i !== len) ***REMOVED***
    x = a[i];
    y = b[i];
  ***REMOVED***

  return x < y ? -1 : y < x ? 1 : 0;
***REMOVED***

function removeFrom(server, list) ***REMOVED***
  for(var i = 0; i < list.length; i++) ***REMOVED***
    if(list[i].equals && list[i].equals(server)) ***REMOVED***
      list.splice(i, 1);
      return true;
    ***REMOVED*** else if(typeof list[i] == 'string' && list[i] == server.name) ***REMOVED***
      list.splice(i, 1);
      return true;
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

function emitTopologyDescriptionChanged(self) ***REMOVED***
  if(self.listeners('topologyDescriptionChanged').length > 0) ***REMOVED***
    var topology = 'Unknown';
    var setName = self.setName;

    if(self.hasPrimaryAndSecondary()) ***REMOVED***
      topology = 'ReplicaSetWithPrimary';
    ***REMOVED*** else if(!self.hasPrimary() && self.hasSecondary()) ***REMOVED***
      topology = 'ReplicaSetNoPrimary';
    ***REMOVED***

    // Generate description
    var description = ***REMOVED***
      topologyType: topology,
      setName: setName,
      servers: []
    ***REMOVED***

    // Add the primary to the list
    if(self.hasPrimary()) ***REMOVED***
      var desc = self.primary.getDescription();
      desc.type = 'RSPrimary';
      description.servers.push(desc);
    ***REMOVED***

    // Add all the secondaries
    description.servers = description.servers.concat(self.secondaries.map(function(x) ***REMOVED***
      var description = x.getDescription();
      description.type = 'RSSecondary';
      return description;
    ***REMOVED***));

    // Add all the arbiters
    description.servers = description.servers.concat(self.arbiters.map(function(x) ***REMOVED***
      var description = x.getDescription();
      description.type = 'RSArbiter';
      return description;
    ***REMOVED***));

    // Add all the passives
    description.servers = description.servers.concat(self.passives.map(function(x) ***REMOVED***
      var description = x.getDescription();
      description.type = 'RSSecondary';
      return description;
    ***REMOVED***));

    // Create the result
    var result = ***REMOVED***
      topologyId: self.id,
      previousDescription: self.replicasetDescription,
      newDescription: description,
      diff: diff(self.replicasetDescription, description)
    ***REMOVED***;

    // Emit the topologyDescription change
    self.emit('topologyDescriptionChanged', result);

    // Set the new description
    self.replicasetDescription = description;
  ***REMOVED***
***REMOVED***

function diff(previous, current) ***REMOVED***
  // Difference document
  var diff = ***REMOVED***
    servers: []
  ***REMOVED***

  // Previous entry
  if(!previous) ***REMOVED***
    previous = ***REMOVED*** servers: [] ***REMOVED***;
  ***REMOVED***

  // Got through all the servers
  for(var i = 0; i < previous.servers.length; i++) ***REMOVED***
    var prevServer = previous.servers[i];

    // Go through all current servers
    for(var j = 0; j < current.servers.length; j++) ***REMOVED***
      var currServer = current.servers[j];

      // Matching server
      if(prevServer.address === currServer.address) ***REMOVED***
        // We had a change in state
        if(prevServer.type != currServer.type) ***REMOVED***
          diff.servers.push(***REMOVED***
            address: prevServer.address,
            from: prevServer.type,
            to: currServer.type
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // Return difference
  return diff;
***REMOVED***

module.exports = ReplSetState;
