/**
 * Module dependencies.
 */
var passport = require('passport-strategy')
  , crypto = require('crypto')
  , util = require('util');


/**
 * `DigestStrategy` constructor.
 *
 * The HTTP Digest authentication strategy authenticates requests based on
 * username and digest credentials contained in the `Authorization` header
 * field.
 *
 * Applications must supply a `secret` callback, which is used to look up the
 * user and corresponding password (aka shared secret) known to both the server
 * and the client, supplying them to the `done` callback as `user` and
 *`password`, respectively.  The strategy will use the password to compute the
 * response hash, failing authentication if it does not match that found in the
 * request. If the username is not valid, `user` should be set to false.  If an
 * exception occured, `err` should be set.
 *
 * An optional `validate` callback can be supplied, which receives `params`
 * containing nonces that the server may want to track and validate.
 *
 * Options:
 *   - `realm`      authentication realm, defaults to "Users"
 *   - `domain`     list of URIs that define the protection space
 *   - `algorithm`  algorithm used to produce the digest (MD5 | MD5-sess)
 *   - `qop`        list of quality of protection values support by the server (auth | auth-int) (recommended: auth)
 *
 * `validate` params:
 *   - `nonce`   unique string value specified by the server
 *   - `cnonce`  opaque string value provided by the client
 *   - `nc`      count of the number of requests (including the current request) that the client has sent with the nonce value
 *   - `opaque`  string of data, specified by the server, which should be returned by the client in subsequent requests
 *
 * Examples:
 *
 *     passport.use(new DigestStrategy(***REMOVED*** qop: 'auth' ***REMOVED***,
 *       function(username, done) ***REMOVED***
 *         // secret callback
 *         User.findOne(***REMOVED*** username: username ***REMOVED***, function (err, user) ***REMOVED***
 *           if (err) ***REMOVED*** return done(err); ***REMOVED***
 *           return done(null, user, user.password);
 *         ***REMOVED***);
 *       ***REMOVED***,
 *       function(params, done) ***REMOVED***
 *         // validate callback, check nonces in params...
 *         done(err, true);
 *       ***REMOVED***
 *     ));
 *
 * For further details on HTTP Basic authentication, refer to [RFC 2617: HTTP Authentication: Basic and Digest Access Authentication](http://tools.ietf.org/html/rfc2617)
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @param ***REMOVED***Function***REMOVED*** secret
 * @param ***REMOVED***Function***REMOVED*** validate
 * @api public
 */
function DigestStrategy(options, secret, validate) ***REMOVED***
  if (typeof options == 'function') ***REMOVED***
    validate = secret;
    secret = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***
  if (!secret) throw new Error('HTTP Digest authentication strategy requires a secret function');
  
  passport.Strategy.call(this);
  this.name = 'digest';
  this._secret = secret;
  this._validate = validate;
  this._realm = options.realm || 'Users';
  if (options.domain) ***REMOVED***
    this._domain = (Array.isArray(options.domain)) ? options.domain : [ options.domain ];
  ***REMOVED***
  this._opaque = options.opaque;
  this._algorithm = options.algorithm;
  if (options.qop) ***REMOVED***
    this._qop = (Array.isArray(options.qop)) ? options.qop : [ options.qop ];
  ***REMOVED***
***REMOVED***

/**
 * Inherit from `passport.Strategy`.
 */
util.inherits(DigestStrategy, passport.Strategy);

/**
 * Authenticate request based on the contents of a HTTP Digest authorization
 * header.
 *
 * @param ***REMOVED***Object***REMOVED*** req
 * @api protected
 */
DigestStrategy.prototype.authenticate = function(req) ***REMOVED***
  var authorization = req.headers['authorization'];
  if (!authorization) ***REMOVED*** return this.fail(this._challenge()); ***REMOVED***
  
  var parts = authorization.split(' ')
  if (parts.length < 2) ***REMOVED*** return this.fail(400); ***REMOVED***
  
  var scheme = parts[0]
    , params = parts.slice(1).join(' ');
  
  if (!/Digest/i.test(scheme)) ***REMOVED*** return this.fail(this._challenge()); ***REMOVED***
  
  var creds = parse(params);
  if (Object.keys(creds).length === 0) ***REMOVED*** return this.fail(400); ***REMOVED***
  
  if (!creds.username) ***REMOVED***
    return this.fail(this._challenge());
  ***REMOVED***
  if (req.url !== creds.uri) ***REMOVED***
    return this.fail(400);
  ***REMOVED***
  
  
  var self = this;
  
  // Use of digest authentication requires a password (aka shared secret) known
  // to both the client and server, but not transported over the wire.  This
  // secret is needed in order to compute the hashes required to authenticate
  // the request, and can be obtained by calling the secret() function the
  // application provides to the strategy.  Because username is the key for a
  // database query, a `user` instance is also obtained from this callback.
  // However, the user will only be successfully authenticated if the password
  // is correct, as indicated by the challenge response matching the computed
  // value.
  this._secret(creds.username, function(err, user, password) ***REMOVED***
    if (err) ***REMOVED*** return self.error(err); ***REMOVED***
    if (!user) ***REMOVED*** return self.fail(self._challenge()); ***REMOVED***
    
    var ha1;
    if (!creds.algorithm || creds.algorithm === 'MD5') ***REMOVED***
      if (typeof password === 'object' && password.ha1) ***REMOVED***
        ha1 = password.ha1;
      ***REMOVED*** else  ***REMOVED***
        ha1 = md5(creds.username + ":" + creds.realm + ":" + password);
      ***REMOVED***
    ***REMOVED*** else if (creds.algorithm === 'MD5-sess') ***REMOVED***
      // TODO: The nonce and cnonce used here should be the initial nonce
      //       value generated by the server and the first nonce value used by
      //       the client.  This creates a 'session key' for the authentication
      //       of subsequent requests.  The storage of the nonce values and the
      //       resulting session key needs to be investigated.
      //
      //       See RFC 2617 (Section 3.2.2.2) for further details.
      ha1 = md5(md5(creds.username + ":" + creds.realm + ":" + password) + ":" + creds.nonce + ":" + creds.cnonce);
    ***REMOVED*** else ***REMOVED***
      return self.fail(400);
    ***REMOVED***
    
    var ha2;
    if (!creds.qop || creds.qop === 'auth') ***REMOVED***
      ha2 = md5(req.method + ":" + creds.uri);
    ***REMOVED*** else if (creds.qop === 'auth-int') ***REMOVED***
      // TODO: Implement support for auth-int.  Note that the raw entity body
      //       will be needed, not the parsed req.body property set by Connect's
      //       bodyParser middleware.
      //
      //       See RFC 2617 (Section 3.2.2.3 and Section 3.2.2.4) for further
      //       details.
      return self.error(new Error('auth-int not implemented'));
    ***REMOVED*** else ***REMOVED***
      return self.fail(400);
    ***REMOVED***
    
    var digest;
    if (!creds.qop) ***REMOVED***
      digest = md5(ha1 + ":" + creds.nonce + ":" + ha2);
    ***REMOVED*** else if (creds.qop === 'auth' || creds.qop === 'auth-int') ***REMOVED***
      digest = md5(ha1 + ":" + creds.nonce + ":" + creds.nc + ":" + creds.cnonce + ":" + creds.qop + ":" + ha2);
    ***REMOVED*** else ***REMOVED***
      return self.fail(400);
    ***REMOVED***
    
    if (creds.response != digest) ***REMOVED***
      return self.fail(self._challenge());
    ***REMOVED*** else ***REMOVED***
      if (self._validate) ***REMOVED***
        self._validate(***REMOVED***
            nonce: creds.nonce,
            cnonce: creds.cnonce,
            nc: creds.nc,
            opaque: creds.opaque
          ***REMOVED***,
          function(err, valid) ***REMOVED***
            if (err) ***REMOVED*** return self.error(err); ***REMOVED***
            if (!valid) ***REMOVED*** return self.fail(self._challenge()); ***REMOVED***
            self.success(user);
          ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
        self.success(user);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

/**
 * Authentication challenge.
 *
 * @api private
 */
DigestStrategy.prototype._challenge = function() ***REMOVED***
  // TODO: For maximum flexibility, a mechanism for delegating the generation
  //       of the nonce and opaque data to the application would be useful.
  
  var challenge = 'Digest realm="' + this._realm + '"';
  if (this._domain) ***REMOVED***
    challenge += ', domain="' + this._domain.join(' ') + '"';
  ***REMOVED***
  challenge += ', nonce="' + nonce(32) + '"';
  if (this._opaque) ***REMOVED***
    challenge += ', opaque="' + this._opaque + '"';
  ***REMOVED***
  if (this._algorithm) ***REMOVED***
    challenge += ', algorithm=' + this._algorithm;
  ***REMOVED***
  if (this._qop) ***REMOVED***
    challenge += ', qop="' + this._qop.join(',') + '"';
  ***REMOVED***
  
  return challenge;
***REMOVED***


/**
 * Parse authentication response.
 *
 * @api private
 */
function parse(params) ***REMOVED***
  var opts = ***REMOVED******REMOVED***;
  var tokens = params.split(/,(?=(?:[^"]|"[^"]*")*$)/);
  for (var i = 0, len = tokens.length; i < len; i++) ***REMOVED***
    var param = /(\w+)=["]?([^"]+)["]?$/.exec(tokens[i])
    if (param) ***REMOVED***
      opts[param[1]] = param[2];
    ***REMOVED***
  ***REMOVED***
  return opts;
***REMOVED***

/**
 * Return a unique nonce with the given `len`.
 *
 *     utils.uid(10);
 *     // => "FDaS435D2z"
 *
 * CREDIT: Connect -- utils.uid
 *         https://github.com/senchalabs/connect/blob/1.7.1/lib/utils.js
 *
 * @param ***REMOVED***Number***REMOVED*** len
 * @return ***REMOVED***String***REMOVED***
 * @api private
 */
function nonce(len) ***REMOVED***
  var buf = []
    , chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
    , charlen = chars.length;

  for (var i = 0; i < len; ++i) ***REMOVED***
    buf.push(chars[Math.random() * charlen | 0]);
  ***REMOVED***

  return buf.join('');
***REMOVED***;


/**
 * Return md5 hash of the given string and optional encoding,
 * defaulting to hex.
 *
 *     utils.md5('wahoo');
 *     // => "e493298061761236c96b02ea6aa8a2ad"
 *
 * CREDIT: Connect -- utils.md5
 *         https://github.com/senchalabs/connect/blob/1.7.1/lib/utils.js
 *
 * @param ***REMOVED***String***REMOVED*** str
 * @param ***REMOVED***String***REMOVED*** encoding
 * @return ***REMOVED***String***REMOVED***
 * @api private
 */
function md5(str, encoding)***REMOVED***
  return crypto
    .createHash('md5')
    .update(str)
    .digest(encoding || 'hex');
***REMOVED***;


/**
 * Expose `DigestStrategy`.
 */ 
module.exports = DigestStrategy;
