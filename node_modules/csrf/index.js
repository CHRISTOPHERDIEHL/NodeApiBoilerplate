/*!
 * csrf
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module dependencies.
 * @private
 */

var rndm = require('rndm')
var uid = require('uid-safe')
var compare = require('tsscmp')
var crypto = require('crypto')
var escape = require('base64-url').escape

/**
 * Module exports.
 * @public
 */

module.exports = Tokens

/**
 * Token generation/verification class.
 *
 * @param ***REMOVED***object***REMOVED*** [options]
 * @param ***REMOVED***number***REMOVED*** [options.saltLength=8] The string length of the salt
 * @param ***REMOVED***number***REMOVED*** [options.secretLength=18] The byte length of the secret key
 * @public
 */

function Tokens (options) ***REMOVED***
  if (!(this instanceof Tokens)) ***REMOVED***
    return new Tokens(options)
  ***REMOVED***

  var opts = options || ***REMOVED******REMOVED***

  var saltLength = opts.saltLength !== undefined
    ? opts.saltLength
    : 8

  if (typeof saltLength !== 'number' || !isFinite(saltLength) || saltLength < 1) ***REMOVED***
    throw new TypeError('option saltLength must be finite number > 1')
  ***REMOVED***

  var secretLength = opts.secretLength !== undefined
    ? opts.secretLength
    : 18

  if (typeof secretLength !== 'number' || !isFinite(secretLength) || secretLength < 1) ***REMOVED***
    throw new TypeError('option secretLength must be finite number > 1')
  ***REMOVED***

  this.saltLength = saltLength
  this.secretLength = secretLength
***REMOVED***

/**
 * Create a new CSRF token.
 *
 * @param ***REMOVED***string***REMOVED*** secret The secret for the token.
 * @public
 */

Tokens.prototype.create = function create (secret) ***REMOVED***
  if (!secret || typeof secret !== 'string') ***REMOVED***
    throw new TypeError('argument secret is required')
  ***REMOVED***

  return this._tokenize(secret, rndm(this.saltLength))
***REMOVED***

/**
 * Create a new secret key.
 *
 * @param ***REMOVED***function***REMOVED*** [callback]
 * @public
 */

Tokens.prototype.secret = function secret (callback) ***REMOVED***
  return uid(this.secretLength, callback)
***REMOVED***

/**
 * Create a new secret key synchronously.
 * @public
 */

Tokens.prototype.secretSync = function secretSync () ***REMOVED***
  return uid.sync(this.secretLength)
***REMOVED***

/**
 * Tokenize a secret and salt.
 * @private
 */

Tokens.prototype._tokenize = function tokenize (secret, salt) ***REMOVED***
  var hash = crypto
    .createHash('sha1')
    .update(salt + '-' + secret, 'ascii')
    .digest('base64')
  return escape(salt + '-' + hash)
***REMOVED***

/**
 * Verify if a given token is valid for a given secret.
 *
 * @param ***REMOVED***string***REMOVED*** secret
 * @param ***REMOVED***string***REMOVED*** token
 * @public
 */

Tokens.prototype.verify = function verify (secret, token) ***REMOVED***
  if (!secret || typeof secret !== 'string') ***REMOVED***
    return false
  ***REMOVED***

  if (!token || typeof token !== 'string') ***REMOVED***
    return false
  ***REMOVED***

  var index = token.indexOf('-')

  if (index === -1) ***REMOVED***
    return false
  ***REMOVED***

  var salt = token.substr(0, index)
  var expected = this._tokenize(secret, salt)

  return compare(token, expected)
***REMOVED***
