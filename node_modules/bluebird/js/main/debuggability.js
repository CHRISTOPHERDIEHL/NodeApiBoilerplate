"use strict";
module.exports = function(Promise, CapturedTrace) ***REMOVED***
var getDomain = Promise._getDomain;
var async = require("./async.js");
var Warning = require("./errors.js").Warning;
var util = require("./util.js");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var debugging = false || (util.isNode &&
                    (!!process.env["BLUEBIRD_DEBUG"] ||
                     process.env["NODE_ENV"] === "development"));

if (util.isNode && process.env["BLUEBIRD_DEBUG"] == 0) debugging = false;

if (debugging) ***REMOVED***
    async.disableTrampolineIfNecessary();
***REMOVED***

Promise.prototype._ignoreRejections = function() ***REMOVED***
    this._unsetRejectionIsUnhandled();
    this._bitField = this._bitField | 16777216;
***REMOVED***;

Promise.prototype._ensurePossibleRejectionHandled = function () ***REMOVED***
    if ((this._bitField & 16777216) !== 0) return;
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
***REMOVED***;

Promise.prototype._notifyUnhandledRejectionIsHandled = function () ***REMOVED***
    CapturedTrace.fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
***REMOVED***;

Promise.prototype._notifyUnhandledRejection = function () ***REMOVED***
    if (this._isRejectionUnhandled()) ***REMOVED***
        var reason = this._getCarriedStackTrace() || this._settledValue;
        this._setUnhandledRejectionIsNotified();
        CapturedTrace.fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    ***REMOVED***
***REMOVED***;

Promise.prototype._setUnhandledRejectionIsNotified = function () ***REMOVED***
    this._bitField = this._bitField | 524288;
***REMOVED***;

Promise.prototype._unsetUnhandledRejectionIsNotified = function () ***REMOVED***
    this._bitField = this._bitField & (~524288);
***REMOVED***;

Promise.prototype._isUnhandledRejectionNotified = function () ***REMOVED***
    return (this._bitField & 524288) > 0;
***REMOVED***;

Promise.prototype._setRejectionIsUnhandled = function () ***REMOVED***
    this._bitField = this._bitField | 2097152;
***REMOVED***;

Promise.prototype._unsetRejectionIsUnhandled = function () ***REMOVED***
    this._bitField = this._bitField & (~2097152);
    if (this._isUnhandledRejectionNotified()) ***REMOVED***
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    ***REMOVED***
***REMOVED***;

Promise.prototype._isRejectionUnhandled = function () ***REMOVED***
    return (this._bitField & 2097152) > 0;
***REMOVED***;

Promise.prototype._setCarriedStackTrace = function (capturedTrace) ***REMOVED***
    this._bitField = this._bitField | 1048576;
    this._fulfillmentHandler0 = capturedTrace;
***REMOVED***;

Promise.prototype._isCarryingStackTrace = function () ***REMOVED***
    return (this._bitField & 1048576) > 0;
***REMOVED***;

Promise.prototype._getCarriedStackTrace = function () ***REMOVED***
    return this._isCarryingStackTrace()
        ? this._fulfillmentHandler0
        : undefined;
***REMOVED***;

Promise.prototype._captureStackTrace = function () ***REMOVED***
    if (debugging) ***REMOVED***
        this._trace = new CapturedTrace(this._peekContext());
    ***REMOVED***
    return this;
***REMOVED***;

Promise.prototype._attachExtraTrace = function (error, ignoreSelf) ***REMOVED***
    if (debugging && canAttachTrace(error)) ***REMOVED***
        var trace = this._trace;
        if (trace !== undefined) ***REMOVED***
            if (ignoreSelf) trace = trace._parent;
        ***REMOVED***
        if (trace !== undefined) ***REMOVED***
            trace.attachExtraTrace(error);
        ***REMOVED*** else if (!error.__stackCleaned__) ***REMOVED***
            var parsed = CapturedTrace.parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;

Promise.prototype._warn = function(message) ***REMOVED***
    var warning = new Warning(message);
    var ctx = this._peekContext();
    if (ctx) ***REMOVED***
        ctx.attachExtraTrace(warning);
    ***REMOVED*** else ***REMOVED***
        var parsed = CapturedTrace.parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    ***REMOVED***
    CapturedTrace.formatAndLogError(warning, "");
***REMOVED***;

Promise.onPossiblyUnhandledRejection = function (fn) ***REMOVED***
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
***REMOVED***;

Promise.onUnhandledRejectionHandled = function (fn) ***REMOVED***
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
***REMOVED***;

Promise.longStackTraces = function () ***REMOVED***
    if (async.haveItemsQueued() &&
        debugging === false
   ) ***REMOVED***
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
    ***REMOVED***
    debugging = CapturedTrace.isSupported();
    if (debugging) ***REMOVED***
        async.disableTrampolineIfNecessary();
    ***REMOVED***
***REMOVED***;

Promise.hasLongStackTraces = function () ***REMOVED***
    return debugging && CapturedTrace.isSupported();
***REMOVED***;

if (!CapturedTrace.isSupported()) ***REMOVED***
    Promise.longStackTraces = function()***REMOVED******REMOVED***;
    debugging = false;
***REMOVED***

return function() ***REMOVED***
    return debugging;
***REMOVED***;
***REMOVED***;
