"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) ***REMOVED***
var getDomain = Promise._getDomain;
var async = require("./async.js");
var util = require("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var PENDING = ***REMOVED******REMOVED***;
var EMPTY_ARRAY = [];

function MappingPromiseArray(promises, fn, limit, _filter) ***REMOVED***
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : domain.bind(fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
    async.invoke(init, this, undefined);
***REMOVED***
util.inherits(MappingPromiseArray, PromiseArray);
function init() ***REMOVED***this._init$(undefined, -2);***REMOVED***

MappingPromiseArray.prototype._init = function () ***REMOVED******REMOVED***;

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) ***REMOVED***
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;
    if (values[index] === PENDING) ***REMOVED***
        values[index] = value;
        if (limit >= 1) ***REMOVED***
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return;
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (limit >= 1 && this._inFlight >= limit) ***REMOVED***
            values[index] = value;
            this._queue.push(index);
            return;
        ***REMOVED***
        if (preservedValues !== null) preservedValues[index] = value;

        var callback = this._callback;
        var receiver = this._promise._boundValue();
        this._promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        this._promise._popContext();
        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) ***REMOVED***
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) ***REMOVED***
                if (limit >= 1) this._inFlight++;
                values[index] = PENDING;
                return maybePromise._proxyPromiseArray(this, index);
            ***REMOVED*** else if (maybePromise._isFulfilled()) ***REMOVED***
                ret = maybePromise._value();
            ***REMOVED*** else ***REMOVED***
                return this._reject(maybePromise._reason());
            ***REMOVED***
        ***REMOVED***
        values[index] = ret;
    ***REMOVED***
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) ***REMOVED***
        if (preservedValues !== null) ***REMOVED***
            this._filter(values, preservedValues);
        ***REMOVED*** else ***REMOVED***
            this._resolve(values);
        ***REMOVED***

    ***REMOVED***
***REMOVED***;

MappingPromiseArray.prototype._drainQueue = function () ***REMOVED***
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) ***REMOVED***
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    ***REMOVED***
***REMOVED***;

MappingPromiseArray.prototype._filter = function (booleans, values) ***REMOVED***
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) ***REMOVED***
        if (booleans[i]) ret[j++] = values[i];
    ***REMOVED***
    ret.length = j;
    this._resolve(ret);
***REMOVED***;

MappingPromiseArray.prototype.preservedValues = function () ***REMOVED***
    return this._preservedValues;
***REMOVED***;

function map(promises, fn, options, _filter) ***REMOVED***
    var limit = typeof options === "object" && options !== null
        ? options.concurrency
        : 0;
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter);
***REMOVED***

Promise.prototype.map = function (fn, options) ***REMOVED***
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

    return map(this, fn, options, null).promise();
***REMOVED***;

Promise.map = function (promises, fn, options, _filter) ***REMOVED***
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    return map(promises, fn, options, _filter).promise();
***REMOVED***;


***REMOVED***;
