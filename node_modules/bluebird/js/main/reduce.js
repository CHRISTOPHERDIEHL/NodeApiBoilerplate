"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) ***REMOVED***
var getDomain = Promise._getDomain;
var async = require("./async.js");
var util = require("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
function ReductionPromiseArray(promises, fn, accum, _each) ***REMOVED***
    this.constructor$(promises);
    this._promise._captureStackTrace();
    this._preservedValues = _each === INTERNAL ? [] : null;
    this._zerothIsAccum = (accum === undefined);
    this._gotAccum = false;
    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
    this._valuesPhase = undefined;
    var maybePromise = tryConvertToPromise(accum, this._promise);
    var rejected = false;
    var isPromise = maybePromise instanceof Promise;
    if (isPromise) ***REMOVED***
        maybePromise = maybePromise._target();
        if (maybePromise._isPending()) ***REMOVED***
            maybePromise._proxyPromiseArray(this, -1);
        ***REMOVED*** else if (maybePromise._isFulfilled()) ***REMOVED***
            accum = maybePromise._value();
            this._gotAccum = true;
        ***REMOVED*** else ***REMOVED***
            this._reject(maybePromise._reason());
            rejected = true;
        ***REMOVED***
    ***REMOVED***
    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
    var domain = getDomain();
    this._callback = domain === null ? fn : domain.bind(fn);
    this._accum = accum;
    if (!rejected) async.invoke(init, this, undefined);
***REMOVED***
function init() ***REMOVED***
    this._init$(undefined, -5);
***REMOVED***
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._init = function () ***REMOVED******REMOVED***;

ReductionPromiseArray.prototype._resolveEmptyArray = function () ***REMOVED***
    if (this._gotAccum || this._zerothIsAccum) ***REMOVED***
        this._resolve(this._preservedValues !== null
                        ? [] : this._accum);
    ***REMOVED***
***REMOVED***;

ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) ***REMOVED***
    var values = this._values;
    values[index] = value;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var isEach = preservedValues !== null;
    var gotAccum = this._gotAccum;
    var valuesPhase = this._valuesPhase;
    var valuesPhaseIndex;
    if (!valuesPhase) ***REMOVED***
        valuesPhase = this._valuesPhase = new Array(length);
        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) ***REMOVED***
            valuesPhase[valuesPhaseIndex] = 0;
        ***REMOVED***
    ***REMOVED***
    valuesPhaseIndex = valuesPhase[index];

    if (index === 0 && this._zerothIsAccum) ***REMOVED***
        this._accum = value;
        this._gotAccum = gotAccum = true;
        valuesPhase[index] = ((valuesPhaseIndex === 0)
            ? 1 : 2);
    ***REMOVED*** else if (index === -1) ***REMOVED***
        this._accum = value;
        this._gotAccum = gotAccum = true;
    ***REMOVED*** else ***REMOVED***
        if (valuesPhaseIndex === 0) ***REMOVED***
            valuesPhase[index] = 1;
        ***REMOVED*** else ***REMOVED***
            valuesPhase[index] = 2;
            this._accum = value;
        ***REMOVED***
    ***REMOVED***
    if (!gotAccum) return;

    var callback = this._callback;
    var receiver = this._promise._boundValue();
    var ret;

    for (var i = this._reducingIndex; i < length; ++i) ***REMOVED***
        valuesPhaseIndex = valuesPhase[i];
        if (valuesPhaseIndex === 2) ***REMOVED***
            this._reducingIndex = i + 1;
            continue;
        ***REMOVED***
        if (valuesPhaseIndex !== 1) return;
        value = values[i];
        this._promise._pushContext();
        if (isEach) ***REMOVED***
            preservedValues.push(value);
            ret = tryCatch(callback).call(receiver, value, i, length);
        ***REMOVED***
        else ***REMOVED***
            ret = tryCatch(callback)
                .call(receiver, this._accum, value, i, length);
        ***REMOVED***
        this._promise._popContext();

        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) ***REMOVED***
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) ***REMOVED***
                valuesPhase[i] = 4;
                return maybePromise._proxyPromiseArray(this, i);
            ***REMOVED*** else if (maybePromise._isFulfilled()) ***REMOVED***
                ret = maybePromise._value();
            ***REMOVED*** else ***REMOVED***
                return this._reject(maybePromise._reason());
            ***REMOVED***
        ***REMOVED***

        this._reducingIndex = i + 1;
        this._accum = ret;
    ***REMOVED***

    this._resolve(isEach ? preservedValues : this._accum);
***REMOVED***;

function reduce(promises, fn, initialValue, _each) ***REMOVED***
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
***REMOVED***

Promise.prototype.reduce = function (fn, initialValue) ***REMOVED***
    return reduce(this, fn, initialValue, null);
***REMOVED***;

Promise.reduce = function (promises, fn, initialValue, _each) ***REMOVED***
    return reduce(promises, fn, initialValue, _each);
***REMOVED***;
***REMOVED***;
