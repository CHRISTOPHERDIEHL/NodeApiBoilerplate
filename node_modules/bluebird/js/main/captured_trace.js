"use strict";
module.exports = function() ***REMOVED***
var async = require("./async.js");
var util = require("./util.js");
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var warn;

function CapturedTrace(parent) ***REMOVED***
    this._parent = parent;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
***REMOVED***
util.inherits(CapturedTrace, Error);

CapturedTrace.prototype.uncycle = function() ***REMOVED***
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = ***REMOVED******REMOVED***;

    for (var i = 0, node = this; node !== undefined; ++i) ***REMOVED***
        nodes.push(node);
        node = node._parent;
    ***REMOVED***
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) ***REMOVED***
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) ***REMOVED***
            stackToIndex[stack] = i;
        ***REMOVED***
    ***REMOVED***
    for (var i = 0; i < length; ++i) ***REMOVED***
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) ***REMOVED***
            if (index > 0) ***REMOVED***
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            ***REMOVED***
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) ***REMOVED***
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            ***REMOVED*** else ***REMOVED***
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            ***REMOVED***
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) ***REMOVED***
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            ***REMOVED***
            return;
        ***REMOVED***
    ***REMOVED***
***REMOVED***;

CapturedTrace.prototype.parent = function() ***REMOVED***
    return this._parent;
***REMOVED***;

CapturedTrace.prototype.hasParent = function() ***REMOVED***
    return this._parent !== undefined;
***REMOVED***;

CapturedTrace.prototype.attachExtraTrace = function(error) ***REMOVED***
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = CapturedTrace.parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) ***REMOVED***
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    ***REMOVED***
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
***REMOVED***;

function reconstructStack(message, stacks) ***REMOVED***
    for (var i = 0; i < stacks.length - 1; ++i) ***REMOVED***
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    ***REMOVED***
    if (i < stacks.length) ***REMOVED***
        stacks[i] = stacks[i].join("\n");
    ***REMOVED***
    return message + "\n" + stacks.join("\n");
***REMOVED***

function removeDuplicateOrEmptyJumps(stacks) ***REMOVED***
    for (var i = 0; i < stacks.length; ++i) ***REMOVED***
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) ***REMOVED***
            stacks.splice(i, 1);
            i--;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

function removeCommonRoots(stacks) ***REMOVED***
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) ***REMOVED***
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) ***REMOVED***
            if (prev[j] === currentLastLine) ***REMOVED***
                commonRootMeetPoint = j;
                break;
            ***REMOVED***
        ***REMOVED***

        for (var j = commonRootMeetPoint; j >= 0; --j) ***REMOVED***
            var line = prev[j];
            if (current[currentLastIndex] === line) ***REMOVED***
                current.pop();
                currentLastIndex--;
            ***REMOVED*** else ***REMOVED***
                break;
            ***REMOVED***
        ***REMOVED***
        current = prev;
    ***REMOVED***
***REMOVED***

function cleanStack(stack) ***REMOVED***
    var ret = [];
    for (var i = 0; i < stack.length; ++i) ***REMOVED***
        var line = stack[i];
        var isTraceLine = stackFramePattern.test(line) ||
            "    (No stack trace)" === line;
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) ***REMOVED***
            if (indentStackFrames && line.charAt(0) !== " ") ***REMOVED***
                line = "    " + line;
            ***REMOVED***
            ret.push(line);
        ***REMOVED***
    ***REMOVED***
    return ret;
***REMOVED***

function stackFramesAsArray(error) ***REMOVED***
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) ***REMOVED***
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) ***REMOVED***
            break;
        ***REMOVED***
    ***REMOVED***
    if (i > 0) ***REMOVED***
        stack = stack.slice(i);
    ***REMOVED***
    return stack;
***REMOVED***

CapturedTrace.parseStackAndMessage = function(error) ***REMOVED***
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return ***REMOVED***
        message: message,
        stack: cleanStack(stack)
    ***REMOVED***;
***REMOVED***;

CapturedTrace.formatAndLogError = function(error, title) ***REMOVED***
    if (typeof console !== "undefined") ***REMOVED***
        var message;
        if (typeof error === "object" || typeof error === "function") ***REMOVED***
            var stack = error.stack;
            message = title + formatStack(stack, error);
        ***REMOVED*** else ***REMOVED***
            message = title + String(error);
        ***REMOVED***
        if (typeof warn === "function") ***REMOVED***
            warn(message);
        ***REMOVED*** else if (typeof console.log === "function" ||
            typeof console.log === "object") ***REMOVED***
            console.log(message);
        ***REMOVED***
    ***REMOVED***
***REMOVED***;

CapturedTrace.unhandledRejection = function (reason) ***REMOVED***
    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
***REMOVED***;

CapturedTrace.isSupported = function () ***REMOVED***
    return typeof captureStackTrace === "function";
***REMOVED***;

CapturedTrace.fireRejectionEvent =
function(name, localHandler, reason, promise) ***REMOVED***
    var localEventFired = false;
    try ***REMOVED***
        if (typeof localHandler === "function") ***REMOVED***
            localEventFired = true;
            if (name === "rejectionHandled") ***REMOVED***
                localHandler(promise);
            ***REMOVED*** else ***REMOVED***
                localHandler(reason, promise);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
        async.throwLater(e);
    ***REMOVED***

    var globalEventFired = false;
    try ***REMOVED***
        globalEventFired = fireGlobalEvent(name, reason, promise);
    ***REMOVED*** catch (e) ***REMOVED***
        globalEventFired = true;
        async.throwLater(e);
    ***REMOVED***

    var domEventFired = false;
    if (fireDomEvent) ***REMOVED***
        try ***REMOVED***
            domEventFired = fireDomEvent(name.toLowerCase(), ***REMOVED***
                reason: reason,
                promise: promise
            ***REMOVED***);
        ***REMOVED*** catch (e) ***REMOVED***
            domEventFired = true;
            async.throwLater(e);
        ***REMOVED***
    ***REMOVED***

    if (!globalEventFired && !localEventFired && !domEventFired &&
        name === "unhandledRejection") ***REMOVED***
        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
    ***REMOVED***
***REMOVED***;

function formatNonError(obj) ***REMOVED***
    var str;
    if (typeof obj === "function") ***REMOVED***
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    ***REMOVED*** else ***REMOVED***
        str = obj.toString();
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) ***REMOVED***
            try ***REMOVED***
                var newStr = JSON.stringify(obj);
                str = newStr;
            ***REMOVED***
            catch(e) ***REMOVED***

            ***REMOVED***
        ***REMOVED***
        if (str.length === 0) ***REMOVED***
            str = "(empty array)";
        ***REMOVED***
    ***REMOVED***
    return ("(<" + snip(str) + ">, no stack trace)");
***REMOVED***

function snip(str) ***REMOVED***
    var maxChars = 41;
    if (str.length < maxChars) ***REMOVED***
        return str;
    ***REMOVED***
    return str.substr(0, maxChars - 3) + "...";
***REMOVED***

var shouldIgnore = function() ***REMOVED*** return false; ***REMOVED***;
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) ***REMOVED***
    var matches = line.match(parseLineInfoRegex);
    if (matches) ***REMOVED***
        return ***REMOVED***
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        ***REMOVED***;
    ***REMOVED***
***REMOVED***
CapturedTrace.setBounds = function(firstLineError, lastLineError) ***REMOVED***
    if (!CapturedTrace.isSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) ***REMOVED***
        var result = parseLineInfo(firstStackLines[i]);
        if (result) ***REMOVED***
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        ***REMOVED***
    ***REMOVED***
    for (var i = 0; i < lastStackLines.length; ++i) ***REMOVED***
        var result = parseLineInfo(lastStackLines[i]);
        if (result) ***REMOVED***
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        ***REMOVED***
    ***REMOVED***
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) ***REMOVED***
        return;
    ***REMOVED***

    shouldIgnore = function(line) ***REMOVED***
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) ***REMOVED***
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) ***REMOVED***
                return true;
            ***REMOVED***
        ***REMOVED***
        return false;
    ***REMOVED***;
***REMOVED***;

var captureStackTrace = (function stackDetection() ***REMOVED***
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) ***REMOVED***
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) ***REMOVED***
            return error.toString();
        ***REMOVED***
        return formatNonError(error);
    ***REMOVED***;

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") ***REMOVED***
        Error.stackTraceLimit = Error.stackTraceLimit + 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) ***REMOVED***
            return bluebirdFramePattern.test(line);
        ***REMOVED***;
        return function(receiver, ignoreUntil) ***REMOVED***
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        ***REMOVED***;
    ***REMOVED***
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) ***REMOVED***
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) ***REMOVED***
            o.stack = new Error().stack;
        ***REMOVED***;
    ***REMOVED***

    var hasStackAfterThrow;
    try ***REMOVED*** throw new Error(); ***REMOVED***
    catch(e) ***REMOVED***
        hasStackAfterThrow = ("stack" in e);
    ***REMOVED***
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") ***REMOVED***
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) ***REMOVED***
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            try ***REMOVED*** throw new Error(); ***REMOVED***
            catch(e) ***REMOVED*** o.stack = e.stack; ***REMOVED***
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        ***REMOVED***;
    ***REMOVED***

    formatStack = function(stack, error) ***REMOVED***
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) ***REMOVED***
            return error.toString();
        ***REMOVED***
        return formatNonError(error);
    ***REMOVED***;

    return null;

***REMOVED***)([]);

var fireDomEvent;
var fireGlobalEvent = (function() ***REMOVED***
    if (util.isNode) ***REMOVED***
        return function(name, reason, promise) ***REMOVED***
            if (name === "rejectionHandled") ***REMOVED***
                return process.emit(name, promise);
            ***REMOVED*** else ***REMOVED***
                return process.emit(name, reason, promise);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
        var customEventWorks = false;
        var anyEventWorks = true;
        try ***REMOVED***
            var ev = new self.CustomEvent("test");
            customEventWorks = ev instanceof CustomEvent;
        ***REMOVED*** catch (e) ***REMOVED******REMOVED***
        if (!customEventWorks) ***REMOVED***
            try ***REMOVED***
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, ***REMOVED******REMOVED***);
                self.dispatchEvent(event);
            ***REMOVED*** catch (e) ***REMOVED***
                anyEventWorks = false;
            ***REMOVED***
        ***REMOVED***
        if (anyEventWorks) ***REMOVED***
            fireDomEvent = function(type, detail) ***REMOVED***
                var event;
                if (customEventWorks) ***REMOVED***
                    event = new self.CustomEvent(type, ***REMOVED***
                        detail: detail,
                        bubbles: false,
                        cancelable: true
                    ***REMOVED***);
                ***REMOVED*** else if (self.dispatchEvent) ***REMOVED***
                    event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, false, true, detail);
                ***REMOVED***

                return event ? !self.dispatchEvent(event) : false;
            ***REMOVED***;
        ***REMOVED***

        var toWindowMethodNameMap = ***REMOVED******REMOVED***;
        toWindowMethodNameMap["unhandledRejection"] = ("on" +
            "unhandledRejection").toLowerCase();
        toWindowMethodNameMap["rejectionHandled"] = ("on" +
            "rejectionHandled").toLowerCase();

        return function(name, reason, promise) ***REMOVED***
            var methodName = toWindowMethodNameMap[name];
            var method = self[methodName];
            if (!method) return false;
            if (name === "rejectionHandled") ***REMOVED***
                method.call(self, promise);
            ***REMOVED*** else ***REMOVED***
                method.call(self, reason, promise);
            ***REMOVED***
            return true;
        ***REMOVED***;
    ***REMOVED***
***REMOVED***)();

if (typeof console !== "undefined" && typeof console.warn !== "undefined") ***REMOVED***
    warn = function (message) ***REMOVED***
        console.warn(message);
    ***REMOVED***;
    if (util.isNode && process.stderr.isTTY) ***REMOVED***
        warn = function(message) ***REMOVED***
            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
        ***REMOVED***;
    ***REMOVED*** else if (!util.isNode && typeof (new Error().stack) === "string") ***REMOVED***
        warn = function(message) ***REMOVED***
            console.warn("%c" + message, "color: red");
        ***REMOVED***;
    ***REMOVED***
***REMOVED***

return CapturedTrace;
***REMOVED***;
