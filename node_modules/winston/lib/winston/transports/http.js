var util = require('util'),
    winston = require('../../winston'),
    http = require('http'),
    https = require('https'),
    Stream = require('stream').Stream,
    Transport = require('./transport').Transport;

//
// ### function Http (options)
// #### @options ***REMOVED***Object***REMOVED*** Options for this instance.
// Constructor function for the Http transport object responsible
// for persisting log messages and metadata to a terminal or TTY.
//
var Http = exports.Http = function (options) ***REMOVED***
  Transport.call(this, options);
  options = options || ***REMOVED******REMOVED***;

  this.name = 'http';
  this.ssl = !!options.ssl;
  this.host = options.host || 'localhost';
  this.port = options.port;
  this.auth = options.auth;
  this.path = options.path || '';
  this.agent = options.agent;

  if (!this.port) ***REMOVED***
    this.port = this.ssl ? 443 : 80;
  ***REMOVED***
***REMOVED***;

util.inherits(Http, winston.Transport);

//
// Expose the name of this Transport on the prototype
//
Http.prototype.name = 'http';

//
// ### function _request (options, callback)
// #### @callback ***REMOVED***function***REMOVED*** Continuation to respond to when complete.
// Make a request to a winstond server or any http server which can
// handle json-rpc.
//
Http.prototype._request = function (options, callback) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;

  var auth = options.auth || this.auth,
      path = options.path || this.path || '',
      req;

  delete options.auth;
  delete options.path;

  // Prepare options for outgoing HTTP request
  req = (this.ssl ? https : http).request(***REMOVED***
    host: this.host,
    port: this.port,
    path: '/' + path.replace(/^\//, ''),
    method: 'POST',
    headers: ***REMOVED*** 'Content-Type': 'application/json' ***REMOVED***,
    agent: this.agent,
    auth: (auth) ? auth.username + ':' + auth.password : ''
  ***REMOVED***);

  req.on('error', callback);
  req.on('response', function (res) ***REMOVED***
    var body = '';

    res.on('data', function (chunk) ***REMOVED***
      body += chunk;
    ***REMOVED***);

    res.on('end', function () ***REMOVED***
      callback(null, res, body);
    ***REMOVED***);

    res.resume();
  ***REMOVED***);

  req.end(new Buffer(JSON.stringify(options), 'utf8'));
***REMOVED***;

//
// ### function log (level, msg, [meta], callback)
// #### @level ***REMOVED***string***REMOVED*** Level at which to log the message.
// #### @msg ***REMOVED***string***REMOVED*** Message to log
// #### @meta ***REMOVED***Object***REMOVED*** **Optional** Additional metadata to attach
// #### @callback ***REMOVED***function***REMOVED*** Continuation to respond to when complete.
// Core logging method exposed to Winston. Metadata is optional.
//
Http.prototype.log = function (level, msg, meta, callback) ***REMOVED***
  var self = this;

  if (typeof meta === 'function') ***REMOVED***
    callback = meta;
    meta = ***REMOVED******REMOVED***;
  ***REMOVED***

  var options = ***REMOVED***
    method: 'collect',
    params: ***REMOVED***
      level: level,
      message: msg,
      meta: meta
    ***REMOVED***
  ***REMOVED***;

  if (meta) ***REMOVED***
    if (meta.path) ***REMOVED***
      options.path = meta.path;
      delete meta.path;
    ***REMOVED***

    if (meta.auth) ***REMOVED***
      options.auth = meta.auth;
      delete meta.auth;
    ***REMOVED***
  ***REMOVED***

  this._request(options, function (err, res) ***REMOVED***
    if (res && res.statusCode !== 200) ***REMOVED***
      err = new Error('HTTP Status Code: ' + res.statusCode);
    ***REMOVED***

    if (err) return callback(err);

    // TODO: emit 'logged' correctly,
    // keep track of pending logs.
    self.emit('logged');

    if (callback) callback(null, true);
  ***REMOVED***);
***REMOVED***;

//
// ### function query (options, callback)
// #### @options ***REMOVED***Object***REMOVED*** Loggly-like query options for this instance.
// #### @callback ***REMOVED***function***REMOVED*** Continuation to respond to when complete.
// Query the transport. Options object is optional.
//
Http.prototype.query = function (options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  var self = this,
      options = this.normalizeQuery(options);

  options = ***REMOVED***
    method: 'query',
    params: options
  ***REMOVED***;

  if (options.params.path) ***REMOVED***
    options.path = options.params.path;
    delete options.params.path;
  ***REMOVED***

  if (options.params.auth) ***REMOVED***
    options.auth = options.params.auth;
    delete options.params.auth;
  ***REMOVED***

  this._request(options, function (err, res, body) ***REMOVED***
    if (res && res.statusCode !== 200) ***REMOVED***
      err = new Error('HTTP Status Code: ' + res.statusCode);
    ***REMOVED***

    if (err) return callback(err);

    if (typeof body === 'string') ***REMOVED***
      try ***REMOVED***
        body = JSON.parse(body);
      ***REMOVED*** catch (e) ***REMOVED***
        return callback(e);
      ***REMOVED***
    ***REMOVED***

    callback(null, body);
  ***REMOVED***);
***REMOVED***;

//
// ### function stream (options)
// #### @options ***REMOVED***Object***REMOVED*** Stream options for this instance.
// Returns a log stream for this transport. Options object is optional.
//
Http.prototype.stream = function (options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  
  var self = this,
      stream = new Stream,
      req,
      buff;

  stream.destroy = function () ***REMOVED***
    req.destroy();
  ***REMOVED***;

  options = ***REMOVED***
    method: 'stream',
    params: options
  ***REMOVED***;

  if (options.params.path) ***REMOVED***
    options.path = options.params.path;
    delete options.params.path;
  ***REMOVED***

  if (options.params.auth) ***REMOVED***
    options.auth = options.params.auth;
    delete options.params.auth;
  ***REMOVED***

  req = this._request(options);
  buff = '';

  req.on('data', function (data) ***REMOVED***
    var data = (buff + data).split(/\n+/),
        l = data.length - 1,
        i = 0;

    for (; i < l; i++) ***REMOVED***
      try ***REMOVED***
        stream.emit('log', JSON.parse(data[i]));
      ***REMOVED*** catch (e) ***REMOVED***
        stream.emit('error', e);
      ***REMOVED***
    ***REMOVED***

    buff = data[l];
  ***REMOVED***);

  req.on('error', function (err) ***REMOVED***
    stream.emit('error', err);
  ***REMOVED***);

  return stream;
***REMOVED***;
