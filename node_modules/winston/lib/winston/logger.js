/*
 * logger.js: Core logger object used by winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 *
 */

var events = require('events'),
    util = require('util'),
    async = require('async'),
    config = require('./config'),
    common = require('./common'),
    exception = require('./exception'),
    Stream = require('stream').Stream;

var formatRegExp = /%[sdj%]/g;

//
// ### function Logger (options)
// #### @options ***REMOVED***Object***REMOVED*** Options for this instance.
// Constructor function for the Logger object responsible
// for persisting log messages and metadata to one or more transports.
//
var Logger = exports.Logger = function (options) ***REMOVED***
  events.EventEmitter.call(this);
  this.configure(options);
***REMOVED***;

//
// Inherit from `events.EventEmitter`.
//
util.inherits(Logger, events.EventEmitter);

//
// ### function configure (options)
// This will wholesale reconfigure this instance by:
// 1. Resetting all transports. Older transports will be removed implicitly.
// 2. Set all other options including levels, colors, rewriters, filters,
//    exceptionHandlers, etc.
//
Logger.prototype.configure = function (options) ***REMOVED***
  var self = this;

  //
  // If we have already been setup with transports
  // then remove them before proceeding.
  //
  if (Array.isArray(this._names) && this._names.length) ***REMOVED***
    this.clear();
  ***REMOVED***

  options = options || ***REMOVED******REMOVED***;
  this.transports = ***REMOVED******REMOVED***;
  this._names     = [];

  if (options.transports) ***REMOVED***
    options.transports.forEach(function (transport) ***REMOVED***
      self.add(transport, null, true);
    ***REMOVED***);
  ***REMOVED***

  //
  // Set Levels and default logging level
  //
  this.padLevels = options.padLevels || false;
  this.setLevels(options.levels);
  if (options.colors) ***REMOVED***
    config.addColors(options.colors);
  ***REMOVED***

  //
  // Hoist other options onto this instance.
  //
  this.id          = options.id || null;
  this.level       = options.level || 'info';
  this.emitErrs    = options.emitErrs || false;
  this.stripColors = options.stripColors || false;
  this.exitOnError = typeof options.exitOnError !== 'undefined'
    ? options.exitOnError
    : true;

  //
  // Setup internal state as empty Objects even though it is
  // defined lazily later to ensure a strong existential API contract.
  //
  this.exceptionHandlers = ***REMOVED******REMOVED***;
  this.profilers         = ***REMOVED******REMOVED***;

  ['rewriters', 'filters'].forEach(function (kind) ***REMOVED***
    self[kind] = Array.isArray(options[kind])
      ? options[kind]
      : [];
  ***REMOVED***);

  if (options.exceptionHandlers) ***REMOVED***
    this.handleExceptions(options.exceptionHandlers);
  ***REMOVED***
***REMOVED***;

//
// ### function log (level, msg, [meta], callback)
// #### @level ***REMOVED***string***REMOVED*** Level at which to log the message.
// #### @msg ***REMOVED***string***REMOVED*** Message to log
// #### @meta ***REMOVED***Object***REMOVED*** **Optional** Additional metadata to attach
// #### @callback ***REMOVED***function***REMOVED*** Continuation to respond to when complete.
// Core logging method exposed to Winston. Metadata is optional.
//
Logger.prototype.log = function (level) ***REMOVED***
  var args = Array.prototype.slice.call(arguments, 1),
      self = this,
      transports;

  while (args[args.length - 1] === null) ***REMOVED***
    args.pop();
  ***REMOVED***

  //
  // Determining what is `meta` and what are arguments for string interpolation
  // turns out to be VERY tricky. e.g. in the cases like this:
  //
  //    logger.info('No interpolation symbols', 'ok', 'why', ***REMOVED*** meta: 'is-this' ***REMOVED***);
  //
  var callback  = typeof args[args.length - 1] === 'function'
    ? args.pop()
    : null;

  //
  // Handle errors appropriately.
  //
  function onError(err) ***REMOVED***
    if (callback) ***REMOVED***
      callback(err);
    ***REMOVED***
    else if (self.emitErrs) ***REMOVED***
      self.emit('error', err);
    ***REMOVED***
  ***REMOVED***

  if (this._names.length === 0) ***REMOVED***
    return onError(new Error('Cannot log with no transports.'));
  ***REMOVED***
  else if (typeof self.levels[level] === 'undefined') ***REMOVED***
    return onError(new Error('Unknown log level: ' + level));
  ***REMOVED***

  //
  // If there are no transports that match the level
  // then be eager and return. This could potentially be calculated
  // during `setLevels` for more performance gains.
  //
  var targets = this._names.filter(function (name) ***REMOVED***
    var transport = self.transports[name];
    return (transport.level && self.levels[transport.level] >= self.levels[level])
      || (!transport.level && self.levels[self.level] >= self.levels[level]);
  ***REMOVED***);

  if (!targets.length) ***REMOVED***
    if (callback) ***REMOVED*** callback(); ***REMOVED***
    return;
  ***REMOVED***

  //
  // Determining what is `meta` and what are arguments for string interpolation
  // turns out to be VERY tricky. e.g. in the cases like this:
  //
  //    logger.info('No interpolation symbols', 'ok', 'why', ***REMOVED*** meta: 'is-this' ***REMOVED***);
  //
  var msg, meta = ***REMOVED******REMOVED***, validMeta = false;
  var hasFormat = args && args[0] && args[0].match && args[0].match(formatRegExp) !== null;
  var tokens = (hasFormat) ? args[0].match(formatRegExp) : [];
  var ptokens = tokens.filter(function(t) ***REMOVED*** return t === '%%' ***REMOVED***);
  if (((args.length - 1) - (tokens.length - ptokens.length)) > 0 || args.length === 1) ***REMOVED***
    // last arg is meta
    meta = args[args.length - 1] || args;
    var metaType = Object.prototype.toString.call(meta);
    validMeta = metaType === '[object Object]' ||
      metaType === '[object Error]' || metaType === '[object Array]';
    meta = validMeta ? args.pop() : ***REMOVED******REMOVED***;
  ***REMOVED***
  msg = util.format.apply(null, args);

  //
  // Respond to the callback.
  //
  function finish(err) ***REMOVED***
    if (callback) ***REMOVED***
      if (err) return callback(err);
      callback(null, level, msg, meta);
    ***REMOVED***

    callback = null;
    if (!err) ***REMOVED***
      self.emit('logged', level, msg, meta);
    ***REMOVED***
  ***REMOVED***

  // If we should pad for levels, do so
  if (this.padLevels) ***REMOVED***
    msg = new Array(this.levelLength - level.length + 1).join(' ') + msg;
  ***REMOVED***

  this.rewriters.forEach(function (rewriter) ***REMOVED***
    meta = rewriter(level, msg, meta, self);
  ***REMOVED***);

  this.filters.forEach(function(filter) ***REMOVED***
    var filtered = filter(level, msg, meta, self);
    if (typeof filtered === 'string')
      msg = filtered;
    else ***REMOVED***
      msg = filtered.msg;
      meta = filtered.meta;
    ***REMOVED***
  ***REMOVED***);

  //
  // For consideration of terminal 'color" programs like colors.js,
  // which can add ANSI escape color codes to strings, we destyle the
  // ANSI color escape codes when `this.stripColors` is set.
  //
  // see: http://en.wikipedia.org/wiki/ANSI_escape_code
  //
  if (this.stripColors) ***REMOVED***
    var code = /\u001b\[(\d+(;\d+)*)?m/g;
    msg = ('' + msg).replace(code, '');
  ***REMOVED***

  //
  // Log for each transport and emit 'logging' event
  //
  function transportLog(name, next) ***REMOVED***
    var transport = self.transports[name];
    transport.log(level, msg, meta, function (err) ***REMOVED***
      if (err) ***REMOVED***
        err.transport = transport;
        finish(err);
        return next();
      ***REMOVED***

      self.emit('logging', transport, level, msg, meta);
      next();
    ***REMOVED***);
  ***REMOVED***

  async.forEach(targets, transportLog, finish);
  return this;
***REMOVED***;

//
// ### function query (options, callback)
// #### @options ***REMOVED***Object***REMOVED*** Query options for this instance.
// #### @callback ***REMOVED***function***REMOVED*** Continuation to respond to when complete.
// Queries the all transports for this instance with the specified `options`.
// This will aggregate each transport's results into one object containing
// a property per transport.
//
Logger.prototype.query = function (options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED******REMOVED***;
  ***REMOVED***

  var self = this,
      options = options || ***REMOVED******REMOVED***,
      results = ***REMOVED******REMOVED***,
      query = common.clone(options.query) || ***REMOVED******REMOVED***,
      transports;

  //
  // Helper function to query a single transport
  //
  function queryTransport(transport, next) ***REMOVED***
    if (options.query) ***REMOVED***
      options.query = transport.formatQuery(query);
    ***REMOVED***

    transport.query(options, function (err, results) ***REMOVED***
      if (err) ***REMOVED***
        return next(err);
      ***REMOVED***

      next(null, transport.formatResults(results, options.format));
    ***REMOVED***);
  ***REMOVED***

  //
  // Helper function to accumulate the results from
  // `queryTransport` into the `results`.
  //
  function addResults(transport, next) ***REMOVED***
    queryTransport(transport, function (err, result) ***REMOVED***
      //
      // queryTransport could potentially invoke the callback
      // multiple times since Transport code can be unpredictable.
      //
      if (next) ***REMOVED***
        result = err || result;
        if (result) ***REMOVED***
          results[transport.name] = result;
        ***REMOVED***

        next();
      ***REMOVED***

      next = null;
    ***REMOVED***);
  ***REMOVED***

  //
  // If an explicit transport is being queried then
  // respond with the results from only that transport
  //
  if (options.transport) ***REMOVED***
    options.transport = options.transport.toLowerCase();
    return queryTransport(this.transports[options.transport], callback);
  ***REMOVED***

  //
  // Create a list of all transports for this instance.
  //
  transports = this._names.map(function (name) ***REMOVED***
    return self.transports[name];
  ***REMOVED***).filter(function (transport) ***REMOVED***
    return !!transport.query;
  ***REMOVED***);

  //
  // Iterate over the transports in parallel setting the
  // appropriate key in the `results`
  //
  async.forEach(transports, addResults, function () ***REMOVED***
    callback(null, results);
  ***REMOVED***);
***REMOVED***;

//
// ### function stream (options)
// #### @options ***REMOVED***Object***REMOVED*** Stream options for this instance.
// Returns a log stream for all transports. Options object is optional.
//
Logger.prototype.stream = function (options) ***REMOVED***
  var self = this,
      options = options || ***REMOVED******REMOVED***,
      out = new Stream,
      streams = [],
      transports;

  if (options.transport) ***REMOVED***
    var transport = this.transports[options.transport];
    delete options.transport;
    if (transport && transport.stream) ***REMOVED***
      return transport.stream(options);
    ***REMOVED***
  ***REMOVED***

  out._streams = streams;
  out.destroy = function () ***REMOVED***
    var i = streams.length;
    while (i--) streams[i].destroy();
  ***REMOVED***;

  //
  // Create a list of all transports for this instance.
  //
  transports = this._names.map(function (name) ***REMOVED***
    return self.transports[name];
  ***REMOVED***).filter(function (transport) ***REMOVED***
    return !!transport.stream;
  ***REMOVED***);

  transports.forEach(function (transport) ***REMOVED***
    var stream = transport.stream(options);
    if (!stream) return;

    streams.push(stream);

    stream.on('log', function (log) ***REMOVED***
      log.transport = log.transport || [];
      log.transport.push(transport.name);
      out.emit('log', log);
    ***REMOVED***);

    stream.on('error', function (err) ***REMOVED***
      err.transport = err.transport || [];
      err.transport.push(transport.name);
      out.emit('error', err);
    ***REMOVED***);
  ***REMOVED***);

  return out;
***REMOVED***;

//
// ### function close ()
// Cleans up resources (streams, event listeners) for all
// transports associated with this instance (if necessary).
//
Logger.prototype.close = function () ***REMOVED***
  var self = this;

  this._names.forEach(function (name) ***REMOVED***
    var transport = self.transports[name];
    if (transport && transport.close) ***REMOVED***
      transport.close();
    ***REMOVED***
  ***REMOVED***);

  this.emit('close');
***REMOVED***;

//
// ### function handleExceptions ([tr0, tr1...] || tr0, tr1, ...)
// Handles `uncaughtException` events for the current process by
// ADDING any handlers passed in.
//
Logger.prototype.handleExceptions = function () ***REMOVED***
  var args = Array.prototype.slice.call(arguments),
      handlers = [],
      self = this;

  args.forEach(function (a) ***REMOVED***
    if (Array.isArray(a)) ***REMOVED***
      handlers = handlers.concat(a);
    ***REMOVED***
    else ***REMOVED***
      handlers.push(a);
    ***REMOVED***
  ***REMOVED***);

  this.exceptionHandlers = this.exceptionHandlers || ***REMOVED******REMOVED***;
  handlers.forEach(function (handler) ***REMOVED***
    self.exceptionHandlers[handler.name] = handler;
  ***REMOVED***);

  this._hnames = Object.keys(self.exceptionHandlers);

  if (!this.catchExceptions) ***REMOVED***
    this.catchExceptions = this._uncaughtException.bind(this);
    process.on('uncaughtException', this.catchExceptions);
  ***REMOVED***
***REMOVED***;

//
// ### function unhandleExceptions ()
// Removes any handlers to `uncaughtException` events
// for the current process
//
Logger.prototype.unhandleExceptions = function () ***REMOVED***
  var self = this;

  if (this.catchExceptions) ***REMOVED***
    Object.keys(this.exceptionHandlers).forEach(function (name) ***REMOVED***
      var handler = self.exceptionHandlers[name];
      if (handler.close) ***REMOVED***
        handler.close();
      ***REMOVED***
    ***REMOVED***);

    this.exceptionHandlers = ***REMOVED******REMOVED***;
    Object.keys(this.transports).forEach(function (name) ***REMOVED***
      var transport = self.transports[name];
      if (transport.handleExceptions) ***REMOVED***
        transport.handleExceptions = false;
      ***REMOVED***
    ***REMOVED***)

    process.removeListener('uncaughtException', this.catchExceptions);
    this.catchExceptions = false;
  ***REMOVED***
***REMOVED***;

//
// ### function add (transport, [options])
// #### @transport ***REMOVED***Transport***REMOVED*** Prototype of the Transport object to add.
// #### @options ***REMOVED***Object***REMOVED*** **Optional** Options for the Transport to add.
// #### @instance ***REMOVED***Boolean***REMOVED*** **Optional** Value indicating if `transport` is already instantiated.
// Adds a transport of the specified type to this instance.
//
Logger.prototype.add = function (transport, options, created) ***REMOVED***
  var instance = created ? transport : (new (transport)(options));

  if (!instance.name && !instance.log) ***REMOVED***
    throw new Error('Unknown transport with no log() method');
  ***REMOVED***
  else if (this.transports[instance.name]) ***REMOVED***
    throw new Error('Transport already attached: ' + instance.name + ", assign a different name");
  ***REMOVED***

  this.transports[instance.name] = instance;
  this._names = Object.keys(this.transports);

  //
  // Listen for the `error` event on the new Transport
  //
  instance._onError = this._onError.bind(this, instance)
  if (!created) ***REMOVED***
    instance.on('error', instance._onError);
  ***REMOVED***

  //
  // If this transport has `handleExceptions` set to `true`
  // and we are not already handling exceptions, do so.
  //
  if (instance.handleExceptions && !this.catchExceptions) ***REMOVED***
    this.handleExceptions();
  ***REMOVED***

  return this;
***REMOVED***;

//
// ### function clear ()
// Remove all transports from this instance
//
Logger.prototype.clear = function () ***REMOVED***
  Object.keys(this.transports).forEach(function (name) ***REMOVED***
    this.remove(***REMOVED*** name: name ***REMOVED***);
  ***REMOVED***, this);
***REMOVED***;

//
// ### function remove (transport)
// #### @transport ***REMOVED***Transport|String***REMOVED*** Transport or Name to remove.
// Removes a transport of the specified type from this instance.
//
Logger.prototype.remove = function (transport) ***REMOVED***
  var name = typeof transport !== 'string'
    ? transport.name || transport.prototype.name
    : transport;

  if (!this.transports[name]) ***REMOVED***
    throw new Error('Transport ' + name + ' not attached to this instance');
  ***REMOVED***

  var instance = this.transports[name];
  delete this.transports[name];
  this._names = Object.keys(this.transports);

  if (instance.close) ***REMOVED***
    instance.close();
  ***REMOVED***

  if (instance._onError) ***REMOVED***
    instance.removeListener('error', instance._onError);
  ***REMOVED***
  return this;
***REMOVED***;

//
// ### function startTimer ()
// Returns an object corresponding to a specific timing. When done
// is called the timer will finish and log the duration. e.g.:
//
//    timer = winston.startTimer()
//    setTimeout(function()***REMOVED***
//      timer.done("Logging message");
//    ***REMOVED***, 1000);
//
Logger.prototype.startTimer = function () ***REMOVED***
  return new ProfileHandler(this);
***REMOVED***;

//
// ### function profile (id, [msg, meta, callback])
// #### @id ***REMOVED***string***REMOVED*** Unique id of the profiler
// #### @msg ***REMOVED***string***REMOVED*** **Optional** Message to log
// #### @meta ***REMOVED***Object***REMOVED*** **Optional** Additional metadata to attach
// #### @callback ***REMOVED***function***REMOVED*** **Optional** Continuation to respond to when complete.
// Tracks the time inbetween subsequent calls to this method
// with the same `id` parameter. The second call to this method
// will log the difference in milliseconds along with the message.
//
Logger.prototype.profile = function (id) ***REMOVED***
  var now = Date.now(), then, args,
      msg, meta, callback;

  if (this.profilers[id]) ***REMOVED***
    then = this.profilers[id];
    delete this.profilers[id];

    // Support variable arguments: msg, meta, callback
    args     = Array.prototype.slice.call(arguments);
    callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;
    meta     = typeof args[args.length - 1] === 'object' ? args.pop() : ***REMOVED******REMOVED***;
    msg      = args.length === 2 ? args[1] : id;

    // Set the duration property of the metadata
    meta.durationMs = now - then;
    return this.info(msg, meta, callback);
  ***REMOVED***
  else ***REMOVED***
    this.profilers[id] = now;
  ***REMOVED***

  return this;
***REMOVED***;

//
// ### function setLevels (target)
// #### @target ***REMOVED***Object***REMOVED*** Target levels to use on this instance
// Sets the `target` levels specified on this instance.
//
Logger.prototype.setLevels = function (target) ***REMOVED***
  return common.setLevels(this, this.levels, target);
***REMOVED***;

//
// ### function cli ()
// Configures this instance to have the default
// settings for command-line interfaces: no timestamp,
// colors enabled, padded output, and additional levels.
//
Logger.prototype.cli = function () ***REMOVED***
  this.padLevels = true;
  this.setLevels(config.cli.levels);
  config.addColors(config.cli.colors);

  if (this.transports.console) ***REMOVED***
    this.transports.console.colorize = this.transports.console.colorize || true;
    this.transports.console.timestamp = this.transports.console.timestamp || false;
  ***REMOVED***

  return this;
***REMOVED***;

//
// ### @private function _uncaughtException (err)
// #### @err ***REMOVED***Error***REMOVED*** Error to handle
// Logs all relevant information around the `err` and
// exits the current process.
//
Logger.prototype._uncaughtException = function (err) ***REMOVED***
  var self = this,
      responded = false,
      info = exception.getAllInfo(err),
      handlers = this._getExceptionHandlers(),
      timeout,
      doExit;

  //
  // Calculate if we should exit on this error
  //
  doExit = typeof this.exitOnError === 'function'
    ? this.exitOnError(err)
    : this.exitOnError;

  function logAndWait(transport, next) ***REMOVED***
    transport.logException('uncaughtException: ' + (err.message || err), info, next, err);
  ***REMOVED***

  function gracefulExit() ***REMOVED***
    if (doExit && !responded) ***REMOVED***
      //
      // Remark: Currently ignoring any exceptions from transports
      //         when catching uncaught exceptions.
      //
      clearTimeout(timeout);
      responded = true;
      process.exit(1);
    ***REMOVED***
  ***REMOVED***

  if (!handlers || handlers.length === 0) ***REMOVED***
    return gracefulExit();
  ***REMOVED***

  //
  // Log to all transports and allow the operation to take
  // only up to `3000ms`.
  //
  async.forEach(handlers, logAndWait, gracefulExit);
  if (doExit) ***REMOVED***
    timeout = setTimeout(gracefulExit, 3000);
  ***REMOVED***
***REMOVED***;

//
// ### @private function _getExceptionHandlers ()
// Returns the list of transports and exceptionHandlers
// for this instance.
//
Logger.prototype._getExceptionHandlers = function () ***REMOVED***
  var self = this;

  return this._hnames.map(function (name) ***REMOVED***
    return self.exceptionHandlers[name];
  ***REMOVED***).concat(this._names.map(function (name) ***REMOVED***
    return self.transports[name].handleExceptions && self.transports[name];
  ***REMOVED***)).filter(Boolean);
***REMOVED***;

//
// ### @private function _onError (transport, err)
// #### @transport ***REMOVED***Object***REMOVED*** Transport on which the error occured
// #### @err ***REMOVED***Error***REMOVED*** Error that occurred on the transport
// Bubbles the error, `err`, that occured on the specified `transport`
// up from this instance if `emitErrs` has been set.
//
Logger.prototype._onError = function (transport, err) ***REMOVED***
  if (this.emitErrs) ***REMOVED***
    this.emit('error', err, transport);
  ***REMOVED***
***REMOVED***;

//
// ### @private ProfileHandler
// Constructor function for the ProfileHandler instance used by
// `Logger.prototype.startTimer`. When done is called the timer
// will finish and log the duration.
//
function ProfileHandler(logger) ***REMOVED***
  this.logger = logger;
  this.start = Date.now();
***REMOVED***

//
// ### function done (msg)
// Ends the current timer (i.e. ProfileHandler) instance and
// logs the `msg` along with the duration since creation.
//
ProfileHandler.prototype.done = function (msg) ***REMOVED***
  var args     = Array.prototype.slice.call(arguments),
      callback = typeof args[args.length - 1] === 'function' ? args.pop() : null,
      meta     = typeof args[args.length - 1] === 'object' ? args.pop() : ***REMOVED******REMOVED***;

  meta.duration = (Date.now()) - this.start + 'ms';
  return this.logger.info(msg, meta, callback);
***REMOVED***;
