/*
 * common.js: Internal helper and utility functions for winston
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 *
 */

var util = require('util'),
    crypto = require('crypto'),
    cycle = require('cycle'),
    fs = require('fs'),
    StringDecoder = require('string_decoder').StringDecoder,
    Stream = require('stream').Stream,
    config = require('./config');

//
// ### function setLevels (target, past, current)
// #### @target ***REMOVED***Object***REMOVED*** Object on which to set levels.
// #### @past ***REMOVED***Object***REMOVED*** Previous levels set on target.
// #### @current ***REMOVED***Object***REMOVED*** Current levels to set on target.
// Create functions on the target objects for each level
// in current.levels. If past is defined, remove functions
// for each of those levels.
//
exports.setLevels = function (target, past, current, isDefault) ***REMOVED***
  var self = this;
  if (past) ***REMOVED***
    Object.keys(past).forEach(function (level) ***REMOVED***
      delete target[level];
    ***REMOVED***);
  ***REMOVED***

  target.levels = current || config.npm.levels;
  if (target.padLevels) ***REMOVED***
    target.levelLength = exports.longestElement(Object.keys(target.levels));
  ***REMOVED***

  //
  //  Define prototype methods for each log level
  //  e.g. target.log('info', msg) <=> target.info(msg)
  //
  Object.keys(target.levels).forEach(function (level) ***REMOVED***

    // TODO Refactor logging methods into a different object to avoid name clashes
    if (level === 'log') ***REMOVED***
      console.warn('Log level named "log" will clash with the method "log". Consider using a different name.');
      return;
    ***REMOVED***

    target[level] = function (msg) ***REMOVED***
      // build argument list (level, msg, ... [string interpolate], [***REMOVED***metadata***REMOVED***], [callback])
      var args = [level].concat(Array.prototype.slice.call(arguments));
      target.log.apply(target, args);
    ***REMOVED***;
  ***REMOVED***);

  return target;
***REMOVED***;

//
// ### function longestElement
// #### @xs ***REMOVED***Array***REMOVED*** Array to calculate against
// Returns the longest element in the `xs` array.
//
exports.longestElement = function (xs) ***REMOVED***
  return Math.max.apply(
    null,
    xs.map(function (x) ***REMOVED*** return x.length; ***REMOVED***)
  );
***REMOVED***;

//
// ### function clone (obj)
// #### @obj ***REMOVED***Object***REMOVED*** Object to clone.
// Helper method for deep cloning pure JSON objects
// i.e. JSON objects that are either literals or objects (no Arrays, etc)
//
exports.clone = function (obj) ***REMOVED***
  //
  // We only need to clone reference types (Object)
  //
  var copy = ***REMOVED******REMOVED***;

  if (obj instanceof Error) ***REMOVED***
    // With potential custom Error objects, this might not be exactly correct,
    // but probably close-enough for purposes of this lib.
    copy = ***REMOVED*** message: obj.message ***REMOVED***;
    Object.getOwnPropertyNames(obj).forEach(function (key) ***REMOVED***
      copy[key] = obj[key];
    ***REMOVED***);

    return copy;
  ***REMOVED***
  else if (!(obj instanceof Object)) ***REMOVED***
    return obj;
  ***REMOVED***
  else if (obj instanceof Date) ***REMOVED***
    return new Date(obj.getTime());
  ***REMOVED***

  for (var i in obj) ***REMOVED***
    if (Array.isArray(obj[i])) ***REMOVED***
      copy[i] = obj[i].slice(0);
    ***REMOVED***
    else if (obj[i] instanceof Buffer) ***REMOVED***
        copy[i] = obj[i].slice(0);
    ***REMOVED***
    else if (typeof obj[i] != 'function') ***REMOVED***
      copy[i] = obj[i] instanceof Object ? exports.clone(obj[i]) : obj[i];
    ***REMOVED***
    else if (typeof obj[i] === 'function') ***REMOVED***
      copy[i] = obj[i];
    ***REMOVED***
  ***REMOVED***

  return copy;
***REMOVED***;

//
// ### function log (options)
// #### @options ***REMOVED***Object***REMOVED*** All information about the log serialization.
// Generic logging function for returning timestamped strings
// with the following options:
//
//    ***REMOVED***
//      level:     'level to add to serialized message',
//      message:   'message to serialize',
//      meta:      'additional logging metadata to serialize',
//      colorize:  false, // Colorizes output (only if `.json` is false)
//      align:     false  // Align message level.
//      timestamp: true   // Adds a timestamp to the serialized message
//      label:     'label to prepend the message'
//    ***REMOVED***
//
exports.log = function (options) ***REMOVED***
  var timestampFn = typeof options.timestamp === 'function'
        ? options.timestamp
        : exports.timestamp,
      timestamp   = options.timestamp ? timestampFn() : null,
      showLevel   = options.showLevel === undefined ? true : options.showLevel,
      meta        = options.meta !== null && options.meta !== undefined && !(options.meta instanceof Error)
        ? exports.clone(cycle.decycle(options.meta))
        : options.meta || null,
      output;

  //
  // raw mode is intended for outputing winston as streaming JSON to STDOUT
  //
  if (options.raw) ***REMOVED***
    if (typeof meta !== 'object' && meta != null) ***REMOVED***
      meta = ***REMOVED*** meta: meta ***REMOVED***;
    ***REMOVED***
    output         = exports.clone(meta) || ***REMOVED******REMOVED***;
    output.level   = options.level;
    //
    // Remark (jcrugzz): This used to be output.message = options.message.stripColors.
    // I do not know why this is, it does not make sense but im handling that
    // case here as well as handling the case that does make sense which is to
    // make the `output.message = options.message`
    //
    output.message = options.message.stripColors
      ? options.message.stripColors
      : options.message;

    return JSON.stringify(output);
  ***REMOVED***

  //
  // json mode is intended for pretty printing multi-line json to the terminal
  //
  if (options.json || true === options.logstash) ***REMOVED***
    if (typeof meta !== 'object' && meta != null) ***REMOVED***
      meta = ***REMOVED*** meta: meta ***REMOVED***;
    ***REMOVED***

    output         = exports.clone(meta) || ***REMOVED******REMOVED***;
    output.level   = options.level;
    output.message = output.message || '';

    if (options.label) ***REMOVED*** output.label = options.label; ***REMOVED***
    if (options.message) ***REMOVED*** output.message = options.message; ***REMOVED***
    if (timestamp) ***REMOVED*** output.timestamp = timestamp; ***REMOVED***

    if (options.logstash === true) ***REMOVED***
      // use logstash format
      var logstashOutput = ***REMOVED******REMOVED***;
      if (output.message !== undefined) ***REMOVED***
        logstashOutput['@message'] = output.message;
        delete output.message;
      ***REMOVED***

      if (output.timestamp !== undefined) ***REMOVED***
        logstashOutput['@timestamp'] = output.timestamp;
        delete output.timestamp;
      ***REMOVED***

      logstashOutput['@fields'] = exports.clone(output);
      output = logstashOutput;
    ***REMOVED***

    if (typeof options.stringify === 'function') ***REMOVED***
      return options.stringify(output);
    ***REMOVED***

    return JSON.stringify(output, function (key, value) ***REMOVED***
      return value instanceof Buffer
        ? value.toString('base64')
        : value;
    ***REMOVED***);
  ***REMOVED***

  //
  // Remark: this should really be a call to `util.format`.
  //
  if (typeof options.formatter == 'function') ***REMOVED***
    return String(options.formatter(exports.clone(options)));
  ***REMOVED***

  output = timestamp ? timestamp + ' - ' : '';
  if (showLevel) ***REMOVED***
    output += options.colorize === 'all' || options.colorize === 'level' || options.colorize === true
      ? config.colorize(options.level)
      : options.level;
  ***REMOVED***

  output += (options.align) ? '\t' : '';
  output += (timestamp || showLevel) ? ': ' : '';
  output += options.label ? ('[' + options.label + '] ') : '';
  output += options.colorize === 'all' || options.colorize === 'message'
    ? config.colorize(options.level, options.message)
    : options.message;

  if (meta !== null && meta !== undefined) ***REMOVED***
    if (meta && meta instanceof Error && meta.stack) ***REMOVED***
      meta = meta.stack;
    ***REMOVED***

    if (typeof meta !== 'object') ***REMOVED***
      output += ' ' + meta;
    ***REMOVED***
    else if (Object.keys(meta).length > 0) ***REMOVED***
      if (typeof options.prettyPrint === 'function') ***REMOVED***
        output += ' ' + options.prettyPrint(meta);
      ***REMOVED*** else if (options.prettyPrint) ***REMOVED***
        output += ' ' + '\n' + util.inspect(meta, false, options.depth || null, options.colorize);
      ***REMOVED*** else if (
        options.humanReadableUnhandledException
          && Object.keys(meta).length === 5
          && meta.hasOwnProperty('date')
          && meta.hasOwnProperty('process')
          && meta.hasOwnProperty('os')
          && meta.hasOwnProperty('trace')
          && meta.hasOwnProperty('stack')) ***REMOVED***

        //
        // If meta carries unhandled exception data serialize the stack nicely
        //
        var stack = meta.stack;
        delete meta.stack;
        delete meta.trace;
        output += ' ' + exports.serialize(meta);

        if (stack) ***REMOVED***
          output += '\n' + stack.join('\n');
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        output += ' ' + exports.serialize(meta);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return output;
***REMOVED***;

exports.capitalize = function (str) ***REMOVED***
  return str && str[0].toUpperCase() + str.slice(1);
***REMOVED***;

//
// ### function hash (str)
// #### @str ***REMOVED***string***REMOVED*** String to hash.
// Utility function for creating unique ids
// e.g. Profiling incoming HTTP requests on the same tick
//
exports.hash = function (str) ***REMOVED***
  return crypto.createHash('sha1').update(str).digest('hex');
***REMOVED***;

//
// ### function pad (n)
// Returns a padded string if `n < 10`.
//
exports.pad = function (n) ***REMOVED***
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
***REMOVED***;

//
// ### function timestamp ()
// Returns a timestamp string for the current time.
//
exports.timestamp = function () ***REMOVED***
  return new Date().toISOString();
***REMOVED***;

//
// ### function serialize (obj, key)
// #### @obj ***REMOVED***Object|literal***REMOVED*** Object to serialize
// #### @key ***REMOVED***string***REMOVED*** **Optional** Optional key represented by obj in a larger object
// Performs simple comma-separated, `key=value` serialization for Loggly when
// logging to non-JSON inputs.
//
exports.serialize = function (obj, key) ***REMOVED***
  // symbols cannot be directly casted to strings
  if (typeof key === 'symbol') ***REMOVED***
    key = key.toString()
  ***REMOVED***
  if (typeof obj === 'symbol') ***REMOVED***
    obj = obj.toString()
  ***REMOVED***

  if (obj === null) ***REMOVED***
    obj = 'null';
  ***REMOVED***
  else if (obj === undefined) ***REMOVED***
    obj = 'undefined';
  ***REMOVED***
  else if (obj === false) ***REMOVED***
    obj = 'false';
  ***REMOVED***

  if (typeof obj !== 'object') ***REMOVED***
    return key ? key + '=' + obj : obj;
  ***REMOVED***

  if (obj instanceof Buffer) ***REMOVED***
    return key ? key + '=' + obj.toString('base64') : obj.toString('base64');
  ***REMOVED***

  var msg = '',
      keys = Object.keys(obj),
      length = keys.length;

  for (var i = 0; i < length; i++) ***REMOVED***
    if (Array.isArray(obj[keys[i]])) ***REMOVED***
      msg += keys[i] + '=[';

      for (var j = 0, l = obj[keys[i]].length; j < l; j++) ***REMOVED***
        msg += exports.serialize(obj[keys[i]][j]);
        if (j < l - 1) ***REMOVED***
          msg += ', ';
        ***REMOVED***
      ***REMOVED***

      msg += ']';
    ***REMOVED***
    else if (obj[keys[i]] instanceof Date) ***REMOVED***
      msg += keys[i] + '=' + obj[keys[i]];
    ***REMOVED***
    else ***REMOVED***
      msg += exports.serialize(obj[keys[i]], keys[i]);
    ***REMOVED***

    if (i < length - 1) ***REMOVED***
      msg += ', ';
    ***REMOVED***
  ***REMOVED***

  return msg;
***REMOVED***;

//
// ### function tailFile (options, callback)
// #### @options ***REMOVED***Object***REMOVED*** Options for tail.
// #### @callback ***REMOVED***function***REMOVED*** Callback to execute on every line.
// `tail -f` a file. Options must include file.
//
exports.tailFile = function(options, callback) ***REMOVED***
  var buffer = new Buffer(64 * 1024)
    , decode = new StringDecoder('utf8')
    , stream = new Stream
    , buff = ''
    , pos = 0
    , row = 0;

  if (options.start === -1) ***REMOVED***
    delete options.start;
  ***REMOVED***

  stream.readable = true;
  stream.destroy = function() ***REMOVED***
    stream.destroyed = true;
    stream.emit('end');
    stream.emit('close');
  ***REMOVED***;

  fs.open(options.file, 'a+', '0644', function(err, fd) ***REMOVED***
    if (err) ***REMOVED***
      if (!callback) ***REMOVED***
        stream.emit('error', err);
      ***REMOVED*** else ***REMOVED***
        callback(err);
      ***REMOVED***
      stream.destroy();
      return;
    ***REMOVED***

    (function read() ***REMOVED***
      if (stream.destroyed) ***REMOVED***
        fs.close(fd);
        return;
      ***REMOVED***

      return fs.read(fd, buffer, 0, buffer.length, pos, function(err, bytes) ***REMOVED***
        if (err) ***REMOVED***
          if (!callback) ***REMOVED***
            stream.emit('error', err);
          ***REMOVED*** else ***REMOVED***
            callback(err);
          ***REMOVED***
          stream.destroy();
          return;
        ***REMOVED***

        if (!bytes) ***REMOVED***
          if (buff) ***REMOVED***
            if (options.start == null || row > options.start) ***REMOVED***
              if (!callback) ***REMOVED***
                stream.emit('line', buff);
              ***REMOVED*** else ***REMOVED***
                callback(null, buff);
              ***REMOVED***
            ***REMOVED***
            row++;
            buff = '';
          ***REMOVED***
          return setTimeout(read, 1000);
        ***REMOVED***

        var data = decode.write(buffer.slice(0, bytes));

        if (!callback) ***REMOVED***
          stream.emit('data', data);
        ***REMOVED***

        var data = (buff + data).split(/\n+/)
          , l = data.length - 1
          , i = 0;

        for (; i < l; i++) ***REMOVED***
          if (options.start == null || row > options.start) ***REMOVED***
            if (!callback) ***REMOVED***
              stream.emit('line', data[i]);
            ***REMOVED*** else ***REMOVED***
              callback(null, data[i]);
            ***REMOVED***
          ***REMOVED***
          row++;
        ***REMOVED***

        buff = data[l];

        pos += bytes;

        return read();
      ***REMOVED***);
    ***REMOVED***)();
  ***REMOVED***);

  if (!callback) ***REMOVED***
    return stream;
  ***REMOVED***

  return stream.destroy;
***REMOVED***;

//
// ### function stringArrayToSet (array)
// #### @strArray ***REMOVED***Array***REMOVED*** Array of Set-elements as strings.
// #### @errMsg ***REMOVED***string***REMOVED*** **Optional** Custom error message thrown on invalid input.
// Returns a Set-like object with strArray's elements as keys (each with the value true).
//
exports.stringArrayToSet = function (strArray, errMsg) ***REMOVED***
  if (typeof errMsg === 'undefined') ***REMOVED***
    errMsg = 'Cannot make set from Array with non-string elements';
  ***REMOVED***
  return strArray.reduce(function (set, el) ***REMOVED***
    if (!(typeof el === 'string' || el instanceof String)) ***REMOVED***
      throw new Error(errMsg);
    ***REMOVED***
    set[el] = true;
    return set;
  ***REMOVED***, Object.create(null));
***REMOVED***;
