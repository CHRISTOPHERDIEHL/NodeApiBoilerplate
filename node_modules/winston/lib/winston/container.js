/*
 * container.js: Inversion of control container for winston logger instances
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 *
 */

var common = require('./common'),
    winston = require('../winston'),
    extend = require('util')._extend;

//
// ### function Container (options)
// #### @options ***REMOVED***Object***REMOVED*** Default pass-thru options for Loggers
// Constructor function for the Container object responsible for managing
// a set of `winston.Logger` instances based on string ids.
//
var Container = exports.Container = function (options) ***REMOVED***
  this.loggers = ***REMOVED******REMOVED***;
  this.options = options || ***REMOVED******REMOVED***;
  this.default = ***REMOVED***
    transports: [
      new winston.transports.Console(***REMOVED***
        level: 'silly',
        colorize: false
      ***REMOVED***)
    ]
  ***REMOVED***
***REMOVED***;

//
// ### function get / add (id, options)
// #### @id ***REMOVED***string***REMOVED*** Id of the Logger to get
// #### @options ***REMOVED***Object***REMOVED*** **Optional** Options for the Logger instance
// Retreives a `winston.Logger` instance for the specified `id`. If
// an instance does not exist, one is created.
//
Container.prototype.get = Container.prototype.add = function (id, options) ***REMOVED***
  var self = this,
      existing;

  if (!this.loggers[id]) ***REMOVED***
    //
    // Remark: Simple shallow clone for configuration options in case we pass in
    // instantiated protoypal objects
    //
    options = extend(***REMOVED******REMOVED***, options || this.options || this.default);
    existing = options.transports || this.options.transports;
    //
    // Remark: Make sure if we have an array of transports we slice it to make copies
    // of those references.
    //
    options.transports = existing ? existing.slice() : [];

    if (options.transports.length === 0 && (!options || !options['console'])) ***REMOVED***
      options.transports.push(this.default.transports[0]);
    ***REMOVED***

    Object.keys(options).forEach(function (key) ***REMOVED***
      if (key === 'transports') ***REMOVED***
        return;
      ***REMOVED***

      var name = common.capitalize(key);

      if (!winston.transports[name]) ***REMOVED***
        throw new Error('Cannot add unknown transport: ' + name);
      ***REMOVED***

      var namedOptions = options[key];
      namedOptions.id = id;
      options.transports.push(new (winston.transports[name])(namedOptions));
    ***REMOVED***);

    options.id = id;
    this.loggers[id] = new winston.Logger(options);

    this.loggers[id].on('close', function () ***REMOVED***
        self._delete(id);
    ***REMOVED***);
  ***REMOVED***

  return this.loggers[id];
***REMOVED***;

//
// ### function close (id)
// #### @id ***REMOVED***string***REMOVED*** **Optional** Id of the Logger instance to find
// Returns a boolean value indicating if this instance
// has a logger with the specified `id`.
//
Container.prototype.has = function (id) ***REMOVED***
  return !!this.loggers[id];
***REMOVED***;

//
// ### function close (id)
// #### @id ***REMOVED***string***REMOVED*** **Optional** Id of the Logger instance to close
// Closes a `Logger` instance with the specified `id` if it exists.
// If no `id` is supplied then all Loggers are closed.
//
Container.prototype.close = function (id) ***REMOVED***
  var self = this;

  function _close (id) ***REMOVED***
    if (!self.loggers[id]) ***REMOVED***
      return;
    ***REMOVED***

    self.loggers[id].close();
    self._delete(id);
  ***REMOVED***

  return id ? _close(id) : Object.keys(this.loggers).forEach(function (id) ***REMOVED***
    _close(id);
  ***REMOVED***);
***REMOVED***;

//
// ### @private function _delete (id)
// #### @id ***REMOVED***string***REMOVED*** Id of the Logger instance to delete from container
// Deletes a `Logger` instance with the specified `id`.
//
Container.prototype._delete = function (id) ***REMOVED***
    delete this.loggers[id];
***REMOVED***

