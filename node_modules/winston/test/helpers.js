/*
 * helpers.js: Test helpers for winston
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENSE
 *
 */

var assert = require('assert'),
    fs = require('fs'),
    path = require('path'),
    spawn = require('child_process').spawn,
    util = require('util'),
    vows = require('vows'),
    winston = require('../lib/winston');

var helpers = exports;

helpers.size = function (obj) ***REMOVED***
  var size = 0, key;
  for (key in obj) ***REMOVED***
    if (obj.hasOwnProperty(key)) ***REMOVED***
      size++;
    ***REMOVED***
  ***REMOVED***

  return size;
***REMOVED***;

helpers.tryUnlink = function (file) ***REMOVED***
  try ***REMOVED*** fs.unlinkSync(file) ***REMOVED***
  catch (ex) ***REMOVED*** ***REMOVED***
***REMOVED***;

helpers.assertDateInfo = function (info) ***REMOVED***
  assert.isNumber(Date.parse(info));
***REMOVED***;

helpers.assertProcessInfo = function (info) ***REMOVED***
  assert.isNumber(info.pid);
  assert.isNumber(info.uid);
  assert.isNumber(info.gid);
  assert.isString(info.cwd);
  assert.isString(info.execPath);
  assert.isString(info.version);
  assert.isArray(info.argv);
  assert.isObject(info.memoryUsage);
***REMOVED***;

helpers.assertOsInfo = function (info) ***REMOVED***
  assert.isArray(info.loadavg);
  assert.isNumber(info.uptime);
***REMOVED***;

helpers.assertTrace = function (trace) ***REMOVED***
  trace.forEach(function (site) ***REMOVED***
    assert.isTrue(!site.column || typeof site.column === 'number');
    assert.isTrue(!site.line || typeof site.line === 'number');
    assert.isTrue(!site.file || typeof site.file === 'string');
    assert.isTrue(!site.method || typeof site.method === 'string');
    assert.isTrue(!site.function || typeof site.function === 'string');
    assert.isTrue(typeof site.native === 'boolean');
  ***REMOVED***);
***REMOVED***;

helpers.assertLogger = function (logger, level) ***REMOVED***
  assert.instanceOf(logger, winston.Logger);
  assert.isFunction(logger.log);
  assert.isFunction(logger.add);
  assert.isFunction(logger.remove);
  assert.equal(logger.level, level || "info");
  Object.keys(logger.levels).forEach(function (method) ***REMOVED***
    assert.isFunction(logger[method]);
  ***REMOVED***);
***REMOVED***;

helpers.assertConsole = function (transport) ***REMOVED***
  assert.instanceOf(transport, winston.transports.Console);
  assert.isFunction(transport.log);
***REMOVED***;

helpers.assertMemory = function (transport) ***REMOVED***
  assert.instanceOf(transport, winston.transports.Memory);
  assert.isFunction(transport.log);
***REMOVED***;

helpers.assertFile = function (transport) ***REMOVED***
  assert.instanceOf(transport, winston.transports.File);
  assert.isFunction(transport.log);
***REMOVED***;

helpers.assertCouchdb = function (transport) ***REMOVED***
  assert.instanceOf(transport, winston.transports.Couchdb);
  assert.isFunction(transport.log);
***REMOVED***;

helpers.assertHandleExceptions = function (options) ***REMOVED***
  return ***REMOVED***
    topic: function () ***REMOVED***
      var that = this,
          child = spawn('node', [options.script]);

      helpers.tryUnlink(options.logfile);
      child.on('exit', function () ***REMOVED***
        fs.readFile(options.logfile, that.callback);
      ***REMOVED***);
    ***REMOVED***,
    "should save the error information to the specified file": function (err, data) ***REMOVED***
      assert.isTrue(!err);
      data = JSON.parse(data);

      assert.isObject(data);
      helpers.assertProcessInfo(data.process);
      helpers.assertOsInfo(data.os);
      helpers.assertTrace(data.trace);
      if (options.message) ***REMOVED***
        assert.equal('uncaughtException: ' + options.message, data.message);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;

helpers.assertFailedTransport = function (transport) ***REMOVED***
  return ***REMOVED***
    topic: function () ***REMOVED***
      var self = this;
      transport.on('error', function(emitErr)***REMOVED***
        transport.log('error', 'test message 2', ***REMOVED******REMOVED***, function(logErr, logged)***REMOVED***
          self.callback(emitErr, logErr);
        ***REMOVED***);
      ***REMOVED***);
      transport.log('error', 'test message');
    ***REMOVED***,
    "should emit an error": function (emitErr, logErr) ***REMOVED***
      assert.instanceOf(emitErr, Error);
      assert.equal(emitErr.code, 'ENOENT');
    ***REMOVED***,
    "should enter noop failed state": function (emitErr, logErr) ***REMOVED***
      assert.instanceOf(logErr, Error);
      assert.equal(transport._failures, transport.maxRetries);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;

helpers.testNpmLevels = function (transport, assertMsg, assertFn) ***REMOVED***
  return helpers.testLevels(winston.config.npm.levels, transport, assertMsg, assertFn);
***REMOVED***;

helpers.testSyslogLevels = function (transport, assertMsg, assertFn) ***REMOVED***
  return helpers.testLevels(winston.config.syslog.levels, transport, assertMsg, assertFn);
***REMOVED***;

helpers.testLevels = function (levels, transport, assertMsg, assertFn) ***REMOVED***
  var tests = ***REMOVED******REMOVED***;

  Object.keys(levels).forEach(function (level) ***REMOVED***
    var test = ***REMOVED***
      topic: function () ***REMOVED***
        transport.log(level, 'test message', ***REMOVED******REMOVED***, this.callback.bind(this, null));
      ***REMOVED***
    ***REMOVED***;

    test[assertMsg] = assertFn;
    tests['with the ' + level + ' level'] = test;
  ***REMOVED***);

  var metadatatest = ***REMOVED***
    topic: function () ***REMOVED***
      transport.log('info', 'test message', ***REMOVED*** metadata: true ***REMOVED***, this.callback.bind(this, null));
    ***REMOVED***
  ***REMOVED***;

  metadatatest[assertMsg] = assertFn;
  tests['when passed metadata'] = metadatatest;

  var primmetadatatest = ***REMOVED***
    topic: function () ***REMOVED***
      transport.log('info', 'test message', 'metadata', this.callback.bind(this, null));
    ***REMOVED***
  ***REMOVED***;

  primmetadatatest[assertMsg] = assertFn;
  tests['when passed primitive metadata'] = primmetadatatest;

  var circmetadata = ***REMOVED*** ***REMOVED***;
  circmetadata['metadata'] = circmetadata;

  var circmetadatatest = ***REMOVED***
    topic: function () ***REMOVED***
      transport.log('info', 'test message', circmetadata, this.callback.bind(this, null));
    ***REMOVED***
  ***REMOVED***;

  circmetadatatest[assertMsg] = assertFn;
  tests['when passed circular metadata'] = circmetadatatest;

  return tests;
***REMOVED***;

helpers.assertOptionsThrow = function (options, errMsg) ***REMOVED***
  return function () ***REMOVED***
    assert.throws(
      function () ***REMOVED***
        try ***REMOVED***
          new (winston.transports.Console)(options);
        ***REMOVED*** catch (err) ***REMOVED***
          throw(err);
        ***REMOVED***
      ***REMOVED***,
      new RegExp('^' + errMsg.replace(/[-\/\\^$*+?.()|[\]***REMOVED******REMOVED***]/g, '\\$&') + '$')
    );
  ***REMOVED***
***REMOVED***;

helpers.assertStderrLevels = function (transport, stderrLevels) ***REMOVED***
  return function () ***REMOVED***
    assert.equal(
        JSON.stringify(Object.keys(transport.stderrLevels).sort()),
        JSON.stringify(stderrLevels.sort())
    );
  ***REMOVED***
***REMOVED***;

helpers.testLoggingToStreams = function (levels, transport, stderrLevels, stdMocks) ***REMOVED***
  return ***REMOVED***
    topic: function () ***REMOVED***
      stdMocks.use();
      transport.showLevel = true;
      Object.keys(levels).forEach(function (level) ***REMOVED***
        transport.log(
            level,
            level + ' should go to ' + (stderrLevels.indexOf(level) > -1 ? 'stderr' : 'stdout'),
            ***REMOVED******REMOVED***,
            function () ***REMOVED******REMOVED***
        );
      ***REMOVED***);
      var output = stdMocks.flush();
      stdMocks.restore();
      this.callback(null, output, levels);
    ***REMOVED***,
    "output should go to the appropriate streams": function (ign, output, levels) ***REMOVED***
      var outCount = 0,
          errCount = 0;
      Object.keys(levels).forEach(function (level) ***REMOVED***
        var line;
        if (stderrLevels.indexOf(level) > -1) ***REMOVED***
          line = output.stderr[errCount++];
          assert.equal(line, level + ': ' + level + ' should go to stderr\n');
        ***REMOVED*** else ***REMOVED***
          line = output.stdout[outCount++];
          assert.equal(line, level + ': ' + level + ' should go to stdout\n');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
