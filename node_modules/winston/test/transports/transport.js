var assert = require('assert'),
    winston = require('../../lib/winston'),
    helpers = require('../helpers');

module.exports = function (transport, options) ***REMOVED***
  var logger = transport instanceof winston.Logger
    ? transport
    : new winston.Logger(***REMOVED***
        transports: [
          new transport(options)
        ]
      ***REMOVED***);

  // hack to fix transports that don't log
  // any unit of time smaller than seconds
  var common = require('../../lib/winston/common');
  common.timestamp = function() ***REMOVED***
    return new Date().toISOString();
  ***REMOVED***;

  var transport = logger.transports[logger._names[0]];

  var out = ***REMOVED***
    'topic': logger,
    'when passed valid options': ***REMOVED***
      'should have the proper methods defined': function () ***REMOVED***
        switch (transport.name) ***REMOVED***
          case 'console':
            helpers.assertConsole(transport);
            break;
          case 'file':
            helpers.assertFile(transport);
            break;
          case 'couchdb':
            helpers.assertCouchdb(transport);
            break;
        ***REMOVED***
        assert.isFunction(transport.log);
      ***REMOVED***
    ***REMOVED***,
    'the log() method': helpers.testNpmLevels(transport,
      'should respond with true', function (ign, err, logged) ***REMOVED***
        assert.isNull(err);
        assert.isNotNull(logged);
      ***REMOVED***
    ),
    'the stream() method': ***REMOVED***
      'using no options': ***REMOVED***
        'topic': function () ***REMOVED***
          if (!transport.stream) return;

          logger.log('info', 'hello world', ***REMOVED******REMOVED***);

          var cb = this.callback,
              j = 10,
              i = 10,
              results = [],
              stream = logger.stream();

          stream.on('log', function (log) ***REMOVED***
            results.push(log);
            results.stream = stream;
            if (!--j) cb(null, results);
          ***REMOVED***);

          stream.on('error', function (err) ***REMOVED***
            j = -1; //don't call the callback again
            cb(err);
          ***REMOVED***);

          while (i--) logger.log('info', 'hello world ' + i, ***REMOVED******REMOVED***);
        ***REMOVED***,
        'should stream logs': function (err, results) ***REMOVED***
          if (!transport.stream) return;
          assert.isNull(err);
          results.forEach(function (log) ***REMOVED***
            assert.ok(log.message.indexOf('hello world') === 0
                      || log.message.indexOf('test message') === 0);
          ***REMOVED***);
          results.stream.destroy();
        ***REMOVED***
      ***REMOVED***,
      'using the `start` option': ***REMOVED***
        'topic': function () ***REMOVED***
          if (!transport.stream) return;

          var cb = this.callback,
              stream = logger.stream(***REMOVED*** start: 0 ***REMOVED***);

          stream.on('log', function (log) ***REMOVED***
            log.stream = stream;
            if (cb) cb(null, log);
            cb = null;
          ***REMOVED***);
        ***REMOVED***,
        'should stream logs': function (err, log) ***REMOVED***
          if (!transport.stream) return;
          assert.isNull(err);
          assert.isNotNull(log.message);
          log.stream.destroy();
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***,
    'after the logs have flushed': ***REMOVED***
      topic: function () ***REMOVED***
        setTimeout(this.callback, 1000);
      ***REMOVED***,
      'the query() method': ***REMOVED***
        'using basic querying': ***REMOVED***
          'topic': function () ***REMOVED***
            if (!transport.query) return;
            var cb = this.callback;
            logger.log('info', 'hello world', ***REMOVED******REMOVED***, function () ***REMOVED***
              logger.query(cb);
            ***REMOVED***);
          ***REMOVED***,
          'should return matching results': function (err, results) ***REMOVED***
            if (!transport.query) return;
            assert.isNull(err);
            results = results[transport.name];
            while (!Array.isArray(results)) ***REMOVED***
              results = results[Object.keys(results).pop()];
            ***REMOVED***
            var log = results.pop();
            assert.ok(log.message.indexOf('hello world') === 0
                      || log.message.indexOf('test message') === 0);
          ***REMOVED***
        ***REMOVED***,
        'using the `rows` option': ***REMOVED***
          'topic': function () ***REMOVED***
            if (!transport.query) return;
            var cb = this.callback;
            logger.log('info', 'hello world', ***REMOVED******REMOVED***, function () ***REMOVED***
              logger.query(***REMOVED*** rows: 1 ***REMOVED***, cb);
            ***REMOVED***);
          ***REMOVED***,
          'should return one result': function (err, results) ***REMOVED***
            if (!transport.query) return;
            assert.isNull(err);
            results = results[transport.name];
            while (!Array.isArray(results)) ***REMOVED***
              results = results[Object.keys(results).pop()];
            ***REMOVED***
            assert.equal(results.length, 1);
          ***REMOVED***
        ***REMOVED***,
        'using `fields` and `order` option': ***REMOVED***
          'topic': function () ***REMOVED***
            if (!transport.query) return;
            var cb = this.callback;
            logger.log('info', 'hello world', ***REMOVED******REMOVED***, function () ***REMOVED***
              logger.query(***REMOVED*** order: 'asc', fields: ['timestamp'] ***REMOVED***, cb);
            ***REMOVED***);
          ***REMOVED***,
          'should return matching results': function (err, results) ***REMOVED***
            if (!transport.query) return;
            assert.isNull(err);
            results = results[transport.name];
            while (!Array.isArray(results)) ***REMOVED***
              results = results[Object.keys(results).pop()];
            ***REMOVED***
            assert.equal(Object.keys(results[0]).length, 1);
            assert.ok(new Date(results.shift().timestamp)
                    < new Date(results.pop().timestamp));
          ***REMOVED***
        ***REMOVED***,
        'using the `from` and `until` option': ***REMOVED***
          'topic': function () ***REMOVED***
            if (!transport.query) return;
            var cb = this.callback;
            var start = Date.now() - (100 * 1000);
            var end = Date.now() + (100 * 1000);
            logger.query(***REMOVED*** from: start, until: end ***REMOVED***, cb);
          ***REMOVED***,
          'should return matching results': function (err, results) ***REMOVED***
            if (!transport.query) return;
            assert.isNull(err);
            results = results[transport.name];
            while (!Array.isArray(results)) ***REMOVED***
              results = results[Object.keys(results).pop()];
            ***REMOVED***
            assert.ok(results.length >= 1);
          ***REMOVED***
        ***REMOVED***,
        'using a bad `from` and `until` option': ***REMOVED***
          'topic': function () ***REMOVED***
            if (!transport.query) return;
            var cb = this.callback;
            logger.log('info', 'bad from and until', ***REMOVED******REMOVED***, function () ***REMOVED***
              var now = Date.now() + 1000000;
              logger.query(***REMOVED*** from: now, until: now ***REMOVED***, cb);
            ***REMOVED***);
          ***REMOVED***,
          'should return no results': function (err, results) ***REMOVED***
            if (!transport.query) return;
            assert.isNull(err);
            results = results[transport.name];
            while (!Array.isArray(results)) ***REMOVED***
              results = results[Object.keys(results).pop()];
            ***REMOVED***
            results = [results.filter(function(log) ***REMOVED***
              return log.message === 'bad from and until';
            ***REMOVED***).pop()];
            assert.isUndefined(results[0]);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  return out;
***REMOVED***;
