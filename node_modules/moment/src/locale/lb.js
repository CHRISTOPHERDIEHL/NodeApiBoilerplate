//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

import moment from '../moment';

function processRelativeTime(number, withoutSuffix, key, isFuture) ***REMOVED***
    var format = ***REMOVED***
        'm': ['eng Minutt', 'enger Minutt'],
        'h': ['eng Stonn', 'enger Stonn'],
        'd': ['een Dag', 'engem Dag'],
        'M': ['ee Mount', 'engem Mount'],
        'y': ['ee Joer', 'engem Joer']
    ***REMOVED***;
    return withoutSuffix ? format[key][0] : format[key][1];
***REMOVED***
function processFutureTime(string) ***REMOVED***
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) ***REMOVED***
        return 'a ' + string;
    ***REMOVED***
    return 'an ' + string;
***REMOVED***
function processPastTime(string) ***REMOVED***
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) ***REMOVED***
        return 'viru ' + string;
    ***REMOVED***
    return 'virun ' + string;
***REMOVED***
/**
 * Returns true if the word before the given number loses the '-n' ending.
 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
 *
 * @param number ***REMOVED***integer***REMOVED***
 * @returns ***REMOVED***boolean***REMOVED***
 */
function eifelerRegelAppliesToNumber(number) ***REMOVED***
    number = parseInt(number, 10);
    if (isNaN(number)) ***REMOVED***
        return false;
    ***REMOVED***
    if (number < 0) ***REMOVED***
        // Negative Number --> always true
        return true;
    ***REMOVED*** else if (number < 10) ***REMOVED***
        // Only 1 digit
        if (4 <= number && number <= 7) ***REMOVED***
            return true;
        ***REMOVED***
        return false;
    ***REMOVED*** else if (number < 100) ***REMOVED***
        // 2 digits
        var lastDigit = number % 10, firstDigit = number / 10;
        if (lastDigit === 0) ***REMOVED***
            return eifelerRegelAppliesToNumber(firstDigit);
        ***REMOVED***
        return eifelerRegelAppliesToNumber(lastDigit);
    ***REMOVED*** else if (number < 10000) ***REMOVED***
        // 3 or 4 digits --> recursively check first digit
        while (number >= 10) ***REMOVED***
            number = number / 10;
        ***REMOVED***
        return eifelerRegelAppliesToNumber(number);
    ***REMOVED*** else ***REMOVED***
        // Anything larger than 4 digits: recursively check first n-3 digits
        number = number / 1000;
        return eifelerRegelAppliesToNumber(number);
    ***REMOVED***
***REMOVED***

export default moment.defineLocale('lb', ***REMOVED***
    months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: ***REMOVED***
        LT: 'H:mm [Auer]',
        LTS: 'H:mm:ss [Auer]',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm [Auer]',
        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    ***REMOVED***,
    calendar: ***REMOVED***
        sameDay: '[Haut um] LT',
        sameElse: 'L',
        nextDay: '[Muer um] LT',
        nextWeek: 'dddd [um] LT',
        lastDay: '[Gëschter um] LT',
        lastWeek: function () ***REMOVED***
            // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
            switch (this.day()) ***REMOVED***
                case 2:
                case 4:
                    return '[Leschten] dddd [um] LT';
                default:
                    return '[Leschte] dddd [um] LT';
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***,
    relativeTime : ***REMOVED***
        future : processFutureTime,
        past : processPastTime,
        s : 'e puer Sekonnen',
        m : processRelativeTime,
        mm : '%d Minutten',
        h : processRelativeTime,
        hh : '%d Stonnen',
        d : processRelativeTime,
        dd : '%d Deeg',
        M : processRelativeTime,
        MM : '%d Méint',
        y : processRelativeTime,
        yy : '%d Joer'
    ***REMOVED***,
    ordinalParse: /\d***REMOVED***1,2***REMOVED***\./,
    ordinal: '%d.',
    week: ***REMOVED***
        dow: 1, // Monday is the first day of the week.
        doy: 4  // The week that contains Jan 4th is the first week of the year.
    ***REMOVED***
***REMOVED***);

