import ***REMOVED*** configFromISO ***REMOVED*** from './from-string';
import ***REMOVED*** configFromArray ***REMOVED*** from './from-array';
import ***REMOVED*** getParseRegexForToken ***REMOVED***   from '../parse/regex';
import ***REMOVED*** addTimeToArrayFromToken ***REMOVED*** from '../parse/token';
import ***REMOVED*** expandFormat, formatTokenFunctions, formattingTokens ***REMOVED*** from '../format/format';
import checkOverflow from './check-overflow';
import ***REMOVED*** HOUR ***REMOVED*** from '../units/constants';
import ***REMOVED*** hooks ***REMOVED*** from '../utils/hooks';
import getParsingFlags from './parsing-flags';

// constant that refers to the ISO standard
hooks.ISO_8601 = function () ***REMOVED******REMOVED***;

// date from string and format string
export function configFromStringAndFormat(config) ***REMOVED***
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) ***REMOVED***
        configFromISO(config);
        return;
    ***REMOVED***

    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) ***REMOVED***
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) ***REMOVED***
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) ***REMOVED***
                getParsingFlags(config).unusedInput.push(skipped);
            ***REMOVED***
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        ***REMOVED***
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) ***REMOVED***
            if (parsedInput) ***REMOVED***
                getParsingFlags(config).empty = false;
            ***REMOVED***
            else ***REMOVED***
                getParsingFlags(config).unusedTokens.push(token);
            ***REMOVED***
            addTimeToArrayFromToken(token, parsedInput, config);
        ***REMOVED***
        else if (config._strict && !parsedInput) ***REMOVED***
            getParsingFlags(config).unusedTokens.push(token);
        ***REMOVED***
    ***REMOVED***

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) ***REMOVED***
        getParsingFlags(config).unusedInput.push(string);
    ***REMOVED***

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) ***REMOVED***
        getParsingFlags(config).bigHour = undefined;
    ***REMOVED***

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
***REMOVED***


function meridiemFixWrap (locale, hour, meridiem) ***REMOVED***
    var isPm;

    if (meridiem == null) ***REMOVED***
        // nothing to do
        return hour;
    ***REMOVED***
    if (locale.meridiemHour != null) ***REMOVED***
        return locale.meridiemHour(hour, meridiem);
    ***REMOVED*** else if (locale.isPM != null) ***REMOVED***
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) ***REMOVED***
            hour += 12;
        ***REMOVED***
        if (!isPm && hour === 12) ***REMOVED***
            hour = 0;
        ***REMOVED***
        return hour;
    ***REMOVED*** else ***REMOVED***
        // this is not supposed to happen
        return hour;
    ***REMOVED***
***REMOVED***
