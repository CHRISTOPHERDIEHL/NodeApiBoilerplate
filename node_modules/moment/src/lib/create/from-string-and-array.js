import ***REMOVED*** copyConfig ***REMOVED*** from '../moment/constructor';
import ***REMOVED*** configFromStringAndFormat ***REMOVED*** from './from-string-and-format';
import getParsingFlags from './parsing-flags';
import ***REMOVED*** isValid ***REMOVED*** from './valid';
import extend from '../utils/extend';

// date from string and array of format strings
export function configFromStringAndArray(config) ***REMOVED***
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) ***REMOVED***
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    ***REMOVED***

    for (i = 0; i < config._f.length; i++) ***REMOVED***
        currentScore = 0;
        tempConfig = copyConfig(***REMOVED******REMOVED***, config);
        if (config._useUTC != null) ***REMOVED***
            tempConfig._useUTC = config._useUTC;
        ***REMOVED***
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) ***REMOVED***
            continue;
        ***REMOVED***

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) ***REMOVED***
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        ***REMOVED***
    ***REMOVED***

    extend(config, bestMoment || tempConfig);
***REMOVED***
