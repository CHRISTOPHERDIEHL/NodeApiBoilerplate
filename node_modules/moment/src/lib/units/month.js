import ***REMOVED*** get ***REMOVED*** from '../moment/get-set';
import hasOwnProp from '../utils/has-own-prop';
import ***REMOVED*** addFormatToken ***REMOVED*** from '../format/format';
import ***REMOVED*** addUnitAlias ***REMOVED*** from './aliases';
import ***REMOVED*** addUnitPriority ***REMOVED*** from './priorities';
import ***REMOVED*** addRegexToken, match1to2, match2, matchWord, regexEscape ***REMOVED*** from '../parse/regex';
import ***REMOVED*** addParseToken ***REMOVED*** from '../parse/token';
import ***REMOVED*** hooks ***REMOVED*** from '../utils/hooks';
import ***REMOVED*** MONTH ***REMOVED*** from './constants';
import toInt from '../utils/to-int';
import isArray from '../utils/is-array';
import isNumber from '../utils/is-number';
import indexOf from '../utils/index-of';
import ***REMOVED*** createUTC ***REMOVED*** from '../create/utc';
import getParsingFlags from '../create/parsing-flags';

export function daysInMonth(year, month) ***REMOVED***
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
***REMOVED***

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () ***REMOVED***
    return this.month() + 1;
***REMOVED***);

addFormatToken('MMM', 0, 0, function (format) ***REMOVED***
    return this.localeData().monthsShort(this, format);
***REMOVED***);

addFormatToken('MMMM', 0, 0, function (format) ***REMOVED***
    return this.localeData().months(this, format);
***REMOVED***);

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) ***REMOVED***
    return locale.monthsShortRegex(isStrict);
***REMOVED***);
addRegexToken('MMMM', function (isStrict, locale) ***REMOVED***
    return locale.monthsRegex(isStrict);
***REMOVED***);

addParseToken(['M', 'MM'], function (input, array) ***REMOVED***
    array[MONTH] = toInt(input) - 1;
***REMOVED***);

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) ***REMOVED***
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) ***REMOVED***
        array[MONTH] = month;
    ***REMOVED*** else ***REMOVED***
        getParsingFlags(config).invalidMonth = input;
    ***REMOVED***
***REMOVED***);

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
export var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
export function localeMonths (m, format) ***REMOVED***
    if (!m) ***REMOVED***
        return this._months;
    ***REMOVED***
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
***REMOVED***

export var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
export function localeMonthsShort (m, format) ***REMOVED***
    if (!m) ***REMOVED***
        return this._monthsShort;
    ***REMOVED***
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
***REMOVED***

function handleStrictParse(monthName, format, strict) ***REMOVED***
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) ***REMOVED***
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) ***REMOVED***
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        ***REMOVED***
    ***REMOVED***

    if (strict) ***REMOVED***
        if (format === 'MMM') ***REMOVED***
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        ***REMOVED*** else ***REMOVED***
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (format === 'MMM') ***REMOVED***
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) ***REMOVED***
                return ii;
            ***REMOVED***
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        ***REMOVED*** else ***REMOVED***
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) ***REMOVED***
                return ii;
            ***REMOVED***
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

export function localeMonthsParse (monthName, format, strict) ***REMOVED***
    var i, mom, regex;

    if (this._monthsParseExact) ***REMOVED***
        return handleStrictParse.call(this, monthName, format, strict);
    ***REMOVED***

    if (!this._monthsParse) ***REMOVED***
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    ***REMOVED***

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) ***REMOVED***
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) ***REMOVED***
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        ***REMOVED***
        if (!strict && !this._monthsParse[i]) ***REMOVED***
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        ***REMOVED***
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) ***REMOVED***
            return i;
        ***REMOVED*** else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) ***REMOVED***
            return i;
        ***REMOVED*** else if (!strict && this._monthsParse[i].test(monthName)) ***REMOVED***
            return i;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

// MOMENTS

export function setMonth (mom, value) ***REMOVED***
    var dayOfMonth;

    if (!mom.isValid()) ***REMOVED***
        // No op
        return mom;
    ***REMOVED***

    if (typeof value === 'string') ***REMOVED***
        if (/^\d+$/.test(value)) ***REMOVED***
            value = toInt(value);
        ***REMOVED*** else ***REMOVED***
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) ***REMOVED***
                return mom;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
***REMOVED***

export function getSetMonth (value) ***REMOVED***
    if (value != null) ***REMOVED***
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    ***REMOVED*** else ***REMOVED***
        return get(this, 'Month');
    ***REMOVED***
***REMOVED***

export function getDaysInMonth () ***REMOVED***
    return daysInMonth(this.year(), this.month());
***REMOVED***

var defaultMonthsShortRegex = matchWord;
export function monthsShortRegex (isStrict) ***REMOVED***
    if (this._monthsParseExact) ***REMOVED***
        if (!hasOwnProp(this, '_monthsRegex')) ***REMOVED***
            computeMonthsParse.call(this);
        ***REMOVED***
        if (isStrict) ***REMOVED***
            return this._monthsShortStrictRegex;
        ***REMOVED*** else ***REMOVED***
            return this._monthsShortRegex;
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (!hasOwnProp(this, '_monthsShortRegex')) ***REMOVED***
            this._monthsShortRegex = defaultMonthsShortRegex;
        ***REMOVED***
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    ***REMOVED***
***REMOVED***

var defaultMonthsRegex = matchWord;
export function monthsRegex (isStrict) ***REMOVED***
    if (this._monthsParseExact) ***REMOVED***
        if (!hasOwnProp(this, '_monthsRegex')) ***REMOVED***
            computeMonthsParse.call(this);
        ***REMOVED***
        if (isStrict) ***REMOVED***
            return this._monthsStrictRegex;
        ***REMOVED*** else ***REMOVED***
            return this._monthsRegex;
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (!hasOwnProp(this, '_monthsRegex')) ***REMOVED***
            this._monthsRegex = defaultMonthsRegex;
        ***REMOVED***
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    ***REMOVED***
***REMOVED***

function computeMonthsParse () ***REMOVED***
    function cmpLenRev(a, b) ***REMOVED***
        return b.length - a.length;
    ***REMOVED***

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) ***REMOVED***
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    ***REMOVED***
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) ***REMOVED***
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    ***REMOVED***
    for (i = 0; i < 24; i++) ***REMOVED***
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    ***REMOVED***

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
***REMOVED***
