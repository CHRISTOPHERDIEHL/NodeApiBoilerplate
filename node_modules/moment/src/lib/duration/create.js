import ***REMOVED*** Duration, isDuration ***REMOVED*** from './constructor';
import isNumber from '../utils/is-number';
import toInt from '../utils/to-int';
import absRound from '../utils/abs-round';
import hasOwnProp from '../utils/has-own-prop';
import ***REMOVED*** DATE, HOUR, MINUTE, SECOND, MILLISECOND ***REMOVED*** from '../units/constants';
import ***REMOVED*** cloneWithOffset ***REMOVED*** from '../units/offset';
import ***REMOVED*** createLocal ***REMOVED*** from '../create/local';

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

export function createDuration (input, key) ***REMOVED***
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) ***REMOVED***
        duration = ***REMOVED***
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        ***REMOVED***;
    ***REMOVED*** else if (isNumber(input)) ***REMOVED***
        duration = ***REMOVED******REMOVED***;
        if (key) ***REMOVED***
            duration[key] = input;
        ***REMOVED*** else ***REMOVED***
            duration.milliseconds = input;
        ***REMOVED***
    ***REMOVED*** else if (!!(match = aspNetRegex.exec(input))) ***REMOVED***
        sign = (match[1] === '-') ? -1 : 1;
        duration = ***REMOVED***
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        ***REMOVED***;
    ***REMOVED*** else if (!!(match = isoRegex.exec(input))) ***REMOVED***
        sign = (match[1] === '-') ? -1 : 1;
        duration = ***REMOVED***
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        ***REMOVED***;
    ***REMOVED*** else if (duration == null) ***REMOVED***// checks for null or undefined
        duration = ***REMOVED******REMOVED***;
    ***REMOVED*** else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) ***REMOVED***
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = ***REMOVED******REMOVED***;
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    ***REMOVED***

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) ***REMOVED***
        ret._locale = input._locale;
    ***REMOVED***

    return ret;
***REMOVED***

createDuration.fn = Duration.prototype;

function parseIso (inp, sign) ***REMOVED***
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
***REMOVED***

function positiveMomentsDifference(base, other) ***REMOVED***
    var res = ***REMOVED***milliseconds: 0, months: 0***REMOVED***;

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) ***REMOVED***
        --res.months;
    ***REMOVED***

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
***REMOVED***

function momentsDifference(base, other) ***REMOVED***
    var res;
    if (!(base.isValid() && other.isValid())) ***REMOVED***
        return ***REMOVED***milliseconds: 0, months: 0***REMOVED***;
    ***REMOVED***

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) ***REMOVED***
        res = positiveMomentsDifference(base, other);
    ***REMOVED*** else ***REMOVED***
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    ***REMOVED***

    return res;
***REMOVED***
