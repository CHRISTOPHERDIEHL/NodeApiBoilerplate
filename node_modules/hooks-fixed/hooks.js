// TODO Add in pre and post skipping options
module.exports = ***REMOVED***
  /**
   *  Declares a new hook to which you can add pres and posts
   *  @param ***REMOVED***String***REMOVED*** name of the function
   *  @param ***REMOVED***Function***REMOVED*** the method
   *  @param ***REMOVED***Function***REMOVED*** the error handler callback
   */
  hook: function (name, fn, errorCb) ***REMOVED***
    if (arguments.length === 1 && typeof name === 'object') ***REMOVED***
      for (var k in name) ***REMOVED*** // `name` is a hash of hookName->hookFn
        this.hook(k, name[k]);
      ***REMOVED***
      return;
    ***REMOVED***

    var proto = this.prototype || this
      , pres = proto._pres = proto._pres || ***REMOVED******REMOVED***
      , posts = proto._posts = proto._posts || ***REMOVED******REMOVED***;
    pres[name] = pres[name] || [];
    posts[name] = posts[name] || [];

    proto[name] = function () ***REMOVED***
      var self = this
        , hookArgs // arguments eventually passed to the hook - are mutable
        , lastArg = arguments[arguments.length-1]
        , pres = this._pres[name]
        , posts = this._posts[name]
        , _total = pres.length
        , _current = -1
        , _asyncsLeft = proto[name].numAsyncPres
        , _asyncsDone = function(err) ***REMOVED***
            if (err) ***REMOVED***
              return handleError(err);
            ***REMOVED***
            --_asyncsLeft || _done.apply(self, hookArgs);
          ***REMOVED***
        , handleError = function(err) ***REMOVED***
            if ('function' == typeof lastArg)
              return lastArg(err);
            if (errorCb) return errorCb.call(self, err);
            throw err;
          ***REMOVED***
        , _next = function () ***REMOVED***
            if (arguments[0] instanceof Error) ***REMOVED***
              return handleError(arguments[0]);
            ***REMOVED***
            var _args = Array.prototype.slice.call(arguments)
              , currPre
              , preArgs;
            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))
              hookArgs = _args;
            if (++_current < _total) ***REMOVED***
              currPre = pres[_current]
              if (currPre.isAsync && currPre.length < 2)
                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
              if (currPre.length < 1)
                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
              preArgs = (currPre.isAsync
                          ? [once(_next), once(_asyncsDone)]
                          : [once(_next)]).concat(hookArgs);
              return currPre.apply(self, preArgs);
            ***REMOVED*** else if (!_asyncsLeft) ***REMOVED***
              return _done.apply(self, hookArgs);
            ***REMOVED***
          ***REMOVED***
        , _done = function () ***REMOVED***
            var args_ = Array.prototype.slice.call(arguments)
              , ret, total_, current_, next_, done_, postArgs;

            if (_current === _total) ***REMOVED***
              
              next_ = function () ***REMOVED***
                if (arguments[0] instanceof Error) ***REMOVED***
                  return handleError(arguments[0]);
                ***REMOVED***
                var args_ = Array.prototype.slice.call(arguments, 1)
                  , currPost
                  , postArgs;
                if (args_.length) hookArgs = args_;
                if (++current_ < total_) ***REMOVED***
                  currPost = posts[current_]
                  if (currPost.length < 1)
                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
                  postArgs = [once(next_)].concat(hookArgs);
                  return currPost.apply(self, postArgs);
                ***REMOVED*** else if (typeof lastArg === 'function')***REMOVED***
                  // All post handlers are done, call original callback function
                  return lastArg.apply(self, arguments);
                ***REMOVED***
              ***REMOVED***;

              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
              // a callback.  We trap that callback and wait to call it until all post handlers have finished.
              if(typeof lastArg === 'function')***REMOVED***
                args_[args_.length - 1] = once(next_);
              ***REMOVED***

              total_ = posts.length;
              current_ = -1;
              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward

              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
              return ret;
            ***REMOVED***
          ***REMOVED***;

      return _next.apply(this, arguments);
    ***REMOVED***;
    
    proto[name].numAsyncPres = 0;

    return this;
  ***REMOVED***,

  pre: function (name, isAsync, fn, errorCb) ***REMOVED***
    if ('boolean' !== typeof arguments[1]) ***REMOVED***
      errorCb = fn;
      fn = isAsync;
      isAsync = false;
    ***REMOVED***
    var proto = this.prototype || this
      , pres = proto._pres = proto._pres || ***REMOVED******REMOVED***;

    this._lazySetupHooks(proto, name, errorCb);

    if (fn.isAsync = isAsync) ***REMOVED***
      proto[name].numAsyncPres++;
    ***REMOVED***

    (pres[name] = pres[name] || []).push(fn);
    return this;
  ***REMOVED***,
  post: function (name, isAsync, fn) ***REMOVED***
    if (arguments.length === 2) ***REMOVED***
      fn = isAsync;
      isAsync = false;
    ***REMOVED***
    var proto = this.prototype || this
      , posts = proto._posts = proto._posts || ***REMOVED******REMOVED***;
    
    this._lazySetupHooks(proto, name);
    (posts[name] = posts[name] || []).push(fn);
    return this;
  ***REMOVED***,
  removePre: function (name, fnToRemove) ***REMOVED***
    var proto = this.prototype || this
      , pres = proto._pres || (proto._pres || ***REMOVED******REMOVED***);
    if (!pres[name]) return this;
    if (arguments.length === 1) ***REMOVED***
      // Remove all pre callbacks for hook `name`
      pres[name].length = 0;
    ***REMOVED*** else ***REMOVED***
      pres[name] = pres[name].filter( function (currFn) ***REMOVED***
        return currFn !== fnToRemove;
      ***REMOVED***);
    ***REMOVED***
    return this;
  ***REMOVED***,
  removePost: function (name, fnToRemove) ***REMOVED***
    var proto = this.prototype || this
      , posts = proto._posts || (proto._posts || ***REMOVED******REMOVED***);
    if (!posts[name]) return this;
    if (arguments.length === 1) ***REMOVED***
      // Remove all post callbacks for hook `name`
      posts[name].length = 0;
    ***REMOVED*** else ***REMOVED***
      posts[name] = posts[name].filter( function (currFn) ***REMOVED***
        return currFn !== fnToRemove;
      ***REMOVED***);
    ***REMOVED***
    return this;
  ***REMOVED***,
  
  _lazySetupHooks: function (proto, methodName, errorCb) ***REMOVED***
    if ('undefined' === typeof proto[methodName].numAsyncPres) ***REMOVED***
      this.hook(methodName, proto[methodName], errorCb);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

function once (fn, scope) ***REMOVED***
  return function fnWrapper () ***REMOVED***
    if (fnWrapper.hookCalled) return;
    fnWrapper.hookCalled = true;
    fn.apply(scope, arguments);
  ***REMOVED***;
***REMOVED***
