// Load modules

var Hoek = require('hoek');
var Topo = require('topo');
var Any = require('./any');
var Cast = require('./cast');
var Errors = require('./errors');


// Declare internals

var internals = ***REMOVED******REMOVED***;


internals.Object = function () ***REMOVED***

    Any.call(this);
    this._type = 'object';
    this._inner.children = null;
    this._inner.renames = [];
    this._inner.dependencies = [];
    this._inner.patterns = [];
***REMOVED***;

Hoek.inherits(internals.Object, Any);


internals.Object.prototype._base = function (value, state, options) ***REMOVED***

    var item, key, localState, result;
    var target = value;
    var errors = [];
    var finish = function () ***REMOVED***

        return ***REMOVED***
            value: target,
            errors: errors.length ? errors : null
        ***REMOVED***;
    ***REMOVED***;

    if (typeof value === 'string' &&
        options.convert) ***REMOVED***

        try ***REMOVED***
            value = JSON.parse(value);
        ***REMOVED***
        catch (parseErr) ***REMOVED*** ***REMOVED***
    ***REMOVED***

    var type = this._flags.func ? 'function' : 'object';
    if (!value ||
        typeof value !== type ||
        Array.isArray(value)) ***REMOVED***

        errors.push(Errors.create(type + '.base', null, state, options));
        return finish();
    ***REMOVED***

    // Skip if there are no other rules to test

    if (!this._inner.renames.length &&
        !this._inner.dependencies.length &&
        !this._inner.children &&                    // null allows any keys
        !this._inner.patterns.length) ***REMOVED***

        target = value;
        return finish();
    ***REMOVED***

    // Ensure target is a local copy (parsed) or shallow copy

    if (target === value) ***REMOVED***
        if (type === 'object') ***REMOVED***
            target = Object.create(Object.getPrototypeOf(value));
        ***REMOVED***
        else ***REMOVED***
            target = function () ***REMOVED***

                return value.apply(this, arguments);
            ***REMOVED***;

            target.prototype = Hoek.clone(value.prototype);
        ***REMOVED***

        var valueKeys = Object.keys(value);
        for (var t = 0, tl = valueKeys.length; t < tl; ++t) ***REMOVED***
            target[valueKeys[t]] = value[valueKeys[t]];
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        target = value;
    ***REMOVED***

    // Rename keys

    var renamed = ***REMOVED******REMOVED***;
    for (var r = 0, rl = this._inner.renames.length; r < rl; ++r) ***REMOVED***
        item = this._inner.renames[r];

        if (item.options.ignoreUndefined && target[item.from] === undefined) ***REMOVED***
            continue;
        ***REMOVED***

        if (!item.options.multiple &&
            renamed[item.to]) ***REMOVED***

            errors.push(Errors.create('object.rename.multiple', ***REMOVED*** from: item.from, to: item.to ***REMOVED***, state, options));
            if (options.abortEarly) ***REMOVED***
                return finish();
            ***REMOVED***
        ***REMOVED***

        if (Object.prototype.hasOwnProperty.call(target, item.to) &&
            !item.options.override &&
            !renamed[item.to]) ***REMOVED***

            errors.push(Errors.create('object.rename.override', ***REMOVED*** from: item.from, to: item.to ***REMOVED***, state, options));
            if (options.abortEarly) ***REMOVED***
                return finish();
            ***REMOVED***
        ***REMOVED***

        if (target[item.from] === undefined) ***REMOVED***
            delete target[item.to];
        ***REMOVED***
        else ***REMOVED***
            target[item.to] = target[item.from];
        ***REMOVED***

        renamed[item.to] = true;

        if (!item.options.alias) ***REMOVED***
            delete target[item.from];
        ***REMOVED***
    ***REMOVED***

    // Validate schema

    if (!this._inner.children &&            // null allows any keys
        !this._inner.patterns.length &&
        !this._inner.dependencies.length) ***REMOVED***

        return finish();
    ***REMOVED***

    var unprocessed = Hoek.mapToObject(Object.keys(target));

    if (this._inner.children) ***REMOVED***
        for (var i = 0, il = this._inner.children.length; i < il; ++i) ***REMOVED***
            var child = this._inner.children[i];
            key = child.key;
            item = target[key];

            delete unprocessed[key];

            localState = ***REMOVED*** key: key, path: (state.path || '') + (state.path && key ? '.' : '') + key, parent: target, reference: state.reference ***REMOVED***;
            result = child.schema._validate(item, localState, options);
            if (result.errors) ***REMOVED***
                errors.push(Errors.create('object.child', ***REMOVED*** key: key, reason: result.errors ***REMOVED***, localState, options));

                if (options.abortEarly) ***REMOVED***
                    return finish();
                ***REMOVED***
            ***REMOVED***

            if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) ***REMOVED***
                delete target[key];
            ***REMOVED***
            else if (result.value !== undefined) ***REMOVED***
                target[key] = result.value;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    // Unknown keys

    var unprocessedKeys = Object.keys(unprocessed);
    if (unprocessedKeys.length &&
        this._inner.patterns.length) ***REMOVED***

        for (i = 0, il = unprocessedKeys.length; i < il; ++i) ***REMOVED***
            key = unprocessedKeys[i];

            for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) ***REMOVED***
                var pattern = this._inner.patterns[p];

                if (pattern.regex.test(key)) ***REMOVED***
                    delete unprocessed[key];

                    item = target[key];
                    localState = ***REMOVED*** key: key, path: (state.path ? state.path + '.' : '') + key, parent: target, reference: state.reference ***REMOVED***;
                    result = pattern.rule._validate(item, localState, options);
                    if (result.errors) ***REMOVED***
                        errors.push(Errors.create('object.child', ***REMOVED*** key: key, reason: result.errors ***REMOVED***, localState, options));

                        if (options.abortEarly) ***REMOVED***
                            return finish();
                        ***REMOVED***
                    ***REMOVED***

                    if (result.value !== undefined) ***REMOVED***
                        target[key] = result.value;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        unprocessedKeys = Object.keys(unprocessed);
    ***REMOVED***

    if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) ***REMOVED***
        if (options.stripUnknown ||
            options.skipFunctions) ***REMOVED***

            for (var k = 0, kl = unprocessedKeys.length; k < kl; ++k) ***REMOVED***
                key = unprocessedKeys[k];

                if (options.stripUnknown) ***REMOVED***
                    delete target[key];
                    delete unprocessed[key];
                ***REMOVED***
                else if (typeof target[key] === 'function') ***REMOVED***
                    delete unprocessed[key];
                ***REMOVED***
            ***REMOVED***

            unprocessedKeys = Object.keys(unprocessed);
        ***REMOVED***

        if (unprocessedKeys.length &&
            (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) ***REMOVED***

            for (var e = 0, el = unprocessedKeys.length; e < el; ++e) ***REMOVED***
                errors.push(Errors.create('object.allowUnknown', null, ***REMOVED*** key: unprocessedKeys[e], path: state.path + (state.path ? '.' : '') + unprocessedKeys[e] ***REMOVED***, options));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    // Validate dependencies

    for (var d = 0, dl = this._inner.dependencies.length; d < dl; ++d) ***REMOVED***
        var dep = this._inner.dependencies[d];
        var err = internals[dep.type](dep.key !== null && value[dep.key], dep.peers, target, ***REMOVED*** key: dep.key, path: (state.path || '') + (dep.key ? '.' + dep.key : '') ***REMOVED***, options);
        if (err) ***REMOVED***
            errors.push(err);
            if (options.abortEarly) ***REMOVED***
                return finish();
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return finish();
***REMOVED***;


internals.Object.prototype._func = function () ***REMOVED***

    var obj = this.clone();
    obj._flags.func = true;
    return obj;
***REMOVED***;


internals.Object.prototype.keys = function (schema) ***REMOVED***

    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
    Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');

    var obj = this.clone();

    if (!schema) ***REMOVED***
        obj._inner.children = null;
        return obj;
    ***REMOVED***

    var children = Object.keys(schema);

    if (!children.length) ***REMOVED***
        obj._inner.children = [];
        return obj;
    ***REMOVED***

    var topo = new Topo();
    var child;
    if (obj._inner.children) ***REMOVED***
        for (var i = 0, il = obj._inner.children.length; i < il; ++i) ***REMOVED***
            child = obj._inner.children[i];

            // Only add the key if we are not going to replace it later
            if (children.indexOf(child.key) === -1) ***REMOVED***
                topo.add(child, ***REMOVED*** after: child._refs, group: child.key ***REMOVED***);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    for (var c = 0, cl = children.length; c < cl; ++c) ***REMOVED***
        var key = children[c];
        child = schema[key];
        try ***REMOVED***
            var cast = Cast.schema(child);
            topo.add(***REMOVED*** key: key, schema: cast ***REMOVED***, ***REMOVED*** after: cast._refs, group: key ***REMOVED***);
        ***REMOVED***
        catch (castErr) ***REMOVED***
            if (castErr.hasOwnProperty('path')) ***REMOVED***
                castErr.path = key + '.' + castErr.path;
            ***REMOVED***
            else ***REMOVED***
                castErr.path = key;
            ***REMOVED***
            throw castErr;
        ***REMOVED***
    ***REMOVED***

    obj._inner.children = topo.nodes;

    return obj;
***REMOVED***;


internals.Object.prototype.unknown = function (allow) ***REMOVED***

    var obj = this.clone();
    obj._flags.allowUnknown = (allow !== false);
    return obj;
***REMOVED***;


internals.Object.prototype.length = function (limit) ***REMOVED***

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('length', limit, function (value, state, options) ***REMOVED***

        if (Object.keys(value).length === limit) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('object.length', ***REMOVED*** limit: limit ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Object.prototype.min = function (limit) ***REMOVED***

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('min', limit, function (value, state, options) ***REMOVED***

        if (Object.keys(value).length >= limit) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('object.min', ***REMOVED*** limit: limit ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Object.prototype.max = function (limit) ***REMOVED***

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('max', limit, function (value, state, options) ***REMOVED***

        if (Object.keys(value).length <= limit) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('object.max', ***REMOVED*** limit: limit ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Object.prototype.pattern = function (pattern, schema) ***REMOVED***

    Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');
    Hoek.assert(schema !== undefined, 'Invalid rule');

    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags

    try ***REMOVED***
        schema = Cast.schema(schema);
    ***REMOVED***
    catch (castErr) ***REMOVED***
        if (castErr.hasOwnProperty('path')) ***REMOVED***
            castErr.message += '(' + castErr.path + ')';
        ***REMOVED***

        throw castErr;
    ***REMOVED***


    var obj = this.clone();
    obj._inner.patterns.push(***REMOVED*** regex: pattern, rule: schema ***REMOVED***);
    return obj;
***REMOVED***;


internals.Object.prototype.with = function (key, peers) ***REMOVED***

    return this._dependency('with', key, peers);
***REMOVED***;


internals.Object.prototype.without = function (key, peers) ***REMOVED***

    return this._dependency('without', key, peers);
***REMOVED***;


internals.Object.prototype.xor = function () ***REMOVED***

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('xor', null, peers);
***REMOVED***;


internals.Object.prototype.or = function () ***REMOVED***

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('or', null, peers);
***REMOVED***;


internals.Object.prototype.and = function () ***REMOVED***

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('and', null, peers);
***REMOVED***;


internals.Object.prototype.nand = function () ***REMOVED***

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency('nand', null, peers);
***REMOVED***;


internals.Object.prototype.requiredKeys = function (children) ***REMOVED***

    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, 'required');
***REMOVED***;


internals.Object.prototype.optionalKeys = function (children) ***REMOVED***

    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, 'optional');
***REMOVED***;


internals.renameDefaults = ***REMOVED***
    alias: false,                   // Keep old value in place
    multiple: false,                // Allow renaming multiple keys into the same target
    override: false                 // Overrides an existing key
***REMOVED***;


internals.Object.prototype.rename = function (from, to, options) ***REMOVED***

    Hoek.assert(typeof from === 'string', 'Rename missing the from argument');
    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

    for (var i = 0, il = this._inner.renames.length; i < il; ++i) ***REMOVED***
        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
    ***REMOVED***

    var obj = this.clone();

    obj._inner.renames.push(***REMOVED***
        from: from,
        to: to,
        options: Hoek.applyToDefaults(internals.renameDefaults, options || ***REMOVED******REMOVED***)
    ***REMOVED***);

    return obj;
***REMOVED***;


internals.groupChildren = function (children) ***REMOVED***

    children.sort();

    var grouped = ***REMOVED******REMOVED***;

    for (var c = 0, lc = children.length; c < lc; c++) ***REMOVED***
        var child = children[c];
        Hoek.assert(typeof child === 'string', 'children must be strings');
        var group = child.split('.')[0];
        var childGroup = grouped[group] = (grouped[group] || []);
        childGroup.push(child.substring(group.length + 1));
    ***REMOVED***

    return grouped;
***REMOVED***;


internals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) ***REMOVED***

    children = [].concat(children);
    Hoek.assert(children.length > 0, 'expected at least one children');

    var groupedChildren = internals.groupChildren(children);
    var obj;

    if ('' in groupedChildren) ***REMOVED***
        obj = this[fn].apply(this, args);
        delete groupedChildren[''];
    ***REMOVED***
    else ***REMOVED***
        obj = this.clone();
    ***REMOVED***

    if (obj._inner.children) ***REMOVED***
        root = root ? (root + '.') : '';

        for (var i = 0, il = obj._inner.children.length; i < il; ++i) ***REMOVED***
            var child = obj._inner.children[i];
            var group = groupedChildren[child.key];

            if (group) ***REMOVED***
                obj._inner.children[i] = ***REMOVED***
                    key: child.key,
                    _refs: child._refs,
                    schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                ***REMOVED***;

                delete groupedChildren[child.key];
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    var remaining = Object.keys(groupedChildren);
    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));

    return obj;
***REMOVED***;


internals.Object.prototype._dependency = function (type, key, peers) ***REMOVED***

    peers = [].concat(peers);
    for (var i = 0, li = peers.length; i < li; i++) ***REMOVED***
        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
    ***REMOVED***

    var obj = this.clone();
    obj._inner.dependencies.push(***REMOVED*** type: type, key: key, peers: peers ***REMOVED***);
    return obj;
***REMOVED***;


internals.with = function (value, peers, parent, state, options) ***REMOVED***

    if (value === undefined) ***REMOVED***
        return null;
    ***REMOVED***

    for (var i = 0, il = peers.length; i < il; ++i) ***REMOVED***
        var peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||
            parent[peer] === undefined) ***REMOVED***

            return Errors.create('object.with', ***REMOVED*** peer: peer ***REMOVED***, state, options);
        ***REMOVED***
    ***REMOVED***

    return null;
***REMOVED***;


internals.without = function (value, peers, parent, state, options) ***REMOVED***

    if (value === undefined) ***REMOVED***
        return null;
    ***REMOVED***

    for (var i = 0, il = peers.length; i < il; ++i) ***REMOVED***
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
            parent[peer] !== undefined) ***REMOVED***

            return Errors.create('object.without', ***REMOVED*** peer: peer ***REMOVED***, state, options);
        ***REMOVED***
    ***REMOVED***

    return null;
***REMOVED***;


internals.xor = function (value, peers, parent, state, options) ***REMOVED***

    var present = [];
    for (var i = 0, il = peers.length; i < il; ++i) ***REMOVED***
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
            parent[peer] !== undefined) ***REMOVED***

            present.push(peer);
        ***REMOVED***
    ***REMOVED***

    if (present.length === 1) ***REMOVED***
        return null;
    ***REMOVED***

    if (present.length === 0) ***REMOVED***
        return Errors.create('object.missing', ***REMOVED*** peers: peers ***REMOVED***, state, options);
    ***REMOVED***

    return Errors.create('object.xor', ***REMOVED*** peers: peers ***REMOVED***, state, options);
***REMOVED***;


internals.or = function (value, peers, parent, state, options) ***REMOVED***

    for (var i = 0, il = peers.length; i < il; ++i) ***REMOVED***
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
            parent[peer] !== undefined) ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***

    return Errors.create('object.missing', ***REMOVED*** peers: peers ***REMOVED***, state, options);
***REMOVED***;


internals.and = function (value, peers, parent, state, options) ***REMOVED***

    var missing = [];
    var present = [];
    var count = peers.length;
    for (var i = 0; i < count; ++i) ***REMOVED***
        var peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||
            parent[peer] === undefined) ***REMOVED***

            missing.push(peer);
        ***REMOVED***
        else ***REMOVED***
            present.push(peer);
        ***REMOVED***
    ***REMOVED***

    var aon = (missing.length === count || present.length === count);
    return !aon ? Errors.create('object.and', ***REMOVED*** present: present, missing: missing ***REMOVED***, state, options) : null;
***REMOVED***;


internals.nand = function (value, peers, parent, state, options) ***REMOVED***

    var present = [];
    for (var i = 0, il = peers.length; i < il; ++i) ***REMOVED***
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &&
            parent[peer] !== undefined) ***REMOVED***

            present.push(peer);
        ***REMOVED***
    ***REMOVED***

    var values = Hoek.clone(peers);
    var main = values.splice(0, 1)[0];
    var allPresent = (present.length === peers.length);
    return allPresent ? Errors.create('object.nand', ***REMOVED*** main: main, peers: values ***REMOVED***, state, options) : null;
***REMOVED***;


internals.Object.prototype.describe = function (shallow) ***REMOVED***

    var description = Any.prototype.describe.call(this);

    if (this._inner.children &&
        !shallow) ***REMOVED***

        description.children = ***REMOVED******REMOVED***;
        for (var i = 0, il = this._inner.children.length; i < il; ++i) ***REMOVED***
            var child = this._inner.children[i];
            description.children[child.key] = child.schema.describe();
        ***REMOVED***
    ***REMOVED***

    if (this._inner.dependencies.length) ***REMOVED***
        description.dependencies = Hoek.clone(this._inner.dependencies);
    ***REMOVED***

    if (this._inner.patterns.length) ***REMOVED***
        description.patterns = [];

        for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) ***REMOVED***
            var pattern = this._inner.patterns[p];
            description.patterns.push(***REMOVED*** regex: pattern.regex.toString(), rule: pattern.rule.describe() ***REMOVED***);
        ***REMOVED***
    ***REMOVED***

    return description;
***REMOVED***;


internals.Object.prototype.assert = function (ref, schema, message) ***REMOVED***

    ref = Cast.ref(ref);
    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
    message = message || 'pass the assertion test';

    var cast;
    try ***REMOVED***
        cast = Cast.schema(schema);
    ***REMOVED***
    catch (castErr) ***REMOVED***
        if (castErr.hasOwnProperty('path')) ***REMOVED***
            castErr.message += '(' + castErr.path + ')';
        ***REMOVED***

        throw castErr;
    ***REMOVED***

    var key = ref.path[ref.path.length - 1];
    var path = ref.path.join('.');

    return this._test('assert', ***REMOVED*** cast: cast, ref: ref ***REMOVED***, function (value, state, options) ***REMOVED***

        var result = cast._validate(ref(value), null, options, value);
        if (!result.errors) ***REMOVED***
            return null;
        ***REMOVED***

        var localState = Hoek.merge(***REMOVED******REMOVED***, state);
        localState.key = key;
        localState.path = path;
        return Errors.create('object.assert', ***REMOVED*** ref: localState.path, message: message ***REMOVED***, localState, options);
    ***REMOVED***);
***REMOVED***;


internals.Object.prototype.type = function (constructor, name) ***REMOVED***

    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
    name = name || constructor.name;

    return this._test('type', name, function (value, state, options) ***REMOVED***

        if (value instanceof constructor) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('object.type', ***REMOVED*** type: name ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


module.exports = new internals.Object();
