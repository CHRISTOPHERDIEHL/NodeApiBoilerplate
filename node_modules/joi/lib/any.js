// Load modules

var Hoek = require('hoek');
var Ref = require('./ref');
var Errors = require('./errors');
var Alternatives = null;                // Delay-loaded to prevent circular dependencies
var Cast = null;


// Declare internals

var internals = ***REMOVED******REMOVED***;


internals.defaults = ***REMOVED***
    abortEarly: true,
    convert: true,
    allowUnknown: false,
    skipFunctions: false,
    stripUnknown: false,
    language: ***REMOVED******REMOVED***,
    presence: 'optional',
    raw: false,
    strip: false,
    noDefaults: false

    // context: null
***REMOVED***;


internals.checkOptions = function (options) ***REMOVED***

    var optionType = ***REMOVED***
        abortEarly: 'boolean',
        convert: 'boolean',
        allowUnknown: 'boolean',
        skipFunctions: 'boolean',
        stripUnknown: 'boolean',
        language: 'object',
        presence: ['string', 'required', 'optional', 'forbidden', 'ignore'],
        raw: 'boolean',
        context: 'object',
        strip: 'boolean',
        noDefaults: 'boolean'
    ***REMOVED***;

    var keys = Object.keys(options);
    for (var k = 0, kl = keys.length; k < kl; ++k) ***REMOVED***
        var key = keys[k];
        var opt = optionType[key];
        var type = opt;
        var values = null;

        if (Array.isArray(opt)) ***REMOVED***
            type = opt[0];
            values = opt.slice(1);
        ***REMOVED***

        Hoek.assert(type, 'unknown key ' + key);
        Hoek.assert(typeof options[key] === type, key + ' should be of type ' + type);
        if (values) ***REMOVED***
            Hoek.assert(values.indexOf(options[key]) >= 0, key + ' should be one of ' + values.join(', '));
        ***REMOVED***
    ***REMOVED***
***REMOVED***;


module.exports = internals.Any = function () ***REMOVED***

    Cast = Cast || require('./cast');

    this.isJoi = true;
    this._type = 'any';
    this._settings = null;
    this._valids = new internals.Set();
    this._invalids = new internals.Set();
    this._tests = [];
    this._refs = [];
    this._flags = ***REMOVED*** /*
        presence: 'optional',                   // optional, required, forbidden, ignore
        allowOnly: false,
        allowUnknown: undefined,
        default: undefined,
        forbidden: false,
        encoding: undefined,
        insensitive: false,
        trim: false,
        case: undefined,                        // upper, lower
        empty: undefined,
        func: false
    */ ***REMOVED***;

    this._description = null;
    this._unit = null;
    this._notes = [];
    this._tags = [];
    this._examples = [];
    this._meta = [];

    this._inner = ***REMOVED******REMOVED***;                           // Hash of arrays of immutable objects
***REMOVED***;


internals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects


internals.Any.prototype.clone = function () ***REMOVED***

    var obj = Object.create(Object.getPrototypeOf(this));

    obj.isJoi = true;
    obj._type = this._type;
    obj._settings = internals.concatSettings(this._settings);
    obj._valids = Hoek.clone(this._valids);
    obj._invalids = Hoek.clone(this._invalids);
    obj._tests = this._tests.slice();
    obj._refs = this._refs.slice();
    obj._flags = Hoek.clone(this._flags);

    obj._description = this._description;
    obj._unit = this._unit;
    obj._notes = this._notes.slice();
    obj._tags = this._tags.slice();
    obj._examples = this._examples.slice();
    obj._meta = this._meta.slice();

    obj._inner = ***REMOVED******REMOVED***;
    var inners = Object.keys(this._inner);
    for (var i = 0, il = inners.length; i < il; ++i) ***REMOVED***
        var key = inners[i];
        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
    ***REMOVED***

    return obj;
***REMOVED***;


internals.Any.prototype.concat = function (schema) ***REMOVED***

    Hoek.assert(schema && schema.isJoi, 'Invalid schema object');
    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);

    var obj = this.clone();

    if (this._type === 'any' && schema._type !== 'any') ***REMOVED***

        // Reset values as if we were "this"
        var tmpObj = schema.clone();
        var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',
            '_notes', '_tags', '_examples', '_meta', '_inner'];

        for (var j = 0, jl = keysToRestore.length; j < jl; ++j) ***REMOVED***
            tmpObj[keysToRestore[j]] = obj[keysToRestore[j]];
        ***REMOVED***

        obj = tmpObj;
    ***REMOVED***

    obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;
    obj._valids.merge(schema._valids, schema._invalids);
    obj._invalids.merge(schema._invalids, schema._valids);
    obj._tests = obj._tests.concat(schema._tests);
    obj._refs = obj._refs.concat(schema._refs);
    Hoek.merge(obj._flags, schema._flags);

    obj._description = schema._description || obj._description;
    obj._unit = schema._unit || obj._unit;
    obj._notes = obj._notes.concat(schema._notes);
    obj._tags = obj._tags.concat(schema._tags);
    obj._examples = obj._examples.concat(schema._examples);
    obj._meta = obj._meta.concat(schema._meta);

    var inners = Object.keys(schema._inner);
    var isObject = obj._type === 'object';
    for (var i = 0, il = inners.length; i < il; ++i) ***REMOVED***
        var key = inners[i];
        var source = schema._inner[key];
        if (source) ***REMOVED***
            var target = obj._inner[key];
            if (target) ***REMOVED***
                if (isObject && key === 'children') ***REMOVED***
                    var keys = ***REMOVED******REMOVED***;

                    for (var k = 0, kl = target.length; k < kl; ++k) ***REMOVED***
                        keys[target[k].key] = k;
                    ***REMOVED***

                    for (k = 0, kl = source.length; k < kl; ++k) ***REMOVED***
                        var sourceKey = source[k].key;
                        if (keys[sourceKey] >= 0) ***REMOVED***
                            target[keys[sourceKey]] = ***REMOVED***
                                key: sourceKey,
                                schema: target[keys[sourceKey]].schema.concat(source[k].schema)
                            ***REMOVED***;
                        ***REMOVED***
                        else ***REMOVED***
                            target.push(source[k]);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    obj._inner[key] = obj._inner[key].concat(source);
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                obj._inner[key] = source.slice();
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return obj;
***REMOVED***;


internals.Any.prototype._test = function (name, arg, func) ***REMOVED***

    Hoek.assert(!this._flags.allowOnly, 'Cannot define rules when valid values specified');

    var obj = this.clone();
    obj._tests.push(***REMOVED*** func: func, name: name, arg: arg ***REMOVED***);
    return obj;
***REMOVED***;


internals.Any.prototype.options = function (options) ***REMOVED***

    Hoek.assert(!options.context, 'Cannot override context');
    internals.checkOptions(options);

    var obj = this.clone();
    obj._settings = internals.concatSettings(obj._settings, options);
    return obj;
***REMOVED***;


internals.Any.prototype.strict = function (isStrict) ***REMOVED***

    var obj = this.clone();
    obj._settings = obj._settings || ***REMOVED******REMOVED***;
    obj._settings.convert = isStrict === undefined ? false : !isStrict;
    return obj;
***REMOVED***;


internals.Any.prototype.raw = function (isRaw) ***REMOVED***

    var obj = this.clone();
    obj._settings = obj._settings || ***REMOVED******REMOVED***;
    obj._settings.raw = isRaw === undefined ? true : isRaw;
    return obj;
***REMOVED***;


internals.Any.prototype._allow = function () ***REMOVED***

    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
    for (var i = 0, il = values.length; i < il; ++i) ***REMOVED***
        var value = values[i];

        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
        this._invalids.remove(value);
        this._valids.add(value, this._refs);
    ***REMOVED***
***REMOVED***;


internals.Any.prototype.allow = function () ***REMOVED***

    var obj = this.clone();
    obj._allow.apply(obj, arguments);
    return obj;
***REMOVED***;


internals.Any.prototype.valid = internals.Any.prototype.only = internals.Any.prototype.equal = function () ***REMOVED***

    Hoek.assert(!this._tests.length, 'Cannot set valid values when rules specified');

    var obj = this.allow.apply(this, arguments);
    obj._flags.allowOnly = true;
    return obj;
***REMOVED***;


internals.Any.prototype.invalid = internals.Any.prototype.disallow = internals.Any.prototype.not = function (value) ***REMOVED***

    var obj = this.clone();
    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
    for (var i = 0, il = values.length; i < il; ++i) ***REMOVED***
        value = values[i];

        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
        obj._valids.remove(value);
        obj._invalids.add(value, this._refs);
    ***REMOVED***

    return obj;
***REMOVED***;


internals.Any.prototype.required = internals.Any.prototype.exist = function () ***REMOVED***

    var obj = this.clone();
    obj._flags.presence = 'required';
    return obj;
***REMOVED***;


internals.Any.prototype.optional = function () ***REMOVED***

    var obj = this.clone();
    obj._flags.presence = 'optional';
    return obj;
***REMOVED***;


internals.Any.prototype.forbidden = function () ***REMOVED***

    var obj = this.clone();
    obj._flags.presence = 'forbidden';
    return obj;
***REMOVED***;


internals.Any.prototype.strip = function () ***REMOVED***

    var obj = this.clone();
    obj._flags.strip = true;
    return obj;
***REMOVED***;


internals.Any.prototype.applyFunctionToChildren = function (children, fn, args, root) ***REMOVED***

    children = [].concat(children);

    if (children.length !== 1 || children[0] !== '') ***REMOVED***
        root = root ? (root + '.') : '';

        var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) ***REMOVED***

            return root + child;
        ***REMOVED***);

        throw new Error('unknown key(s) ' + extraChildren.join(', '));
    ***REMOVED***

    return this[fn].apply(this, args);
***REMOVED***;


internals.Any.prototype.default = function (value, description) ***REMOVED***

    if (typeof value === 'function' &&
        !Ref.isRef(value)) ***REMOVED***

        if (!value.description &&
            description) ***REMOVED***

            value.description = description;
        ***REMOVED***

        if (!this._flags.func) ***REMOVED***
            Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
        ***REMOVED***
    ***REMOVED***

    var obj = this.clone();
    obj._flags.default = value;
    Ref.push(obj._refs, value);
    return obj;
***REMOVED***;


internals.Any.prototype.empty = function (schema) ***REMOVED***

    var obj;
    if (schema === undefined) ***REMOVED***
        obj = this.clone();
        obj._flags.empty = undefined;
    ***REMOVED***
    else ***REMOVED***
        schema = Cast.schema(schema);

        obj = this.clone();
        obj._flags.empty = schema;
    ***REMOVED***

    return obj;
***REMOVED***;


internals.Any.prototype.when = function (ref, options) ***REMOVED***

    Hoek.assert(options && typeof options === 'object', 'Invalid options');
    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

    var then = options.then ? this.concat(Cast.schema(options.then)) : this;
    var otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;

    Alternatives = Alternatives || require('./alternatives');
    var obj = Alternatives.when(ref, ***REMOVED*** is: options.is, then: then, otherwise: otherwise ***REMOVED***);
    obj._flags.presence = 'ignore';
    return obj;
***REMOVED***;


internals.Any.prototype.description = function (desc) ***REMOVED***

    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

    var obj = this.clone();
    obj._description = desc;
    return obj;
***REMOVED***;


internals.Any.prototype.notes = function (notes) ***REMOVED***

    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');

    var obj = this.clone();
    obj._notes = obj._notes.concat(notes);
    return obj;
***REMOVED***;


internals.Any.prototype.tags = function (tags) ***REMOVED***

    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');

    var obj = this.clone();
    obj._tags = obj._tags.concat(tags);
    return obj;
***REMOVED***;

internals.Any.prototype.meta = function (meta) ***REMOVED***

    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');

    var obj = this.clone();
    obj._meta = obj._meta.concat(meta);
    return obj;
***REMOVED***;


internals.Any.prototype.example = function (value) ***REMOVED***

    Hoek.assert(arguments.length, 'Missing example');
    var result = this._validate(value, null, internals.defaults);
    Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));

    var obj = this.clone();
    obj._examples = obj._examples.concat(value);
    return obj;
***REMOVED***;


internals.Any.prototype.unit = function (name) ***REMOVED***

    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

    var obj = this.clone();
    obj._unit = name;
    return obj;
***REMOVED***;


internals._try = function (fn, arg) ***REMOVED***

    var err;
    var result;

    try ***REMOVED***
        result = fn.call(null, arg);
    ***REMOVED*** catch (e) ***REMOVED***
        err = e;
    ***REMOVED***

    return ***REMOVED***
        value: result,
        error: err
    ***REMOVED***;
***REMOVED***;


internals.Any.prototype._validate = function (value, state, options, reference) ***REMOVED***

    var self = this;
    var originalValue = value;

    // Setup state and settings

    state = state || ***REMOVED*** key: '', path: '', parent: null, reference: reference ***REMOVED***;

    if (this._settings) ***REMOVED***
        options = internals.concatSettings(options, this._settings);
    ***REMOVED***

    var errors = [];
    var finish = function () ***REMOVED***

        var finalValue;

        if (!self._flags.strip) ***REMOVED***
            if (value !== undefined) ***REMOVED***
                finalValue = options.raw ? originalValue : value;
            ***REMOVED***
            else if (options.noDefaults) ***REMOVED***
                finalValue = originalValue;
            ***REMOVED***
            else if (Ref.isRef(self._flags.default)) ***REMOVED***
                finalValue = self._flags.default(state.parent, options);
            ***REMOVED***
            else if (typeof self._flags.default === 'function' &&
                    !(self._flags.func && !self._flags.default.description)) ***REMOVED***

                var arg;

                if (state.parent !== null &&
                    self._flags.default.length > 0) ***REMOVED***

                    arg = Hoek.clone(state.parent);
                ***REMOVED***

                var defaultValue = internals._try(self._flags.default, arg);
                finalValue = defaultValue.value;
                if (defaultValue.error) ***REMOVED***
                    errors.push(Errors.create('any.default', defaultValue.error, state, options));
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                finalValue = Hoek.clone(self._flags.default);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            value: finalValue,
            errors: errors.length ? errors : null
        ***REMOVED***;
    ***REMOVED***;

    // Check presence requirements

    var presence = this._flags.presence || options.presence;
    if (presence === 'optional') ***REMOVED***
        if (value === undefined) ***REMOVED***
            var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;
            if (isDeepDefault && this._type === 'object') ***REMOVED***
                value = ***REMOVED******REMOVED***;
            ***REMOVED***
            else ***REMOVED***
                return finish();
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    else if (presence === 'required' &&
            value === undefined) ***REMOVED***

        errors.push(Errors.create('any.required', null, state, options));
        return finish();
    ***REMOVED***
    else if (presence === 'forbidden') ***REMOVED***
        if (value === undefined) ***REMOVED***
            return finish();
        ***REMOVED***

        errors.push(Errors.create('any.unknown', null, state, options));
        return finish();
    ***REMOVED***

    if (this._flags.empty && !this._flags.empty._validate(value, null, internals.defaults).errors) ***REMOVED***
        value = undefined;
        return finish();
    ***REMOVED***

    // Check allowed and denied values using the original value

    if (this._valids.has(value, state, options, this._flags.insensitive)) ***REMOVED***
        return finish();
    ***REMOVED***

    if (this._invalids.has(value, state, options, this._flags.insensitive)) ***REMOVED***
        errors.push(Errors.create(value === '' ? 'any.empty' : 'any.invalid', null, state, options));
        if (options.abortEarly ||
            value === undefined) ***REMOVED***          // No reason to keep validating missing value

            return finish();
        ***REMOVED***
    ***REMOVED***

    // Convert value and validate type

    if (this._base) ***REMOVED***
        var base = this._base.call(this, value, state, options);
        if (base.errors) ***REMOVED***
            value = base.value;
            errors = errors.concat(base.errors);
            return finish();                            // Base error always aborts early
        ***REMOVED***

        if (base.value !== value) ***REMOVED***
            value = base.value;

            // Check allowed and denied values using the converted value

            if (this._valids.has(value, state, options, this._flags.insensitive)) ***REMOVED***
                return finish();
            ***REMOVED***

            if (this._invalids.has(value, state, options, this._flags.insensitive)) ***REMOVED***
                errors.push(Errors.create('any.invalid', null, state, options));
                if (options.abortEarly) ***REMOVED***
                    return finish();
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    // Required values did not match

    if (this._flags.allowOnly) ***REMOVED***
        errors.push(Errors.create('any.allowOnly', ***REMOVED*** valids: this._valids.values(***REMOVED*** stripUndefined: true ***REMOVED***) ***REMOVED***, state, options));
        if (options.abortEarly) ***REMOVED***
            return finish();
        ***REMOVED***
    ***REMOVED***

    // Helper.validate tests

    for (var i = 0, il = this._tests.length; i < il; ++i) ***REMOVED***
        var test = this._tests[i];
        var err = test.func.call(this, value, state, options);
        if (err) ***REMOVED***
            errors.push(err);
            if (options.abortEarly) ***REMOVED***
                return finish();
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return finish();
***REMOVED***;


internals.Any.prototype._validateWithOptions = function (value, options, callback) ***REMOVED***

    if (options) ***REMOVED***
        internals.checkOptions(options);
    ***REMOVED***

    var settings = internals.concatSettings(internals.defaults, options);
    var result = this._validate(value, null, settings);
    var errors = Errors.process(result.errors, value);

    if (callback) ***REMOVED***
        return callback(errors, result.value);
    ***REMOVED***

    return ***REMOVED*** error: errors, value: result.value ***REMOVED***;
***REMOVED***;


internals.Any.prototype.validate = function (value, callback) ***REMOVED***

    var result = this._validate(value, null, internals.defaults);
    var errors = Errors.process(result.errors, value);

    if (callback) ***REMOVED***
        return callback(errors, result.value);
    ***REMOVED***

    return ***REMOVED*** error: errors, value: result.value ***REMOVED***;
***REMOVED***;


internals.Any.prototype.describe = function () ***REMOVED***

    var description = ***REMOVED***
        type: this._type
    ***REMOVED***;

    var flags = Object.keys(this._flags);
    if (flags.length) ***REMOVED***
        if (this._flags.empty) ***REMOVED***
            description.flags = ***REMOVED******REMOVED***;
            for (var f = 0, fl = flags.length; f < fl; ++f) ***REMOVED***
                var flag = flags[f];
                description.flags[flag] = flag === 'empty' ? this._flags[flag].describe() : this._flags[flag];
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            description.flags = this._flags;
        ***REMOVED***
    ***REMOVED***

    if (this._description) ***REMOVED***
        description.description = this._description;
    ***REMOVED***

    if (this._notes.length) ***REMOVED***
        description.notes = this._notes;
    ***REMOVED***

    if (this._tags.length) ***REMOVED***
        description.tags = this._tags;
    ***REMOVED***

    if (this._meta.length) ***REMOVED***
        description.meta = this._meta;
    ***REMOVED***

    if (this._examples.length) ***REMOVED***
        description.examples = this._examples;
    ***REMOVED***

    if (this._unit) ***REMOVED***
        description.unit = this._unit;
    ***REMOVED***

    var valids = this._valids.values();
    if (valids.length) ***REMOVED***
        description.valids = valids;
    ***REMOVED***

    var invalids = this._invalids.values();
    if (invalids.length) ***REMOVED***
        description.invalids = invalids;
    ***REMOVED***

    description.rules = [];

    for (var i = 0, il = this._tests.length; i < il; ++i) ***REMOVED***
        var validator = this._tests[i];
        var item = ***REMOVED*** name: validator.name ***REMOVED***;
        if (validator.arg !== void 0) ***REMOVED***
            item.arg = validator.arg;
        ***REMOVED***
        description.rules.push(item);
    ***REMOVED***

    if (!description.rules.length) ***REMOVED***
        delete description.rules;
    ***REMOVED***

    var label = Hoek.reach(this._settings, 'language.label');
    if (label) ***REMOVED***
        description.label = label;
    ***REMOVED***

    return description;
***REMOVED***;

internals.Any.prototype.label = function (name) ***REMOVED***

    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');

    var obj = this.clone();
    var options = ***REMOVED*** language: ***REMOVED*** label: name ***REMOVED*** ***REMOVED***;

    // If language.label is set, it should override this label
    obj._settings = internals.concatSettings(options, obj._settings);
    return obj;
***REMOVED***;


// Set

internals.Set = function () ***REMOVED***

    this._set = [];
***REMOVED***;


internals.Set.prototype.add = function (value, refs) ***REMOVED***

    Hoek.assert(value === null || value === undefined || value instanceof Date || Buffer.isBuffer(value) || Ref.isRef(value) || (typeof value !== 'function' && typeof value !== 'object'), 'Value cannot be an object or function');

    if (typeof value !== 'function' &&
        this.has(value, null, null, false)) ***REMOVED***

        return;
    ***REMOVED***

    Ref.push(refs, value);
    this._set.push(value);
***REMOVED***;


internals.Set.prototype.merge = function (add, remove) ***REMOVED***

    for (var i = 0, il = add._set.length; i < il; ++i) ***REMOVED***
        this.add(add._set[i]);
    ***REMOVED***

    for (i = 0, il = remove._set.length; i < il; ++i) ***REMOVED***
        this.remove(remove._set[i]);
    ***REMOVED***
***REMOVED***;


internals.Set.prototype.remove = function (value) ***REMOVED***

    this._set = this._set.filter(function (item) ***REMOVED***

        return value !== item;
    ***REMOVED***);
***REMOVED***;


internals.Set.prototype.has = function (value, state, options, insensitive) ***REMOVED***

    for (var i = 0, il = this._set.length; i < il; ++i) ***REMOVED***
        var items = this._set[i];

        if (Ref.isRef(items)) ***REMOVED***
            items = items(state.reference || state.parent, options);
        ***REMOVED***

        if (!Array.isArray(items)) ***REMOVED***
            items = [items];
        ***REMOVED***

        for (var j = 0, jl = items.length; j < jl; ++j) ***REMOVED***
            var item = items[j];
            if (typeof value !== typeof item) ***REMOVED***
                continue;
            ***REMOVED***

            if (value === item ||
                (value instanceof Date && item instanceof Date && value.getTime() === item.getTime()) ||
                (insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase()) ||
                (Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary'))) ***REMOVED***

                return true;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return false;
***REMOVED***;


internals.Set.prototype.values = function (options) ***REMOVED***

    if (options && options.stripUndefined) ***REMOVED***
        var values = [];

        for (var i = 0, il = this._set.length; i < il; ++i) ***REMOVED***
            var item = this._set[i];
            if (item !== undefined) ***REMOVED***
                values.push(item);
            ***REMOVED***
        ***REMOVED***

        return values;
    ***REMOVED***

    return this._set.slice();
***REMOVED***;


internals.concatSettings = function (target, source) ***REMOVED***

    // Used to avoid cloning context

    if (!target &&
        !source) ***REMOVED***

        return null;
    ***REMOVED***

    var key, obj = ***REMOVED******REMOVED***;

    if (target) ***REMOVED***
        var tKeys = Object.keys(target);
        for (var i = 0, il = tKeys.length; i < il; ++i) ***REMOVED***
            key = tKeys[i];
            obj[key] = target[key];
        ***REMOVED***
    ***REMOVED***

    if (source) ***REMOVED***
        var sKeys = Object.keys(source);
        for (var j = 0, jl = sKeys.length; j < jl; ++j) ***REMOVED***
            key = sKeys[j];
            if (key !== 'language' ||
                !obj.hasOwnProperty(key)) ***REMOVED***

                obj[key] = source[key];
            ***REMOVED***
            else ***REMOVED***
                obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return obj;
***REMOVED***;
