// Load modules

var Net = require('net');
var Hoek = require('hoek');
var Isemail = require('isemail');
var Any = require('./any');
var Ref = require('./ref');
var JoiDate = require('./date');
var Errors = require('./errors');
var Uri = require('./string/uri');
var Ip = require('./string/ip');

// Declare internals

var internals = ***REMOVED***
    uriRegex: Uri.createUriRegex(),
    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')
***REMOVED***;

internals.String = function () ***REMOVED***

    Any.call(this);
    this._type = 'string';
    this._invalids.add('');
***REMOVED***;

Hoek.inherits(internals.String, Any);

internals.compare = function (type, compare) ***REMOVED***

    return function (limit, encoding) ***REMOVED***

        var isRef = Ref.isRef(limit);

        Hoek.assert((Hoek.isInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');
        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

        return this._test(type, limit, function (value, state, options) ***REMOVED***

            var compareTo;
            if (isRef) ***REMOVED***
                compareTo = limit(state.parent, options);

                if (!Hoek.isInteger(compareTo)) ***REMOVED***
                    return Errors.create('string.ref', ***REMOVED*** ref: limit.key ***REMOVED***, state, options);
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                compareTo = limit;
            ***REMOVED***

            if (compare(value, compareTo, encoding)) ***REMOVED***
                return null;
            ***REMOVED***

            return Errors.create('string.' + type, ***REMOVED*** limit: compareTo, value: value, encoding: encoding ***REMOVED***, state, options);
        ***REMOVED***);
    ***REMOVED***;
***REMOVED***;

internals.String.prototype._base = function (value, state, options) ***REMOVED***

    if (typeof value === 'string' &&
        options.convert) ***REMOVED***

        if (this._flags.case) ***REMOVED***
            value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
        ***REMOVED***

        if (this._flags.trim) ***REMOVED***
            value = value.trim();
        ***REMOVED***

        if (this._inner.replacements) ***REMOVED***

            for (var r = 0, rl = this._inner.replacements.length; r < rl; ++r) ***REMOVED***
                var replacement = this._inner.replacements[r];
                value = value.replace(replacement.pattern, replacement.replacement);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
        value: value,
        errors: (typeof value === 'string') ? null : Errors.create('string.base', ***REMOVED*** value: value ***REMOVED***, state, options)
    ***REMOVED***;
***REMOVED***;


internals.String.prototype.insensitive = function () ***REMOVED***

    var obj = this.clone();
    obj._flags.insensitive = true;
    return obj;
***REMOVED***;


internals.String.prototype.min = internals.compare('min', function (value, limit, encoding) ***REMOVED***

    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length >= limit;
***REMOVED***);


internals.String.prototype.max = internals.compare('max', function (value, limit, encoding) ***REMOVED***

    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length <= limit;
***REMOVED***);


internals.String.prototype.creditCard = function () ***REMOVED***

    return this._test('creditCard', undefined, function (value, state, options) ***REMOVED***

        var i = value.length;
        var sum = 0;
        var mul = 1;
        var char;

        while (i--) ***REMOVED***
            char = value.charAt(i) * mul;
            sum += char - (char > 9) * 9;
            mul ^= 3;
        ***REMOVED***

        var check = (sum % 10 === 0) && (sum > 0);
        return check ? null : Errors.create('string.creditCard', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;

internals.String.prototype.length = internals.compare('length', function (value, limit, encoding) ***REMOVED***

    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length === limit;
***REMOVED***);


internals.String.prototype.regex = function (pattern, name) ***REMOVED***

    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');

    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags

    return this._test('regex', pattern, function (value, state, options) ***REMOVED***

        if (pattern.test(value)) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create((name ? 'string.regex.name' : 'string.regex.base'), ***REMOVED*** name: name, pattern: pattern, value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.alphanum = function () ***REMOVED***

    return this._test('alphanum', undefined, function (value, state, options) ***REMOVED***

        if (/^[a-zA-Z0-9]+$/.test(value)) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('string.alphanum', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.token = function () ***REMOVED***

    return this._test('token', undefined, function (value, state, options) ***REMOVED***

        if (/^\w+$/.test(value)) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('string.token', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.email = function (isEmailOptions) ***REMOVED***

    if (isEmailOptions) ***REMOVED***
        Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');
        Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');
        Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||
            typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');
        Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' ||
            Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0,
            'minDomainAtoms must be a positive integer');
        Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' ||
            (Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0),
            'errorLevel must be a non-negative integer or boolean');
    ***REMOVED***

    return this._test('email', isEmailOptions, function (value, state, options) ***REMOVED***

        try ***REMOVED***
            var result = Isemail(value, isEmailOptions);
            if (result === true || result === 0) ***REMOVED***
                return null;
            ***REMOVED***
        ***REMOVED***
        catch (e) ***REMOVED******REMOVED***

        return Errors.create('string.email', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.ip = function (ipOptions) ***REMOVED***

    var regex = internals.ipRegex;
    ipOptions = ipOptions || ***REMOVED******REMOVED***;
    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');

    if (ipOptions.cidr) ***REMOVED***
        Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
        ipOptions.cidr = ipOptions.cidr.toLowerCase();

        Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', '));

        // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default
        if (!ipOptions.version && ipOptions.cidr !== 'optional') ***REMOVED***
            regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***

        // Set our default cidr strategy
        ipOptions.cidr = 'optional';
    ***REMOVED***

    if (ipOptions.version) ***REMOVED***
        if (!Array.isArray(ipOptions.version)) ***REMOVED***
            ipOptions.version = [ipOptions.version];
        ***REMOVED***

        Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');

        var versions = [];
        for (var i = 0, il = ipOptions.version.length; i < il; ++i) ***REMOVED***
            var version = ipOptions.version[i];
            Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
            version = version.toLowerCase();
            Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
            versions.push(version);
        ***REMOVED***

        // Make sure we have a set of versions
        versions = Hoek.unique(versions);

        regex = Ip.createIpRegex(versions, ipOptions.cidr);
    ***REMOVED***

    return this._test('ip', ipOptions, function (value, state, options) ***REMOVED***

        if (regex.test(value)) ***REMOVED***
            return null;
        ***REMOVED***

        if (versions) ***REMOVED***
            return Errors.create('string.ipVersion', ***REMOVED*** value: value, cidr: ipOptions.cidr, version: versions ***REMOVED***, state, options);
        ***REMOVED***

        return Errors.create('string.ip', ***REMOVED*** value: value, cidr: ipOptions.cidr ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.uri = function (uriOptions) ***REMOVED***

    var customScheme = '',
        regex = internals.uriRegex;

    if (uriOptions) ***REMOVED***
        Hoek.assert(typeof uriOptions === 'object', 'options must be an object');

        if (uriOptions.scheme) ***REMOVED***
            Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');

            if (!Array.isArray(uriOptions.scheme)) ***REMOVED***
                uriOptions.scheme = [uriOptions.scheme];
            ***REMOVED***

            Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');

            // Flatten the array into a string to be used to match the schemes.
            for (var i = 0, il = uriOptions.scheme.length; i < il; ++i) ***REMOVED***
                var scheme = uriOptions.scheme[i];
                Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

                // Add OR separators if a value already exists
                customScheme += customScheme ? '|' : '';

                // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
                if (scheme instanceof RegExp) ***REMOVED***
                    customScheme += scheme.source;
                ***REMOVED***
                else ***REMOVED***
                    Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                    customScheme += Hoek.escapeRegex(scheme);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    if (customScheme) ***REMOVED***
        regex = Uri.createUriRegex(customScheme);
    ***REMOVED***

    return this._test('uri', uriOptions, function (value, state, options) ***REMOVED***

        if (regex.test(value)) ***REMOVED***
            return null;
        ***REMOVED***

        if (customScheme) ***REMOVED***
            return Errors.create('string.uriCustomScheme', ***REMOVED*** scheme: customScheme, value: value ***REMOVED***, state, options);
        ***REMOVED***

        return Errors.create('string.uri', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.isoDate = function () ***REMOVED***

    return this._test('isoDate', undefined, function (value, state, options) ***REMOVED***

        if (JoiDate._isIsoDate(value)) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('string.isoDate', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.guid = function () ***REMOVED***

    var regex = /^[A-F0-9]***REMOVED***8***REMOVED***(?:-?[A-F0-9]***REMOVED***4***REMOVED***)***REMOVED***3***REMOVED***-?[A-F0-9]***REMOVED***12***REMOVED***$/i;
    var regex2 = /^\***REMOVED***[A-F0-9]***REMOVED***8***REMOVED***(?:-?[A-F0-9]***REMOVED***4***REMOVED***)***REMOVED***3***REMOVED***-?[A-F0-9]***REMOVED***12***REMOVED***\***REMOVED***$/i;

    return this._test('guid', undefined, function (value, state, options) ***REMOVED***

        if (regex.test(value) || regex2.test(value)) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('string.guid', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.hex = function () ***REMOVED***

    var regex = /^[a-f0-9]+$/i;

    return this._test('hex', regex, function (value, state, options) ***REMOVED***

        if (regex.test(value)) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('string.hex', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.hostname = function () ***REMOVED***

    var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;

    return this._test('hostname', undefined, function (value, state, options) ***REMOVED***

        if ((value.length <= 255 && regex.test(value)) ||
            Net.isIPv6(value)) ***REMOVED***

            return null;
        ***REMOVED***

        return Errors.create('string.hostname', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.String.prototype.lowercase = function () ***REMOVED***

    var obj = this._test('lowercase', undefined, function (value, state, options) ***REMOVED***

        if (options.convert ||
            value === value.toLocaleLowerCase()) ***REMOVED***

            return null;
        ***REMOVED***

        return Errors.create('string.lowercase', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);

    obj._flags.case = 'lower';
    return obj;
***REMOVED***;


internals.String.prototype.uppercase = function () ***REMOVED***

    var obj = this._test('uppercase', undefined, function (value, state, options) ***REMOVED***

        if (options.convert ||
            value === value.toLocaleUpperCase()) ***REMOVED***

            return null;
        ***REMOVED***

        return Errors.create('string.uppercase', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);

    obj._flags.case = 'upper';
    return obj;
***REMOVED***;


internals.String.prototype.trim = function () ***REMOVED***

    var obj = this._test('trim', undefined, function (value, state, options) ***REMOVED***

        if (options.convert ||
            value === value.trim()) ***REMOVED***

            return null;
        ***REMOVED***

        return Errors.create('string.trim', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);

    obj._flags.trim = true;
    return obj;
***REMOVED***;


internals.String.prototype.replace = function (pattern, replacement) ***REMOVED***

    if (typeof pattern === 'string') ***REMOVED***
        pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
    ***REMOVED***

    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
    Hoek.assert(typeof replacement === 'string', 'replacement must be a String');

    // This can not be considere a test like trim, we can't "reject"
    // anything from this rule, so just clone the current object
    var obj = this.clone();

    if (!obj._inner.replacements) ***REMOVED***
        obj._inner.replacements = [];
    ***REMOVED***

    obj._inner.replacements.push(***REMOVED***
        pattern: pattern,
        replacement: replacement
    ***REMOVED***);

    return obj;
***REMOVED***;

module.exports = new internals.String();
