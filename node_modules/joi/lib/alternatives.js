// Load modules

var Hoek = require('hoek');
var Any = require('./any');
var Cast = require('./cast');
var Ref = require('./ref');
var Errors = require('./errors');


// Declare internals

var internals = ***REMOVED******REMOVED***;


internals.Alternatives = function () ***REMOVED***

    Any.call(this);
    this._type = 'alternatives';
    this._invalids.remove(null);

    this._inner.matches = [];
***REMOVED***;

Hoek.inherits(internals.Alternatives, Any);


internals.Alternatives.prototype._base = function (value, state, options) ***REMOVED***

    var errors = [];
    for (var i = 0, il = this._inner.matches.length; i < il; ++i) ***REMOVED***
        var item = this._inner.matches[i];
        var schema = item.schema;
        if (!schema) ***REMOVED***
            var failed = item.is._validate(item.ref(state.parent, options), null, options, state.parent).errors;
            schema = failed ? item.otherwise : item.then;
            if (!schema) ***REMOVED***
                continue;
            ***REMOVED***
        ***REMOVED***

        var result = schema._validate(value, state, options);
        if (!result.errors) ***REMOVED***     // Found a valid match
            return result;
        ***REMOVED***

        errors = errors.concat(result.errors);
    ***REMOVED***

    return ***REMOVED*** errors: errors.length ? errors : Errors.create('alternatives.base', null, state, options) ***REMOVED***;
***REMOVED***;


internals.Alternatives.prototype.try = function (/* schemas */) ***REMOVED***


    var schemas = Hoek.flatten(Array.prototype.slice.call(arguments));
    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');

    var obj = this.clone();

    for (var i = 0, il = schemas.length; i < il; ++i) ***REMOVED***
        var cast = Cast.schema(schemas[i]);
        if (cast._refs.length) ***REMOVED***
            obj._refs = obj._refs.concat(cast._refs);
        ***REMOVED***
        obj._inner.matches.push(***REMOVED*** schema: cast ***REMOVED***);
    ***REMOVED***

    return obj;
***REMOVED***;


internals.Alternatives.prototype.when = function (ref, options) ***REMOVED***

    Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);
    Hoek.assert(options, 'Missing options');
    Hoek.assert(typeof options === 'object', 'Invalid options');
    Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

    var obj = this.clone();
    var is = Cast.schema(options.is);

    if (options.is === null || !options.is.isJoi) ***REMOVED***

        // Only apply required if this wasn't already a schema, we'll suppose people know what they're doing
        is = is.required();
    ***REMOVED***

    var item = ***REMOVED***
        ref: Cast.ref(ref),
        is: is,
        then: options.then !== undefined ? Cast.schema(options.then) : undefined,
        otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined
    ***REMOVED***;

    Ref.push(obj._refs, item.ref);
    obj._refs = obj._refs.concat(item.is._refs);

    if (item.then && item.then._refs) ***REMOVED***
        obj._refs = obj._refs.concat(item.then._refs);
    ***REMOVED***

    if (item.otherwise && item.otherwise._refs) ***REMOVED***
        obj._refs = obj._refs.concat(item.otherwise._refs);
    ***REMOVED***

    obj._inner.matches.push(item);

    return obj;
***REMOVED***;


internals.Alternatives.prototype.describe = function () ***REMOVED***

    var description = Any.prototype.describe.call(this);
    var alternatives = [];
    for (var i = 0, il = this._inner.matches.length; i < il; ++i) ***REMOVED***
        var item = this._inner.matches[i];
        if (item.schema) ***REMOVED***

            // try()

            alternatives.push(item.schema.describe());
        ***REMOVED***
        else ***REMOVED***

            // when()

            var when = ***REMOVED***
                ref: item.ref.toString(),
                is: item.is.describe()
            ***REMOVED***;

            if (item.then) ***REMOVED***
                when.then = item.then.describe();
            ***REMOVED***

            if (item.otherwise) ***REMOVED***
                when.otherwise = item.otherwise.describe();
            ***REMOVED***

            alternatives.push(when);
        ***REMOVED***
    ***REMOVED***

    description.alternatives = alternatives;
    return description;
***REMOVED***;


module.exports = new internals.Alternatives();
