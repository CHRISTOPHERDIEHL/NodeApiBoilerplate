// Load modules

var Any = require('./any');
var Cast = require('./cast');
var Errors = require('./errors');
var Hoek = require('hoek');


// Declare internals

var internals = ***REMOVED******REMOVED***;


internals.fastSplice = function (arr, i) ***REMOVED***

    var il = arr.length;
    var pos = i;

    while (pos < il) ***REMOVED***
        arr[pos++] = arr[pos];
    ***REMOVED***

    --arr.length;
***REMOVED***;


internals.Array = function () ***REMOVED***

    Any.call(this);
    this._type = 'array';
    this._inner.items = [];
    this._inner.ordereds = [];
    this._inner.inclusions = [];
    this._inner.exclusions = [];
    this._inner.requireds = [];
    this._flags.sparse = false;
***REMOVED***;

Hoek.inherits(internals.Array, Any);


internals.Array.prototype._base = function (value, state, options) ***REMOVED***

    var result = ***REMOVED***
        value: value
    ***REMOVED***;

    if (typeof value === 'string' &&
        options.convert) ***REMOVED***

        try ***REMOVED***
            var converted = JSON.parse(value);
            if (Array.isArray(converted)) ***REMOVED***
                result.value = converted;
            ***REMOVED***
        ***REMOVED***
        catch (e) ***REMOVED*** ***REMOVED***
    ***REMOVED***

    var isArray = Array.isArray(result.value);
    var wasArray = isArray;
    if (options.convert && this._flags.single && !isArray) ***REMOVED***
        result.value = [result.value];
        isArray = true;
    ***REMOVED***

    if (!isArray) ***REMOVED***
        result.errors = Errors.create('array.base', null, state, options);
        return result;
    ***REMOVED***

    if (this._inner.inclusions.length ||
        this._inner.exclusions.length ||
        !this._flags.sparse) ***REMOVED***

        // Clone the array so that we don't modify the original
        if (wasArray) ***REMOVED***
            result.value = result.value.slice(0);
        ***REMOVED***

        result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);

        if (result.errors && wasArray && options.convert && this._flags.single) ***REMOVED***

            // Attempt a 2nd pass by putting the array inside one.
            var previousErrors = result.errors;

            result.value = [result.value];
            result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);

            if (result.errors) ***REMOVED***

                // Restore previous errors and value since this didn't validate either.
                result.errors = previousErrors;
                result.value = result.value[0];
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return result;
***REMOVED***;


internals.checkItems = function (items, wasArray, state, options) ***REMOVED***

    var errors = [];
    var errored;

    var requireds = this._inner.requireds.slice();
    var ordereds = this._inner.ordereds.slice();
    var inclusions = this._inner.inclusions.concat(requireds);

    for (var v = 0, vl = items.length; v < vl; ++v) ***REMOVED***
        errored = false;
        var item = items[v];
        var isValid = false;
        var localState = ***REMOVED*** key: v, path: (state.path ? state.path + '.' : '') + v, parent: items, reference: state.reference ***REMOVED***;
        var res;

        // Sparse

        if (!this._flags.sparse && item === undefined) ***REMOVED***
            errors.push(Errors.create('array.sparse', null, ***REMOVED*** key: state.key, path: localState.path ***REMOVED***, options));

            if (options.abortEarly) ***REMOVED***
                return errors;
            ***REMOVED***

            continue;
        ***REMOVED***

        // Exclusions

        for (var i = 0, il = this._inner.exclusions.length; i < il; ++i) ***REMOVED***
            res = this._inner.exclusions[i]._validate(item, localState, ***REMOVED******REMOVED***);                // Not passing options to use defaults

            if (!res.errors) ***REMOVED***
                errors.push(Errors.create(wasArray ? 'array.excludes' : 'array.excludesSingle', ***REMOVED*** pos: v, value: item ***REMOVED***, ***REMOVED*** key: state.key, path: localState.path ***REMOVED***, options));
                errored = true;

                if (options.abortEarly) ***REMOVED***
                    return errors;
                ***REMOVED***

                break;
            ***REMOVED***
        ***REMOVED***

        if (errored) ***REMOVED***
            continue;
        ***REMOVED***

        // Ordered
        if (this._inner.ordereds.length) ***REMOVED***
            if (ordereds.length > 0) ***REMOVED***
                var ordered = ordereds.shift();
                res = ordered._validate(item, localState, options);
                if (!res.errors) ***REMOVED***
                    if (ordered._flags.strip) ***REMOVED***
                        internals.fastSplice(items, v);
                        --v;
                        --vl;
                    ***REMOVED***
                    else ***REMOVED***
                        items[v] = res.value;
                    ***REMOVED***
                ***REMOVED***
                else ***REMOVED***
                    errors.push(Errors.create('array.ordered', ***REMOVED*** pos: v, reason: res.errors, value: item ***REMOVED***, ***REMOVED*** key: state.key, path: localState.path ***REMOVED***, options));
                    if (options.abortEarly) ***REMOVED***
                        return errors;
                    ***REMOVED***
                ***REMOVED***
                continue;
            ***REMOVED***
            else if (!this._inner.items.length) ***REMOVED***
                errors.push(Errors.create('array.orderedLength', ***REMOVED*** pos: v, limit: this._inner.ordereds.length ***REMOVED***, ***REMOVED*** key: state.key, path: localState.path ***REMOVED***, options));
                if (options.abortEarly) ***REMOVED***
                    return errors;
                ***REMOVED***
                continue;
            ***REMOVED***
        ***REMOVED***

        // Requireds

        var requiredChecks = [];
        for (i = 0, il = requireds.length; i < il; ++i) ***REMOVED***
            res = requiredChecks[i] = requireds[i]._validate(item, localState, options);
            if (!res.errors) ***REMOVED***
                items[v] = res.value;
                isValid = true;
                internals.fastSplice(requireds, i);
                --i;
                --il;
                break;
            ***REMOVED***
        ***REMOVED***

        if (isValid) ***REMOVED***
            continue;
        ***REMOVED***

        // Inclusions

        for (i = 0, il = inclusions.length; i < il; ++i) ***REMOVED***
            var inclusion = inclusions[i];

            // Avoid re-running requireds that already didn't match in the previous loop
            var previousCheck = requireds.indexOf(inclusion);
            if (previousCheck !== -1) ***REMOVED***
                res = requiredChecks[previousCheck];
            ***REMOVED***
            else ***REMOVED***
                res = inclusion._validate(item, localState, options);

                if (!res.errors) ***REMOVED***
                    if (inclusion._flags.strip) ***REMOVED***
                        internals.fastSplice(items, v);
                        --v;
                        --vl;
                    ***REMOVED***
                    else ***REMOVED***
                        items[v] = res.value;
                    ***REMOVED***
                    isValid = true;
                    break;
                ***REMOVED***
            ***REMOVED***

            // Return the actual error if only one inclusion defined
            if (il === 1) ***REMOVED***
                if (options.stripUnknown) ***REMOVED***
                    internals.fastSplice(items, v);
                    --v;
                    --vl;
                    isValid = true;
                    break;
                ***REMOVED***

                errors.push(Errors.create(wasArray ? 'array.includesOne' : 'array.includesOneSingle', ***REMOVED*** pos: v, reason: res.errors, value: item ***REMOVED***, ***REMOVED*** key: state.key, path: localState.path ***REMOVED***, options));
                errored = true;

                if (options.abortEarly) ***REMOVED***
                    return errors;
                ***REMOVED***

                break;
            ***REMOVED***
        ***REMOVED***

        if (errored) ***REMOVED***
            continue;
        ***REMOVED***

        if (this._inner.inclusions.length && !isValid) ***REMOVED***
            if (options.stripUnknown) ***REMOVED***
                internals.fastSplice(items, v);
                --v;
                --vl;
                continue;
            ***REMOVED***

            errors.push(Errors.create(wasArray ? 'array.includes' : 'array.includesSingle', ***REMOVED*** pos: v, value: item ***REMOVED***, ***REMOVED*** key: state.key, path: localState.path ***REMOVED***, options));

            if (options.abortEarly) ***REMOVED***
                return errors;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    if (requireds.length) ***REMOVED***
        internals.fillMissedErrors(errors, requireds, state, options);
    ***REMOVED***

    if (ordereds.length) ***REMOVED***
        internals.fillOrderedErrors(errors, ordereds, state, options);
    ***REMOVED***

    return errors.length ? errors : null;
***REMOVED***;

internals.fillMissedErrors = function (errors, requireds, state, options) ***REMOVED***

    var knownMisses = [];
    var unknownMisses = 0;
    for (var i = 0, il = requireds.length; i < il; ++i) ***REMOVED***
        var label = Hoek.reach(requireds[i], '_settings.language.label');
        if (label) ***REMOVED***
            knownMisses.push(label);
        ***REMOVED***
        else ***REMOVED***
            ++unknownMisses;
        ***REMOVED***
    ***REMOVED***

    if (knownMisses.length) ***REMOVED***
        if (unknownMisses) ***REMOVED***
            errors.push(Errors.create('array.includesRequiredBoth', ***REMOVED*** knownMisses: knownMisses, unknownMisses: unknownMisses ***REMOVED***, ***REMOVED*** key: state.key, path: state.patk ***REMOVED***, options));
        ***REMOVED***
        else ***REMOVED***
            errors.push(Errors.create('array.includesRequiredKnowns', ***REMOVED*** knownMisses: knownMisses ***REMOVED***, ***REMOVED*** key: state.key, path: state.path ***REMOVED***, options));
        ***REMOVED***
    ***REMOVED***
    else ***REMOVED***
        errors.push(Errors.create('array.includesRequiredUnknowns', ***REMOVED*** unknownMisses: unknownMisses ***REMOVED***, ***REMOVED*** key: state.key, path: state.path ***REMOVED***, options));
    ***REMOVED***
***REMOVED***;

internals.fillOrderedErrors = function (errors, ordereds, state, options) ***REMOVED***

    var requiredOrdereds = [];

    for (var i = 0, il = ordereds.length; i < il; ++i) ***REMOVED***
        var presence = Hoek.reach(ordereds[i], '_flags.presence');
        if (presence === 'required') ***REMOVED***
            requiredOrdereds.push(ordereds[i]);
        ***REMOVED***
    ***REMOVED***

    if (requiredOrdereds.length) ***REMOVED***
        internals.fillMissedErrors(errors, requiredOrdereds, state, options);
    ***REMOVED***
***REMOVED***;

internals.Array.prototype.describe = function () ***REMOVED***

    var description = Any.prototype.describe.call(this);

    if (this._inner.ordereds.length) ***REMOVED***
        description.orderedItems = [];

        for (var o = 0, ol = this._inner.ordereds.length; o < ol; ++o) ***REMOVED***
            description.orderedItems.push(this._inner.ordereds[o].describe());
        ***REMOVED***
    ***REMOVED***

    if (this._inner.items.length) ***REMOVED***
        description.items = [];

        for (var i = 0, il = this._inner.items.length; i < il; ++i) ***REMOVED***
            description.items.push(this._inner.items[i].describe());
        ***REMOVED***
    ***REMOVED***

    return description;
***REMOVED***;


internals.Array.prototype.items = function () ***REMOVED***

    var obj = this.clone();

    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) ***REMOVED***

        try ***REMOVED***
            type = Cast.schema(type);
        ***REMOVED***
        catch (castErr) ***REMOVED***
            if (castErr.hasOwnProperty('path')) ***REMOVED***
                castErr.path = index + '.' + castErr.path;
            ***REMOVED***
            else ***REMOVED***
                castErr.path = index;
            ***REMOVED***
            castErr.message += '(' + castErr.path + ')';
            throw castErr;
        ***REMOVED***

        obj._inner.items.push(type);

        if (type._flags.presence === 'required') ***REMOVED***
            obj._inner.requireds.push(type);
        ***REMOVED***
        else if (type._flags.presence === 'forbidden') ***REMOVED***
            obj._inner.exclusions.push(type.optional());
        ***REMOVED***
        else ***REMOVED***
            obj._inner.inclusions.push(type);
        ***REMOVED***
    ***REMOVED***);

    return obj;
***REMOVED***;


internals.Array.prototype.ordered = function () ***REMOVED***

    var obj = this.clone();

    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) ***REMOVED***

        try ***REMOVED***
            type = Cast.schema(type);
        ***REMOVED***
        catch (castErr) ***REMOVED***
            if (castErr.hasOwnProperty('path')) ***REMOVED***
                castErr.path = index + '.' + castErr.path;
            ***REMOVED***
            else ***REMOVED***
                castErr.path = index;
            ***REMOVED***
            castErr.message += '(' + castErr.path + ')';
            throw castErr;
        ***REMOVED***
        obj._inner.ordereds.push(type);
    ***REMOVED***);

    return obj;
***REMOVED***;


internals.Array.prototype.min = function (limit) ***REMOVED***

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('min', limit, function (value, state, options) ***REMOVED***

        if (value.length >= limit) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('array.min', ***REMOVED*** limit: limit, value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Array.prototype.max = function (limit) ***REMOVED***

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('max', limit, function (value, state, options) ***REMOVED***

        if (value.length <= limit) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('array.max', ***REMOVED*** limit: limit, value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Array.prototype.length = function (limit) ***REMOVED***

    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');

    return this._test('length', limit, function (value, state, options) ***REMOVED***

        if (value.length === limit) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('array.length', ***REMOVED*** limit: limit, value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Array.prototype.unique = function () ***REMOVED***

    return this._test('unique', undefined, function (value, state, options) ***REMOVED***

        var found = ***REMOVED***
            string: ***REMOVED******REMOVED***,
            number: ***REMOVED******REMOVED***,
            undefined: ***REMOVED******REMOVED***,
            boolean: ***REMOVED******REMOVED***,
            object: [],
            function: []
        ***REMOVED***;

        for (var i = 0, il = value.length; i < il; ++i) ***REMOVED***
            var item = value[i];
            var type = typeof item;
            var records = found[type];

            // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
            // I still want to keep the test for future js versions with new types (eg. Symbol).
            if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) ***REMOVED***
                if (Array.isArray(records)) ***REMOVED***
                    for (var r = 0, rl = records.length; r < rl; ++r) ***REMOVED***
                        if (Hoek.deepEqual(records[r], item)) ***REMOVED***
                            return Errors.create('array.unique', ***REMOVED*** pos: i, value: item ***REMOVED***, state, options);
                        ***REMOVED***
                    ***REMOVED***

                    records.push(item);
                ***REMOVED***
                else ***REMOVED***
                    if (records[item]) ***REMOVED***
                        return Errors.create('array.unique', ***REMOVED*** pos: i, value: item ***REMOVED***, state, options);
                    ***REMOVED***

                    records[item] = true;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***);
***REMOVED***;


internals.Array.prototype.sparse = function (enabled) ***REMOVED***

    var obj = this.clone();
    obj._flags.sparse = enabled === undefined ? true : !!enabled;
    return obj;
***REMOVED***;


internals.Array.prototype.single = function (enabled) ***REMOVED***

    var obj = this.clone();
    obj._flags.single = enabled === undefined ? true : !!enabled;
    return obj;
***REMOVED***;


module.exports = new internals.Array();
