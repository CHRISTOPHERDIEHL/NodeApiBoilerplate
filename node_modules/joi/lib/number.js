// Load modules

var Any = require('./any');
var Ref = require('./ref');
var Errors = require('./errors');
var Hoek = require('hoek');


// Declare internals

var internals = ***REMOVED******REMOVED***;


internals.Number = function () ***REMOVED***

    Any.call(this);
    this._type = 'number';
    this._invalids.add(Infinity);
    this._invalids.add(-Infinity);
***REMOVED***;

Hoek.inherits(internals.Number, Any);

internals.compare = function (type, compare) ***REMOVED***

    return function (limit) ***REMOVED***

        var isRef = Ref.isRef(limit);
        var isNumber = typeof limit === 'number' && !isNaN(limit);

        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');

        return this._test(type, limit, function (value, state, options) ***REMOVED***

            var compareTo;
            if (isRef) ***REMOVED***
                compareTo = limit(state.parent, options);

                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) ***REMOVED***
                    return Errors.create('number.ref', ***REMOVED*** ref: limit.key ***REMOVED***, state, options);
                ***REMOVED***
            ***REMOVED***
            else ***REMOVED***
                compareTo = limit;
            ***REMOVED***

            if (compare(value, compareTo)) ***REMOVED***
                return null;
            ***REMOVED***

            return Errors.create('number.' + type, ***REMOVED*** limit: compareTo, value: value ***REMOVED***, state, options);
        ***REMOVED***);
    ***REMOVED***;
***REMOVED***;


internals.Number.prototype._base = function (value, state, options) ***REMOVED***

    var result = ***REMOVED***
        errors: null,
        value: value
    ***REMOVED***;

    if (typeof value === 'string' &&
        options.convert) ***REMOVED***

        var number = parseFloat(value);
        result.value = (isNaN(number) || !isFinite(value)) ? NaN : number;
    ***REMOVED***

    var isNumber = typeof result.value === 'number' && !isNaN(result.value);

    if (options.convert && 'precision' in this._flags && isNumber) ***REMOVED***

        // This is conceptually equivalent to using toFixed but it should be much faster
        var precision = Math.pow(10, this._flags.precision);
        result.value = Math.round(result.value * precision) / precision;
    ***REMOVED***

    result.errors = isNumber ? null : Errors.create('number.base', null, state, options);
    return result;
***REMOVED***;


internals.Number.prototype.min = internals.compare('min', function (value, limit) ***REMOVED***

    return value >= limit;
***REMOVED***);


internals.Number.prototype.max = internals.compare('max', function (value, limit) ***REMOVED***

    return value <= limit;
***REMOVED***);


internals.Number.prototype.greater = internals.compare('greater', function (value, limit) ***REMOVED***

    return value > limit;
***REMOVED***);


internals.Number.prototype.less = internals.compare('less', function (value, limit) ***REMOVED***

    return value < limit;
***REMOVED***);


internals.Number.prototype.multiple = function (base) ***REMOVED***

    Hoek.assert(Hoek.isInteger(base), 'multiple must be an integer');
    Hoek.assert(base > 0, 'multiple must be greater than 0');

    return this._test('multiple', base, function (value, state, options) ***REMOVED***

        if (value % base === 0) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('number.multiple', ***REMOVED*** multiple: base, value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Number.prototype.integer = function () ***REMOVED***

    return this._test('integer', undefined, function (value, state, options) ***REMOVED***

        return Hoek.isInteger(value) ? null : Errors.create('number.integer', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Number.prototype.negative = function () ***REMOVED***

    return this._test('negative', undefined, function (value, state, options) ***REMOVED***

        if (value < 0) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('number.negative', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.Number.prototype.positive = function () ***REMOVED***

    return this._test('positive', undefined, function (value, state, options) ***REMOVED***

        if (value > 0) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('number.positive', ***REMOVED*** value: value ***REMOVED***, state, options);
    ***REMOVED***);
***REMOVED***;


internals.precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/;


internals.Number.prototype.precision = function (limit) ***REMOVED***

    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');
    Hoek.assert(!('precision' in this._flags), 'precision already set');

    var obj = this._test('precision', limit, function (value, state, options)***REMOVED***

        var places = value.toString().match(internals.precisionRx);
        var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
        if (decimals <= limit) ***REMOVED***
            return null;
        ***REMOVED***

        return Errors.create('number.precision', ***REMOVED*** limit: limit, value: value ***REMOVED***, state, options);
    ***REMOVED***);

    obj._flags.precision = limit;
    return obj;
***REMOVED***;


module.exports = new internals.Number();
