// Load modules

var Hoek = require('hoek');
var Language = require('./language');


// Declare internals

var internals = ***REMOVED******REMOVED***;

internals.stringify = function (value, wrapArrays) ***REMOVED***

    var type = typeof value;

    if (value === null) ***REMOVED***
        return 'null';
    ***REMOVED***

    if (type === 'string') ***REMOVED***
        return value;
    ***REMOVED***

    if (value instanceof internals.Err || type === 'function') ***REMOVED***
        return value.toString();
    ***REMOVED***

    if (type === 'object') ***REMOVED***
        if (Array.isArray(value)) ***REMOVED***
            var partial = '';

            for (var i = 0, il = value.length; i < il; ++i) ***REMOVED***
                partial += (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);
            ***REMOVED***

            return wrapArrays ? '[' + partial + ']' : partial;
        ***REMOVED***

        return value.toString();
    ***REMOVED***

    return JSON.stringify(value);
***REMOVED***;

internals.Err = function (type, context, state, options) ***REMOVED***

    this.type = type;
    this.context = context || ***REMOVED******REMOVED***;
    this.context.key = state.key;
    this.path = state.path;
    this.options = options;
***REMOVED***;


internals.Err.prototype.toString = function () ***REMOVED***

    var self = this;

    var localized = this.options.language;

    if (localized.label) ***REMOVED***
        this.context.key = localized.label;
    ***REMOVED***
    else if (this.context.key === '' || this.context.key === null) ***REMOVED***
        this.context.key = localized.root || Language.errors.root;
    ***REMOVED***

    var format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);
    var hasKey = /\***REMOVED***\***REMOVED***\!?key\***REMOVED***\***REMOVED***/.test(format);
    var skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';

    if (skipKey) ***REMOVED***
        format = format.slice(2);
    ***REMOVED***

    if (!hasKey && !skipKey) ***REMOVED***
        format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;
    ***REMOVED***

    var wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');
    if (typeof wrapArrays !== 'boolean') ***REMOVED***
        wrapArrays = Language.errors.messages.wrapArrays;
    ***REMOVED***

    var message = format.replace(/\***REMOVED***\***REMOVED***(\!?)([^***REMOVED***]+)\***REMOVED***\***REMOVED***/g, function ($0, isSecure, name) ***REMOVED***

        var value = Hoek.reach(self.context, name);
        var normalized = internals.stringify(value, wrapArrays);
        return (isSecure ? Hoek.escapeHtml(normalized) : normalized);
    ***REMOVED***);

    return message;
***REMOVED***;


exports.create = function (type, context, state, options) ***REMOVED***

    return new internals.Err(type, context, state, options);
***REMOVED***;


exports.process = function (errors, object) ***REMOVED***

    if (!errors || !errors.length) ***REMOVED***
        return null;
    ***REMOVED***

    // Construct error

    var message = '';
    var details = [];

    var processErrors = function (localErrors, parent) ***REMOVED***

        for (var i = 0, il = localErrors.length; i < il; ++i) ***REMOVED***
            var item = localErrors[i];

            var detail = ***REMOVED***
                message: item.toString(),
                path: internals.getPath(item),
                type: item.type,
                context: item.context
            ***REMOVED***;

            if (!parent) ***REMOVED***
                message += (message ? '. ' : '') + detail.message;
            ***REMOVED***

            // Do not push intermediate errors, we're only interested in leafs
            if (item.context.reason && item.context.reason.length) ***REMOVED***
                processErrors(item.context.reason, item.path);
            ***REMOVED***
            else ***REMOVED***
                details.push(detail);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;

    processErrors(errors);

    var error = new Error(message);
    error.name = 'ValidationError';
    error.details = details;
    error._object = object;
    error.annotate = internals.annotate;
    return error;
***REMOVED***;


internals.getPath = function (item) ***REMOVED***

    var recursePath = function (it) ***REMOVED***

        var reachedItem = Hoek.reach(it, 'context.reason.0');
        if (reachedItem && reachedItem.context) ***REMOVED***
            return recursePath(reachedItem);
        ***REMOVED***

        return it.path;
    ***REMOVED***;

    return recursePath(item) || item.context.key;
***REMOVED***;


// Inspired by json-stringify-safe
internals.safeStringify = function (obj, spaces) ***REMOVED***

    return JSON.stringify(obj, internals.serializer(), spaces);
***REMOVED***;

internals.serializer = function () ***REMOVED***

    var cycleReplacer = function (key, value) ***REMOVED***

        if (stack[0] === value) ***REMOVED***
            return '[Circular ~]';
        ***REMOVED***

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    ***REMOVED***;

    var keys = [], stack = [];

    return function (key, value) ***REMOVED***

        if (stack.length > 0) ***REMOVED***
            var thisPos = stack.indexOf(this);
            if (~thisPos) ***REMOVED***
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            ***REMOVED***
            else ***REMOVED***
                stack.push(this);
                keys.push(key);
            ***REMOVED***

            if (~stack.indexOf(value)) ***REMOVED***
                value = cycleReplacer.call(this, key, value);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            stack.push(value);
        ***REMOVED***

        if (Array.isArray(value) && value.placeholders) ***REMOVED***
            var placeholders = value.placeholders;
            var arrWithPlaceholders = [];
            for (var i = 0, il = value.length; i < il; ++i) ***REMOVED***
                if (placeholders[i]) ***REMOVED***
                    arrWithPlaceholders.push(placeholders[i]);
                ***REMOVED***
                arrWithPlaceholders.push(value[i]);
            ***REMOVED***

            value = arrWithPlaceholders;
        ***REMOVED***

        return value;
    ***REMOVED***;
***REMOVED***;


internals.annotate = function () ***REMOVED***

    var obj = Hoek.clone(this._object || ***REMOVED******REMOVED***);

    var lookup = ***REMOVED******REMOVED***;
    var el = this.details.length;
    for (var e = el - 1; e >= 0; --e) ***REMOVED***        // Reverse order to process deepest child first
        var pos = el - e;
        var error = this.details[e];
        var path = error.path.split('.');
        var ref = obj;
        for (var i = 0, il = path.length; i < il && ref; ++i) ***REMOVED***
            var seg = path[i];
            if (i + 1 < il) ***REMOVED***
                ref = ref[seg];
            ***REMOVED***
            else ***REMOVED***
                var value = ref[seg];
                if (Array.isArray(ref)) ***REMOVED***
                    var arrayLabel = '_$idx$_' + (e + 1) + '_$end$_';
                    if (!ref.placeholders) ***REMOVED***
                        ref.placeholders = ***REMOVED******REMOVED***;
                    ***REMOVED***

                    if (ref.placeholders[seg]) ***REMOVED***
                        ref.placeholders[seg] = ref.placeholders[seg].replace('_$end$_', ', ' + (e + 1) + '_$end$_');
                    ***REMOVED***
                    else ***REMOVED***
                        ref.placeholders[seg] = arrayLabel;
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    if (value !== undefined) ***REMOVED***
                        delete ref[seg];
                        var objectLabel = seg + '_$key$_' + pos + '_$end$_';
                        ref[objectLabel] = value;
                        lookup[error.path] = objectLabel;
                    ***REMOVED***
                    else if (lookup[error.path]) ***REMOVED***
                        var replacement = lookup[error.path];
                        var appended = replacement.replace('_$end$_', ', ' + pos + '_$end$_');
                        ref[appended] = ref[replacement];
                        lookup[error.path] = appended;
                        delete ref[replacement];
                    ***REMOVED***
                    else ***REMOVED***
                        ref['_$miss$_' + seg + '|' + pos + '_$end$_'] = '__missing__';
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    var message = internals.safeStringify(obj, 2)
        .replace(/_\$key\$_([, \d]+)_\$end\$_\"/g, function ($0, $1) ***REMOVED***

            return '" \u001b[31m[' + $1 + ']\u001b[0m';
        ***REMOVED***).replace(/\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g, function ($0, $1, $2) ***REMOVED***

            return '\u001b[41m"' + $1 + '"\u001b[0m\u001b[31m [' + $2 + ']: -- missing --\u001b[0m';
        ***REMOVED***).replace(/\s*\"_\$idx\$_([, \d]+)_\$end\$_\",?\n(.*)/g, function ($0, $1, $2) ***REMOVED***

            return '\n' + $2 + ' \u001b[31m[' + $1 + ']\u001b[0m';
        ***REMOVED***);

    message += '\n\u001b[31m';

    for (e = 0; e < el; ++e) ***REMOVED***
        message += '\n[' + (e + 1) + '] ' + this.details[e].message;
    ***REMOVED***

    message += '\u001b[0m';

    return message;
***REMOVED***;
