// Load modules

var Lab = require('lab');
var Code = require('code');
var Joi = require('../lib');


// Declare internals

var internals = ***REMOVED******REMOVED***;


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.describe;
var it = lab.it;
var expect = Code.expect;


describe('errors', function () ***REMOVED***

    it('supports custom errors when validating types', function (done) ***REMOVED***

        var schema = Joi.object(***REMOVED***
            email: Joi.string().email(),
            date: Joi.date(),
            alphanum: Joi.string().alphanum(),
            min: Joi.string().min(3),
            max: Joi.string().max(3),
            required: Joi.string().required(),
            xor: Joi.string(),
            renamed: Joi.string().valid('456'),
            notEmpty: Joi.string().required()
        ***REMOVED***).rename('renamed', 'required').without('required', 'xor').without('xor', 'required');

        var input = ***REMOVED***
            email: 'invalid-email',
            date: 'invalid-date',
            alphanum: '\b\n\f\r\t',
            min: 'ab',
            max: 'abcd',
            required: 'hello',
            xor: '123',
            renamed: '456',
            notEmpty: ''
        ***REMOVED***;

        var lang = ***REMOVED***
            any: ***REMOVED***
                empty: '3'
            ***REMOVED***,
            date: ***REMOVED***
                base: '18'
            ***REMOVED***,
            string: ***REMOVED***
                base: '13',
                min: '14',
                max: '15',
                alphanum: '16',
                email: '19'
            ***REMOVED***,
            object: ***REMOVED***
                without: '7',
                rename: ***REMOVED***
                    override: '11'
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        Joi.validate(input, schema, ***REMOVED*** abortEarly: false, language: lang ***REMOVED***, function (err, value) ***REMOVED***

            expect(err).to.exist();
            expect(err.name).to.equal('ValidationError');
            expect(err.message).to.equal('"value" 11. child "email" fails because ["email" 19]. child "date" fails because ["date" 18]. child "alphanum" fails because ["alphanum" 16]. child "min" fails because ["min" 14]. child "max" fails because ["max" 15]. child "notEmpty" fails because ["notEmpty" 3]. "required" 7. "xor" 7');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('does not prefix with key when language uses context.key', function (done) ***REMOVED***

        Joi.valid('sad').options(***REMOVED*** language: ***REMOVED*** any: ***REMOVED*** allowOnly: 'my hero "***REMOVED******REMOVED***key***REMOVED******REMOVED***" is not ***REMOVED******REMOVED***valids***REMOVED******REMOVED***' ***REMOVED*** ***REMOVED*** ***REMOVED***).validate(5, function (err, value) ***REMOVED***

            expect(err.message).to.equal('my hero "value" is not [sad]');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('escapes unsafe keys', function (done) ***REMOVED***

        var schema = ***REMOVED***
            'a()': Joi.number()
        ***REMOVED***;

        Joi.validate(***REMOVED*** 'a()': 'x' ***REMOVED***, schema, function (err, value) ***REMOVED***

            expect(err.message).to.equal('child "a&#x28;&#x29;" fails because ["a&#x28;&#x29;" must be a number]');

            Joi.validate(***REMOVED*** 'b()': 'x' ***REMOVED***, schema, function (err2, value2) ***REMOVED***

                expect(err2.message).to.equal('"b&#x28;&#x29;" is not allowed');
                done();
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***);

    it('returns error type in validation error', function (done) ***REMOVED***

        var input = ***REMOVED***
            notNumber: '',
            notString: true,
            notBoolean: 9
        ***REMOVED***;

        var schema = ***REMOVED***
            notNumber: Joi.number().required(),
            notString: Joi.string().required(),
            notBoolean: Joi.boolean().required()
        ***REMOVED***;

        Joi.validate(input, schema, ***REMOVED*** abortEarly: false ***REMOVED***, function (err, value) ***REMOVED***

            expect(err).to.exist();
            expect(err.details).to.have.length(3);
            expect(err.details[0].type).to.equal('number.base');
            expect(err.details[1].type).to.equal('string.base');
            expect(err.details[2].type).to.equal('boolean.base');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('returns a full path to an error value on an array (items)', function (done) ***REMOVED***

        var schema = Joi.array().items(Joi.array().items(***REMOVED*** x: Joi.number() ***REMOVED***));
        var input = [
            [***REMOVED*** x: 1 ***REMOVED***],
            [***REMOVED*** x: 1 ***REMOVED***, ***REMOVED*** x: 'a' ***REMOVED***]
        ];

        schema.validate(input, function (err, value) ***REMOVED***

            expect(err).to.exist();
            expect(err.details[0].path).to.equal('1.1.x');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('returns a full path to an error value on an array (items forbidden)', function (done) ***REMOVED***

        var schema = Joi.array().items(Joi.array().items(Joi.object(***REMOVED*** x: Joi.string() ***REMOVED***).forbidden()));
        var input = [
            [***REMOVED*** x: 1 ***REMOVED***],
            [***REMOVED*** x: 1 ***REMOVED***, ***REMOVED*** x: 'a' ***REMOVED***]
        ];

        schema.validate(input, function (err, value) ***REMOVED***

            expect(err).to.exist();
            expect(err.details[0].path).to.equal('1.1');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('returns a full path to an error value on an object', function (done) ***REMOVED***

        var schema = ***REMOVED***
            x: Joi.array().items(***REMOVED*** x: Joi.number() ***REMOVED***)
        ***REMOVED***;

        var input = ***REMOVED***
            x: [***REMOVED*** x: 1 ***REMOVED***, ***REMOVED*** x: 'a' ***REMOVED***]
        ***REMOVED***;

        Joi.validate(input, schema, function (err, value) ***REMOVED***

            expect(err).to.exist();
            expect(err.details[0].path).to.equal('x.1.x');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('overrides root key language', function (done) ***REMOVED***

        Joi.string().options(***REMOVED*** language: ***REMOVED*** root: 'blah' ***REMOVED*** ***REMOVED***).validate(4, function (err, value) ***REMOVED***

            expect(err.message).to.equal('"blah" must be a string');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('overrides label key language', function (done) ***REMOVED***

        Joi.string().options(***REMOVED*** language: ***REMOVED*** key: 'my own ***REMOVED******REMOVED***!key***REMOVED******REMOVED*** ' ***REMOVED*** ***REMOVED***).validate(4, function (err, value) ***REMOVED***

            expect(err.message).to.equal('my own value must be a string');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('overrides wrapArrays', function (done) ***REMOVED***

        Joi.array().items(Joi.boolean()).options(***REMOVED*** language: ***REMOVED*** messages: ***REMOVED*** wrapArrays: false ***REMOVED*** ***REMOVED*** ***REMOVED***).validate([4], function (err, value) ***REMOVED***

            expect(err.message).to.equal('"value" at position 0 fails because "0" must be a boolean');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('allows html escaping', function (done) ***REMOVED***

        Joi.string().options(***REMOVED*** language: ***REMOVED*** root: 'blah', label: 'bleh' ***REMOVED*** ***REMOVED***).validate(4, function (err, value) ***REMOVED***

            expect(err.message).to.equal('"bleh" must be a string');
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('provides context with the error', function (done) ***REMOVED***

        Joi.object(***REMOVED*** length: Joi.number().min(3).required() ***REMOVED***).validate(***REMOVED*** length: 1 ***REMOVED***, function (err) ***REMOVED***

            expect(err.details).to.deep.equal([***REMOVED***
                message: '"length" must be larger than or equal to 3',
                path: 'length',
                type: 'number.min',
                context: ***REMOVED***
                    limit: 3,
                    key: 'length',
                    value: 1
                ***REMOVED***
            ***REMOVED***]);
            done();
        ***REMOVED***);
    ***REMOVED***);

    it('has a name that is ValidationError', function (done) ***REMOVED***

        var schema = Joi.number();
        schema.validate('a', function (validateErr) ***REMOVED***

            expect(validateErr).to.exist();
            expect(validateErr.name).to.be.equal('ValidationError');

            try ***REMOVED***
                Joi.assert('a', schema);
                throw new Error('should not reach that');
            ***REMOVED***
            catch (assertErr) ***REMOVED***
                expect(assertErr.name).to.be.equal('ValidationError');
            ***REMOVED***

            try ***REMOVED***
                Joi.assert('a', schema, 'foo');
                throw new Error('should not reach that');
            ***REMOVED***
            catch (assertErr) ***REMOVED***
                expect(assertErr.name).to.be.equal('ValidationError');
            ***REMOVED***

            try ***REMOVED***
                Joi.assert('a', schema, new Error('foo'));
                throw new Error('should not reach that');
            ***REMOVED***
            catch (assertErr) ***REMOVED***
                expect(assertErr.name).to.equal('Error');
                done();
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***);

    describe('#annotate', function () ***REMOVED***

        it('annotates error', function (done) ***REMOVED***

            var object = ***REMOVED***
                a: 'm',
                y: ***REMOVED***
                    b: ***REMOVED***
                        c: 10
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;

            var schema = ***REMOVED***
                a: Joi.string().valid('a', 'b', 'c', 'd'),
                y: Joi.object(***REMOVED***
                    u: Joi.string().valid(['e', 'f', 'g', 'h']).required(),
                    b: Joi.string().valid('i', 'j').allow(false),
                    d: Joi.object(***REMOVED***
                        x: Joi.string().valid('k', 'l').required(),
                        c: Joi.number()
                    ***REMOVED***)
                ***REMOVED***)
            ***REMOVED***;

            Joi.validate(object, schema, ***REMOVED*** abortEarly: false ***REMOVED***, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"y\": ***REMOVED***\n    \"b\" \u001b[31m[1]\u001b[0m: ***REMOVED***\n      \"c\": 10\n    ***REMOVED***,\n    \u001b[41m\"u\"\u001b[0m\u001b[31m [2]: -- missing --\u001b[0m\n  ***REMOVED***,\n  "a" \u001b[31m[3]\u001b[0m: \"m\"\n***REMOVED***\n\u001b[31m\n[1] "a" must be one of [a, b, c, d]\n[2] "u" is required\n[3] "b" must be a string\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('annotates error within array', function (done) ***REMOVED***

            var object = ***REMOVED***
                a: [1, 2, 3, 4, 2, 5]
            ***REMOVED***;

            var schema = ***REMOVED***
                a: Joi.array().items(Joi.valid(1, 2))
            ***REMOVED***;

            Joi.validate(object, schema, ***REMOVED*** abortEarly: false ***REMOVED***, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"a\": [\n    1,\n    2,\n    3, \u001b[31m[1]\u001b[0m\n    4, \u001b[31m[2]\u001b[0m\n    2,\n    5 \u001b[31m[3]\u001b[0m\n  ]\n***REMOVED***\n\u001b[31m\n[1] \"2\" must be one of [1, 2]\n[2] \"3\" must be one of [1, 2]\n[3] \"5\" must be one of [1, 2]\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('annotates error within array multiple times on the same element', function (done) ***REMOVED***

            var object = ***REMOVED***
                a: [2, 3, 4]
            ***REMOVED***;

            var schema = ***REMOVED***
                a: Joi.array().items(Joi.number().min(4).max(2))
            ***REMOVED***;

            Joi.validate(object, schema, ***REMOVED*** abortEarly: false ***REMOVED***, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"a\": [\n    2, \u001b[31m[1]\u001b[0m\n    3, \u001b[31m[3, 2]\u001b[0m\n    4 \u001b[31m[4]\u001b[0m\n  ]\n***REMOVED***\n\u001b[31m\n[1] \"0\" must be larger than or equal to 4\n[2] \"1\" must be larger than or equal to 4\n[3] \"1\" must be less than or equal to 2\n[4] \"2\" must be less than or equal to 2\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('annotates error within array when it is an object', function (done) ***REMOVED***

            var object = ***REMOVED***
                a: [***REMOVED*** b: 2 ***REMOVED***]
            ***REMOVED***;

            var schema = ***REMOVED***
                a: Joi.array().items(Joi.number())
            ***REMOVED***;

            Joi.validate(object, schema, ***REMOVED*** abortEarly: false ***REMOVED***, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"a\": [\n    ***REMOVED*** \u001b[31m[1]\u001b[0m\n      \"b\": 2\n    ***REMOVED***\n  ]\n***REMOVED***\n\u001b[31m\n[1] \"0\" must be a number\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('annotates error within multiple arrays and multiple times on the same element', function (done) ***REMOVED***

            var object = ***REMOVED***
                a: [2, 3, 4],
                b: [2, 3, 4]
            ***REMOVED***;

            var schema = ***REMOVED***
                a: Joi.array().items(Joi.number().min(4).max(2)),
                b: Joi.array().items(Joi.number().min(4).max(2))
            ***REMOVED***;

            Joi.validate(object, schema, ***REMOVED*** abortEarly: false ***REMOVED***, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"a\": [\n    2, \u001b[31m[1]\u001b[0m\n    3, \u001b[31m[3, 2]\u001b[0m\n    4 \u001b[31m[4]\u001b[0m\n  ],\n  \"b\": [\n    2, \u001b[31m[5]\u001b[0m\n    3, \u001b[31m[7, 6]\u001b[0m\n    4 \u001b[31m[8]\u001b[0m\n  ]\n***REMOVED***\n\u001b[31m\n[1] \"0\" must be larger than or equal to 4\n[2] \"1\" must be larger than or equal to 4\n[3] \"1\" must be less than or equal to 2\n[4] \"2\" must be less than or equal to 2\n[5] \"0\" must be larger than or equal to 4\n[6] \"1\" must be larger than or equal to 4\n[7] \"1\" must be less than or equal to 2\n[8] \"2\" must be less than or equal to 2\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('displays alternatives fail as a single line', function (done) ***REMOVED***

            var schema = ***REMOVED***
                x: [
                    Joi.string(),
                    Joi.number(),
                    Joi.date()
                ]
            ***REMOVED***;

            Joi.validate(***REMOVED*** x: true ***REMOVED***, schema, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"x\" \u001b[31m[1, 2, 3]\u001b[0m: true\n***REMOVED***\n\u001b[31m\n[1] "x" must be a string\n[2] "x" must be a number\n[3] "x" must be a number of milliseconds or valid date string\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('annotates circular input', function (done) ***REMOVED***

            var schema = ***REMOVED***
                x: Joi.object(***REMOVED***
                    y: Joi.object(***REMOVED***
                        z: Joi.number()
                    ***REMOVED***)
                ***REMOVED***)
            ***REMOVED***;

            var input = ***REMOVED******REMOVED***;
            input.x = input;

            Joi.validate(input, schema, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"x\" \u001b[31m[1]\u001b[0m: \"[Circular ~]\"\n***REMOVED***\n\u001b[31m\n[1] \"x\" is not allowed\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('annotates deep circular input', function (done) ***REMOVED***

            var schema = ***REMOVED***
                x: Joi.object(***REMOVED***
                    y: Joi.object(***REMOVED***
                        z: Joi.number()
                    ***REMOVED***)
                ***REMOVED***)
            ***REMOVED***;

            var input = ***REMOVED*** x: ***REMOVED*** y: ***REMOVED******REMOVED*** ***REMOVED*** ***REMOVED***;
            input.x.y.z = input.x.y;

            Joi.validate(input, schema, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"x\": ***REMOVED***\n    \"y\": ***REMOVED***\n      \"z\" \u001b[31m[1]\u001b[0m: \"[Circular ~.x.y]\"\n    ***REMOVED***\n  ***REMOVED***\n***REMOVED***\n\u001b[31m\n[1] \"z\" must be a number\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);

        it('annotates deep circular input with extra keys', function (done) ***REMOVED***

            var schema = ***REMOVED***
                x: Joi.object(***REMOVED***
                    y: Joi.object(***REMOVED***
                        z: Joi.number()
                    ***REMOVED***)
                ***REMOVED***)
            ***REMOVED***;

            var input = ***REMOVED*** x: ***REMOVED*** y: ***REMOVED*** z: 1, foo: ***REMOVED******REMOVED*** ***REMOVED*** ***REMOVED*** ***REMOVED***;
            input.x.y.foo = input.x.y;

            Joi.validate(input, schema, function (err, value) ***REMOVED***

                expect(err).to.exist();
                expect(err.annotate()).to.equal('***REMOVED***\n  \"x\": ***REMOVED***\n    \"y\": ***REMOVED***\n      \"z\": 1,\n      \"foo\" \u001b[31m[1]\u001b[0m: \"[Circular ~.x.y]\"\n    ***REMOVED***\n  ***REMOVED***\n***REMOVED***\n\u001b[31m\n[1] \"foo\" is not allowed\u001b[0m');
                done();
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***);
