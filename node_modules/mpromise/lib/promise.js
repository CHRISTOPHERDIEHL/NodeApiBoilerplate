'use strict';
var util = require('util');
var EventEmitter = require('events').EventEmitter;
function toArray(arr, start, end) ***REMOVED***
  return Array.prototype.slice.call(arr, start, end)
***REMOVED***
function strongUnshift(x, arrLike) ***REMOVED***
  var arr = toArray(arrLike);
  arr.unshift(x);
  return arr;
***REMOVED***


/**
 * MPromise constructor.
 *
 * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._
 *
 * @param ***REMOVED***Function***REMOVED*** back a function that accepts `fn(err, ...)***REMOVED******REMOVED***` as signature
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
 * @event `reject`: Emits when the promise is rejected (event name may be overridden)
 * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)
 * @api public
 */
function Promise(back) ***REMOVED***
  this.emitter = new EventEmitter();
  this.emitted = ***REMOVED******REMOVED***;
  this.ended = false;
  if ('function' == typeof back) ***REMOVED***
    this.ended = true;
    this.onResolve(back);
  ***REMOVED***
***REMOVED***


/*
 * Module exports.
 */
module.exports = Promise;


/*!
 * event names
 */
Promise.SUCCESS = 'fulfill';
Promise.FAILURE = 'reject';


/**
 * Adds `listener` to the `event`.
 *
 * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.
 *
 * @param ***REMOVED***String***REMOVED*** event
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***MPromise***REMOVED*** this
 * @api private
 */
Promise.prototype.on = function (event, callback) ***REMOVED***
  if (this.emitted[event])
    callback.apply(undefined, this.emitted[event]);
  else
    this.emitter.on(event, callback);

  return this;
***REMOVED***;


/**
 * Keeps track of emitted events to run them on `on`.
 *
 * @api private
 */
Promise.prototype.safeEmit = function (event) ***REMOVED***
  // ensures a promise can't be fulfill() or reject() more than once
  if (event == Promise.SUCCESS || event == Promise.FAILURE) ***REMOVED***
    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) ***REMOVED***
      return this;
    ***REMOVED***
    this.emitted[event] = toArray(arguments, 1);
  ***REMOVED***

  this.emitter.emit.apply(this.emitter, arguments);
  return this;
***REMOVED***;


/**
 * @api private
 */
Promise.prototype.hasRejectListeners = function () ***REMOVED***
  return EventEmitter.listenerCount(this.emitter, Promise.FAILURE) > 0;
***REMOVED***;


/**
 * Fulfills this promise with passed arguments.
 *
 * If this promise has already been fulfilled or rejected, no action is taken.
 *
 * @api public
 */
Promise.prototype.fulfill = function () ***REMOVED***
  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));
***REMOVED***;


/**
 * Rejects this promise with `reason`.
 *
 * If this promise has already been fulfilled or rejected, no action is taken.
 *
 * @api public
 * @param ***REMOVED***Object|String***REMOVED*** reason
 * @return ***REMOVED***MPromise***REMOVED*** this
 */
Promise.prototype.reject = function (reason) ***REMOVED***
  if (this.ended && !this.hasRejectListeners())
    throw reason;
  return this.safeEmit(Promise.FAILURE, reason);
***REMOVED***;


/**
 * Resolves this promise to a rejected state if `err` is passed or
 * fulfilled state if no `err` is passed.
 *
 * @param ***REMOVED***Error***REMOVED*** [err] error or null
 * @param ***REMOVED***Object***REMOVED*** [val] value to fulfill the promise with
 * @api public
 */
Promise.prototype.resolve = function (err, val) ***REMOVED***
  if (err) return this.reject(err);
  return this.fulfill(val);
***REMOVED***;


/**
 * Adds a listener to the SUCCESS event.
 *
 * @return ***REMOVED***MPromise***REMOVED*** this
 * @api public
 */
Promise.prototype.onFulfill = function (fn) ***REMOVED***
  if (!fn) return this;
  if ('function' != typeof fn) throw new TypeError("fn should be a function");
  return this.on(Promise.SUCCESS, fn);
***REMOVED***;


/**
 * Adds a listener to the FAILURE event.
 *
 * @return ***REMOVED***MPromise***REMOVED*** this
 * @api public
 */
Promise.prototype.onReject = function (fn) ***REMOVED***
  if (!fn) return this;
  if ('function' != typeof fn) throw new TypeError("fn should be a function");
  return this.on(Promise.FAILURE, fn);
***REMOVED***;


/**
 * Adds a single function as a listener to both SUCCESS and FAILURE.
 *
 * It will be executed with traditional node.js argument position:
 * function (err, args...) ***REMOVED******REMOVED***
 *
 * Also marks the promise as `end`ed, since it's the common use-case, and yet has no
 * side effects unless `fn` is undefined or null.
 *
 * @param ***REMOVED***Function***REMOVED*** fn
 * @return ***REMOVED***MPromise***REMOVED*** this
 */
Promise.prototype.onResolve = function (fn) ***REMOVED***
  if (!fn) return this;
  if ('function' != typeof fn) throw new TypeError("fn should be a function");
  this.on(Promise.FAILURE, function (err) ***REMOVED*** fn.call(this, err); ***REMOVED***);
  this.on(Promise.SUCCESS, function () ***REMOVED*** fn.apply(this, strongUnshift(null, arguments)); ***REMOVED***);
  return this;
***REMOVED***;


/**
 * Creates a new promise and returns it. If `onFulfill` or
 * `onReject` are passed, they are added as SUCCESS/ERROR callbacks
 * to this promise after the next tick.
 *
 * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.
 *
 * ####Example:
 *
 *     var p = new Promise;
 *     p.then(function (arg) ***REMOVED***
 *       return arg + 1;
 *     ***REMOVED***).then(function (arg) ***REMOVED***
 *       throw new Error(arg + ' is an error!');
 *     ***REMOVED***).then(null, function (err) ***REMOVED***
 *       assert.ok(err instanceof Error);
 *       assert.equal('2 is an error', err.message);
 *     ***REMOVED***);
 *     p.complete(1);
 *
 * @see promises-A+ https://github.com/promises-aplus/promises-spec
 * @param ***REMOVED***Function***REMOVED*** onFulfill
 * @param ***REMOVED***Function***REMOVED*** [onReject]
 * @return ***REMOVED***MPromise***REMOVED*** newPromise
 */
Promise.prototype.then = function (onFulfill, onReject) ***REMOVED***
  var newPromise = new Promise;

  if ('function' == typeof onFulfill) ***REMOVED***
    this.onFulfill(handler(newPromise, onFulfill));
  ***REMOVED*** else ***REMOVED***
    this.onFulfill(newPromise.fulfill.bind(newPromise));
  ***REMOVED***

  if ('function' == typeof onReject) ***REMOVED***
    this.onReject(handler(newPromise, onReject));
  ***REMOVED*** else ***REMOVED***
    this.onReject(newPromise.reject.bind(newPromise));
  ***REMOVED***

  return newPromise;
***REMOVED***;


function handler(promise, fn) ***REMOVED***
  function newTickHandler() ***REMOVED***
    var pDomain = promise.emitter.domain;
    if (pDomain && pDomain !== process.domain) pDomain.enter();
    try ***REMOVED***
      var x = fn.apply(undefined, boundHandler.args);
    ***REMOVED*** catch (err) ***REMOVED***
      promise.reject(err);
      return;
    ***REMOVED***
    resolve(promise, x);
  ***REMOVED***
  function boundHandler() ***REMOVED***
    boundHandler.args = arguments;
    process.nextTick(newTickHandler);
  ***REMOVED***
  return boundHandler;
***REMOVED***


function resolve(promise, x) ***REMOVED***
  function fulfillOnce() ***REMOVED***
    if (done++) return;
    resolve.apply(undefined, strongUnshift(promise, arguments));
  ***REMOVED***
  function rejectOnce(reason) ***REMOVED***
    if (done++) return;
    promise.reject(reason);
  ***REMOVED***

  if (promise === x) ***REMOVED***
    promise.reject(new TypeError("promise and x are the same"));
    return;
  ***REMOVED***
  var rest = toArray(arguments, 1);
  var type = typeof x;
  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) ***REMOVED***
    promise.fulfill.apply(promise, rest);
    return;
  ***REMOVED***

  try ***REMOVED***
    var theThen = x.then;
  ***REMOVED*** catch (err) ***REMOVED***
    promise.reject(err);
    return;
  ***REMOVED***

  if ('function' != typeof theThen) ***REMOVED***
    promise.fulfill.apply(promise, rest);
    return;
  ***REMOVED***

  var done = 0;
  try ***REMOVED***
    var ret = theThen.call(x, fulfillOnce, rejectOnce);
    return ret;
  ***REMOVED*** catch (err) ***REMOVED***
    if (done++) return;
    promise.reject(err);
  ***REMOVED***
***REMOVED***


/**
 * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.
 *
 * ####Example:
 *
 *     var p = new Promise;
 *     p.then(function()***REMOVED*** throw new Error('shucks') ***REMOVED***);
 *     setTimeout(function () ***REMOVED***
 *       p.fulfill();
 *       // error was caught and swallowed by the promise returned from
 *       // p.then(). we either have to always register handlers on
 *       // the returned promises or we can do the following...
 *     ***REMOVED***, 10);
 *
 *     // this time we use .end() which prevents catching thrown errors
 *     var p = new Promise;
 *     var p2 = p.then(function()***REMOVED*** throw new Error('shucks') ***REMOVED***).end(); // <--
 *     setTimeout(function () ***REMOVED***
 *       p.fulfill(); // throws "shucks"
 *     ***REMOVED***, 10);
 *
 * @api public
 * @param ***REMOVED***Function***REMOVED*** [onReject]
 * @return ***REMOVED***MPromise***REMOVED*** this
 */
Promise.prototype.end = Promise.prototype['catch'] = function (onReject) ***REMOVED***
  if (!onReject && !this.hasRejectListeners())
    onReject = function idRejector(e) ***REMOVED*** throw e; ***REMOVED***;
  this.onReject(onReject);
  this.ended = true;
  return this;
***REMOVED***;


/**
 * A debug utility function that adds handlers to a promise that will log some output to the `console`
 *
 * ####Example:
 *
 *     var p = new Promise;
 *     p.then(function()***REMOVED*** throw new Error('shucks') ***REMOVED***);
 *     setTimeout(function () ***REMOVED***
 *       p.fulfill();
 *       // error was caught and swallowed by the promise returned from
 *       // p.then(). we either have to always register handlers on
 *       // the returned promises or we can do the following...
 *     ***REMOVED***, 10);
 *
 *     // this time we use .end() which prevents catching thrown errors
 *     var p = new Promise;
 *     var p2 = p.then(function()***REMOVED*** throw new Error('shucks') ***REMOVED***).end(); // <--
 *     setTimeout(function () ***REMOVED***
 *       p.fulfill(); // throws "shucks"
 *     ***REMOVED***, 10);
 *
 * @api public
 * @param ***REMOVED***MPromise***REMOVED*** p
 * @param ***REMOVED***String***REMOVED*** name
 * @return ***REMOVED***MPromise***REMOVED*** this
 */
Promise.trace = function (p, name) ***REMOVED***
  p.then(
    function () ***REMOVED***
      console.log("%s fulfill %j", name, toArray(arguments));
    ***REMOVED***,
    function () ***REMOVED***
      console.log("%s reject %j", name, toArray(arguments));
    ***REMOVED***
  )
***REMOVED***;


Promise.prototype.chain = function (p2) ***REMOVED***
  var p1 = this;
  p1.onFulfill(p2.fulfill.bind(p2));
  p1.onReject(p2.reject.bind(p2));
  return p2;
***REMOVED***;


Promise.prototype.all = function (promiseOfArr) ***REMOVED***
  var pRet = new Promise;
  this.then(promiseOfArr).then(
    function (promiseArr) ***REMOVED***
      var count = 0;
      var ret = [];
      var errSentinel;
      if (!promiseArr.length) pRet.resolve();
      promiseArr.forEach(function (promise, index) ***REMOVED***
        if (errSentinel) return;
        count++;
        promise.then(
          function (val) ***REMOVED***
            if (errSentinel) return;
            ret[index] = val;
            --count;
            if (count == 0) pRet.fulfill(ret);
          ***REMOVED***,
          function (err) ***REMOVED***
            if (errSentinel) return;
            errSentinel = err;
            pRet.reject(err);
          ***REMOVED***
        );
      ***REMOVED***);
      return pRet;
    ***REMOVED***
    , pRet.reject.bind(pRet)
  );
  return pRet;
***REMOVED***;


Promise.hook = function (arr) ***REMOVED***
  var p1 = new Promise;
  var pFinal = new Promise;
  var signalP = function () ***REMOVED***
    --count;
    if (count == 0)
      pFinal.fulfill();
    return pFinal;
  ***REMOVED***;
  var count = 1;
  var ps = p1;
  arr.forEach(function (hook) ***REMOVED***
    ps = ps.then(
      function () ***REMOVED***
        var p = new Promise;
        count++;
        hook(p.resolve.bind(p), signalP);
        return p;
      ***REMOVED***
    )
  ***REMOVED***);
  ps = ps.then(signalP);
  p1.resolve();
  return ps;
***REMOVED***;


/* This is for the A+ tests, but it's very useful as well */
Promise.fulfilled = function fulfilled() ***REMOVED*** var p = new Promise; p.fulfill.apply(p, arguments); return p; ***REMOVED***;
Promise.rejected = function rejected(reason) ***REMOVED*** return new Promise().reject(reason); ***REMOVED***;
Promise.deferred = function deferred() ***REMOVED***
  var p = new Promise;
  return ***REMOVED***
    promise: p,
    reject: p.reject.bind(p),
    resolve: p.fulfill.bind(p),
    callback: p.resolve.bind(p)
  ***REMOVED***
***REMOVED***;
/* End A+ tests adapter bit */
