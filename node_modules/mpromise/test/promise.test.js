/*global describe,it */
/**
 * Module dependencies.
 */

var assert = require('assert');
var MPromise = require('../');

/**
 * Test.
 */

describe('promise', function () ***REMOVED***
  it('events fire right after fulfill()', function (done) ***REMOVED***
    var promise = new MPromise()
      , called = 0;

    promise.on('fulfill', function (a, b) ***REMOVED***
      assert.equal(a, '1');
      assert.equal(b, '2');
      called++;
    ***REMOVED***);

    promise.fulfill('1', '2');

    promise.on('fulfill', function (a, b) ***REMOVED***
      assert.equal(a, '1');
      assert.equal(b, '2');
      called++;
    ***REMOVED***);

    assert.equal(2, called);
    done();
  ***REMOVED***);

  it('events fire right after reject()', function (done) ***REMOVED***
    var promise = new MPromise()
      , called = 0;

    promise.on('reject', function (err) ***REMOVED***
      assert.ok(err instanceof Error);
      called++;
    ***REMOVED***);

    promise.reject(new Error('booyah'));

    promise.on('reject', function (err) ***REMOVED***
      assert.ok(err instanceof Error);
      called++;
    ***REMOVED***);

    assert.equal(2, called);
    done()
  ***REMOVED***);

  describe('onResolve()', function () ***REMOVED***
    it('from constructor works', function (done) ***REMOVED***
      var called = 0;

      var promise = new MPromise(function (err) ***REMOVED***
        assert.ok(err instanceof Error);
        called++;
      ***REMOVED***);

      promise.reject(new Error('dawg'));

      assert.equal(1, called);
      done();
    ***REMOVED***);

    it('after fulfill()', function (done) ***REMOVED***
      var promise = new MPromise()
        , called = 0;

      promise.fulfill('woot');

      promise.onResolve(function (err, data) ***REMOVED***
        assert.equal(data, 'woot');
        called++;
      ***REMOVED***);

      promise.onResolve(function (err) ***REMOVED***
        assert.strictEqual(err, null);
        called++;
      ***REMOVED***);

      assert.equal(2, called);
      done();
    ***REMOVED***)
  ***REMOVED***);

  describe('onFulfill shortcut', function () ***REMOVED***
    it('works', function (done) ***REMOVED***
      var promise = new MPromise()
        , called = 0;

      promise.onFulfill(function (woot) ***REMOVED***
        assert.strictEqual(woot, undefined);
        called++;
      ***REMOVED***);

      promise.fulfill();

      assert.equal(1, called);
      done();
    ***REMOVED***);
  ***REMOVED***);

  describe('onReject shortcut', function () ***REMOVED***
    it('works', function (done) ***REMOVED***
      var promise = new MPromise()
        , called = 0;

      promise.onReject(function (err) ***REMOVED***
        assert.ok(err instanceof Error);
        called++;
      ***REMOVED***);

      promise.reject(new Error);
      assert.equal(1, called);
      done();
    ***REMOVED***)
  ***REMOVED***);

  describe('return values', function () ***REMOVED***
    it('on()', function (done) ***REMOVED***
      var promise = new MPromise();
      assert.ok(promise.on('jump', function () ***REMOVED******REMOVED***) instanceof MPromise);
      done()
    ***REMOVED***);

    it('onFulfill()', function (done) ***REMOVED***
      var promise = new MPromise();
      assert.ok(promise.onFulfill(function () ***REMOVED******REMOVED***) instanceof MPromise);
      done();
    ***REMOVED***);
    it('onReject()', function (done) ***REMOVED***
      var promise = new MPromise();
      assert.ok(promise.onReject(function () ***REMOVED******REMOVED***) instanceof MPromise);
      done();
    ***REMOVED***);
    it('onResolve()', function (done) ***REMOVED***
      var promise = new MPromise();
      assert.ok(promise.onResolve(function () ***REMOVED******REMOVED***) instanceof MPromise);
      done();
    ***REMOVED***)
  ***REMOVED***);

  describe('casting errors', function () ***REMOVED***
    describe('reject()', function () ***REMOVED***
      it('does not cast arguments to Error', function (done) ***REMOVED***
        var p = new MPromise(function (err) ***REMOVED***
          assert.equal(3, err);
          done();
        ***REMOVED***);

        p.reject(3);
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***);

  describe('then', function () ***REMOVED***
    describe('catching', function () ***REMOVED***
      it('should not catch returned promise fulfillments', function (done) ***REMOVED***
        var errorSentinal
          , p = new MPromise;
        p.then(function () ***REMOVED*** throw errorSentinal = new Error("boo!") ***REMOVED***);

        p.fulfill();
        done();
      ***REMOVED***);


      it('should not catch returned promise fulfillments even async', function (done) ***REMOVED***
        var errorSentinal
          , p = new MPromise;
        p.then(function () ***REMOVED*** throw errorSentinal = new Error("boo!") ***REMOVED***);

        setTimeout(function () ***REMOVED***
          p.fulfill();
          done();
        ***REMOVED***, 10);
      ***REMOVED***);


      it('can be disabled using .end()', function (done) ***REMOVED***
        if (process.version.indexOf('v0.8') == 0) return done();
        var errorSentinal
          , overTimeout
          , domain = require('domain').create();

        domain.once('error', function (err) ***REMOVED***
          assert(err, errorSentinal);
          clearTimeout(overTimeout);
          done()
        ***REMOVED***);

        domain.run(function () ***REMOVED***
          var p = new MPromise;
          var p2 = p.then(function () ***REMOVED***
            throw errorSentinal = new Error('shucks')
          ***REMOVED***);
          p2.end();

          p.fulfill();
        ***REMOVED***);
        overTimeout = setTimeout(function () ***REMOVED*** done(new Error('error was swallowed')); ***REMOVED***, 10);
      ***REMOVED***);


      it('can be disabled using .end() even when async', function (done) ***REMOVED***
        if (process.version.indexOf('v0.10') != 0) return done();
        var errorSentinal
          , overTimeout
          , domain = require('domain').create();

        domain.on('error', function (err) ***REMOVED***
          assert(err, errorSentinal);
          clearTimeout(overTimeout);
          done()
        ***REMOVED***);

        domain.run(function () ***REMOVED***
          var p = new MPromise;
          var p2 = p.then(function () ***REMOVED***
            throw errorSentinal = new Error("boo!")
          ***REMOVED***);
          p2.end();

          setTimeout(function () ***REMOVED***p.fulfill();***REMOVED***, 10);
        ***REMOVED***);
        overTimeout = setTimeout(function () ***REMOVED*** done(new Error('error was swallowed')); ***REMOVED***, 20);
      ***REMOVED***);


      it('can be handled using .end() so no throwing', function (done) ***REMOVED***
        var errorSentinal
          , overTimeout
          , domain = require('domain').create();

        domain.run(function () ***REMOVED***
          var p = new MPromise;
          var p2 = p.then(function () ***REMOVED***
            throw errorSentinal = new Error("boo!")
          ***REMOVED***);
          p2.end(function (err) ***REMOVED***
            assert.equal(err, errorSentinal);
            clearTimeout(overTimeout);
            done()
          ***REMOVED***);

          setTimeout(function () ***REMOVED***p.fulfill();***REMOVED***, 10);
        ***REMOVED***);
        overTimeout = setTimeout(function () ***REMOVED*** done(new Error('error was swallowed')); ***REMOVED***, 20);
      ***REMOVED***);

    ***REMOVED***);

    it('persistent', function (done) ***REMOVED***
      var p = new MPromise;
      v = null;

      function ensure(val) ***REMOVED***
        v = v || val;
        assert.equal(v, val);
      ***REMOVED***

      function guard() ***REMOVED***
        throw new Error('onReject should not be called');
      ***REMOVED***

      p.then(ensure, guard).end();

      p.fulfill('foo');
      p.fulfill('bar');
      p.reject(new Error('baz'));

      p.then(ensure, guard).end();

      setTimeout(done, 0);
    ***REMOVED***);


    it('accepts multiple completion values', function (done) ***REMOVED***
      var p = new MPromise;

      p.then(function (a, b) ***REMOVED***
        assert.equal(2, arguments.length);
        assert.equal('hi', a);
        assert.equal(4, b);
        done();
      ***REMOVED***, done).end();

      p.fulfill('hi', 4);
    ***REMOVED***)
  ***REMOVED***);

  describe('fulfill values and splats', function () ***REMOVED***
    it('should handle multiple values', function (done) ***REMOVED***
      var p = new MPromise;
      p.onFulfill(function (a, b, c) ***REMOVED***
        assert.equal('a', a);
        assert.equal('b', b);
        assert.equal('c', c);
        done();
      ***REMOVED***);
      p.fulfill('a', 'b', 'c');
    ***REMOVED***);

    it('should handle multiple values from a then', function (done) ***REMOVED***
      MPromise.fulfilled().then(
        function () ***REMOVED***
          return MPromise.fulfilled().then(
            function () ***REMOVED***
              var p = new MPromise;
              p.fulfill('a', 'b', 'c');
              return p;
            ***REMOVED***
          );
        ***REMOVED***
      ).onFulfill(
        function (a, b, c) ***REMOVED***
          assert.equal('a', a);
          assert.equal('b', b);
          assert.equal('c', c);
          done();
        ***REMOVED***
      ).end()
    ***REMOVED***);

    it('should work with `fulfilled` convenience method', function (done) ***REMOVED***
      MPromise.fulfilled('a', 'b', 'c').then(function (a, b, c) ***REMOVED***
        assert.equal('a', a);
        assert.equal('b', b);
        assert.equal('c', c);
        done();
      ***REMOVED***)
    ***REMOVED***);
  ***REMOVED***);


  describe('end', function () ***REMOVED***
    it("should return the promise", function (done) ***REMOVED***
      var p = new MPromise;
      var p1 = p.end();
      assert.equal(p, p1);
      done();
    ***REMOVED***);


    it("should throw for chain", function (done) ***REMOVED***
      var p = new MPromise;
      p.then().then().then().then().end();
      try ***REMOVED***
        p.reject('bad');
      ***REMOVED*** catch (e) ***REMOVED***
        done();
      ***REMOVED***
    ***REMOVED***);


    it("should not throw for chain with reject handler", function (done) ***REMOVED***
      var p = new MPromise;
      p.then().then().then().then().end(function () ***REMOVED***
        done();
      ***REMOVED***);
      try ***REMOVED***
        p.reject('bad');
      ***REMOVED*** catch (e) ***REMOVED***
        done(e);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);


  describe('chain', function () ***REMOVED***
    it('should propagate fulfillment', function (done) ***REMOVED***
      var varSentinel = ***REMOVED***a: 'a'***REMOVED***;
      var p1 = new MPromise;
      p1.chain(new MPromise(function (err, doc) ***REMOVED***
        assert.equal(doc, varSentinel);
        done();
      ***REMOVED***));
      p1.fulfill(varSentinel);
    ***REMOVED***);


    it('should propagate rejection', function (done) ***REMOVED***
      var e = new Error("gaga");
      var p1 = new MPromise;
      p1.chain(new MPromise(function (err) ***REMOVED***
        assert.equal(err, e);
        done();
      ***REMOVED***));
      p1.reject(e);
    ***REMOVED***);


    it('should propagate resolution err', function (done) ***REMOVED***
      var e = new Error("gaga");
      var p1 = new MPromise;
      p1.chain(new MPromise(function (err) ***REMOVED***
        assert.equal(err, e);
        done();
      ***REMOVED***));
      p1.resolve(e);
    ***REMOVED***);


    it('should propagate resolution val', function (done) ***REMOVED***
      var varSentinel = ***REMOVED***a: 'a'***REMOVED***;
      var p1 = new MPromise;
      p1.chain(new MPromise(function (err, val) ***REMOVED***
        assert.equal(val, varSentinel);
        done();
      ***REMOVED***));
      p1.resolve(null, varSentinel);
    ***REMOVED***)
  ***REMOVED***);


  describe("all", function () ***REMOVED***
    it("works", function (done) ***REMOVED***
      var count = 0;
      var p = new MPromise;
      var p2 = p.all(function () ***REMOVED***
        return [
          (function () ***REMOVED***
            var p = new MPromise();
            count++;
            p.resolve();
            return p;
          ***REMOVED***)()
          , (function () ***REMOVED***
            var p = new MPromise();
            count++;
            p.resolve();
            return p;
          ***REMOVED***)()
        ];
      ***REMOVED***);
      p2.then(function () ***REMOVED***
        assert.equal(count, 2);
        done();
      ***REMOVED***);
      p.resolve();
    ***REMOVED***);


    it("handles rejects", function (done) ***REMOVED***
      var count = 0;
      var p = new MPromise;
      var p2 = p.all(function () ***REMOVED***
        return [
          (function () ***REMOVED***
            var p = new MPromise();
            count++;
            p.resolve();
            return p;
          ***REMOVED***)()
          , (function () ***REMOVED***
            count++;
            throw new Error("gaga");
          ***REMOVED***)()
        ];
      ***REMOVED***);
      p2.onReject(function (err) ***REMOVED***
        assert(err.message, "gaga");
        assert.equal(count, 2);
        done();
      ***REMOVED***);
      p.resolve();
    ***REMOVED***);
  ***REMOVED***);


  describe("deferred", function () ***REMOVED***
    it("works", function (done) ***REMOVED***
      var d = MPromise.deferred();
      assert.ok(d.promise instanceof MPromise);
      assert.ok(d.reject instanceof Function);
      assert.ok(d.resolve instanceof Function);
      assert.ok(d.callback instanceof Function);
      done();
    ***REMOVED***);
  ***REMOVED***);


  describe("hook", function () ***REMOVED***
    it("works", function (done) ***REMOVED***
      var run = 0;
      var l1 = function (ser, par) ***REMOVED***
        run++;
        ser();
        par();
      ***REMOVED***;
      MPromise.hook([l1, l1, l1]).then(function () ***REMOVED***
        assert(run, 3);
        done();
      ***REMOVED***)

    ***REMOVED***);


    it("works with async serial hooks", function (done) ***REMOVED***
      this.timeout(800);
      var run = 0;
      var l1 = function (ser, par) ***REMOVED***
        run++;
        setTimeout(function () ***REMOVED***ser();***REMOVED***, 200);
        par();
      ***REMOVED***;
      MPromise.hook([l1, l1, l1]).then(function () ***REMOVED***
        assert(run, 3);
        done();
      ***REMOVED***)
    ***REMOVED***);


    it("works with async parallel hooks", function (done) ***REMOVED***
      this.timeout(400);
      var run = 0;
      var l1 = function (ser, par) ***REMOVED***
        run++;
        ser();
        setTimeout(function () ***REMOVED***par();***REMOVED***, 200);
      ***REMOVED***;
      MPromise.hook([l1, l1, l1]).then(function () ***REMOVED***
        assert(run, 3);
        done();
      ***REMOVED***)
    ***REMOVED***);


    it("catches errors in hook logic", function (done) ***REMOVED***
      var run = 0;
      var l1 = function (ser, par) ***REMOVED***
        run++;
        ser();
        par();
      ***REMOVED***;
      var l2 = function (ser, par) ***REMOVED***
        run++;
        ser();
        par();
        throw new Error("err")
      ***REMOVED***;
      MPromise.hook([l1, l2, l1]).end(function (err) ***REMOVED***
        assert(run, 2);
        done();
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***);
