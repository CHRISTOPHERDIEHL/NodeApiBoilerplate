var len = 0;
var vertxNext;
var customSchedulerFn;

export var asap = function asap(callback, arg) ***REMOVED***
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) ***REMOVED***
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) ***REMOVED***
      customSchedulerFn(flush);
    ***REMOVED*** else ***REMOVED***
      scheduleFlush();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

export function setScheduler(scheduleFn) ***REMOVED***
  customSchedulerFn = scheduleFn;
***REMOVED***

export function setAsap(asapFn) ***REMOVED***
  asap = asapFn;
***REMOVED***

var browserWindow = (typeof window !== 'undefined') ? window : undefined;
var browserGlobal = browserWindow || ***REMOVED******REMOVED***;
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ***REMOVED******REMOVED***.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' &&
  typeof importScripts !== 'undefined' &&
  typeof MessageChannel !== 'undefined';

// node
function useNextTick() ***REMOVED***
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function() ***REMOVED***
    process.nextTick(flush);
  ***REMOVED***;
***REMOVED***

// vertx
function useVertxTimer() ***REMOVED***
  return function() ***REMOVED***
    vertxNext(flush);
  ***REMOVED***;
***REMOVED***

function useMutationObserver() ***REMOVED***
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, ***REMOVED*** characterData: true ***REMOVED***);

  return function() ***REMOVED***
    node.data = (iterations = ++iterations % 2);
  ***REMOVED***;
***REMOVED***

// web worker
function useMessageChannel() ***REMOVED***
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () ***REMOVED***
    channel.port2.postMessage(0);
  ***REMOVED***;
***REMOVED***

function useSetTimeout() ***REMOVED***
  return function() ***REMOVED***
    setTimeout(flush, 1);
  ***REMOVED***;
***REMOVED***

var queue = new Array(1000);
function flush() ***REMOVED***
  for (var i = 0; i < len; i+=2) ***REMOVED***
    var callback = queue[i];
    var arg = queue[i+1];

    callback(arg);

    queue[i] = undefined;
    queue[i+1] = undefined;
  ***REMOVED***

  len = 0;
***REMOVED***

function attemptVertx() ***REMOVED***
  try ***REMOVED***
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  ***REMOVED*** catch(e) ***REMOVED***
    return useSetTimeout();
  ***REMOVED***
***REMOVED***

var scheduleFlush;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) ***REMOVED***
  scheduleFlush = useNextTick();
***REMOVED*** else if (BrowserMutationObserver) ***REMOVED***
  scheduleFlush = useMutationObserver();
***REMOVED*** else if (isWorker) ***REMOVED***
  scheduleFlush = useMessageChannel();
***REMOVED*** else if (browserWindow === undefined && typeof require === 'function') ***REMOVED***
  scheduleFlush = attemptVertx();
***REMOVED*** else ***REMOVED***
  scheduleFlush = useSetTimeout();
***REMOVED***
