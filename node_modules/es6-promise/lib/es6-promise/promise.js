import ***REMOVED***
  isFunction
***REMOVED*** from './utils';

import ***REMOVED***
  noop,
  nextId,
  PROMISE_ID,
  initializePromise
***REMOVED*** from './-internal';

import ***REMOVED***
  asap,
  setAsap,
  setScheduler
***REMOVED*** from './asap';

import all from './promise/all';
import race from './promise/race';
import Resolve from './promise/resolve';
import Reject from './promise/reject';
import then from './then';


function needsResolver() ***REMOVED***
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
***REMOVED***

function needsNew() ***REMOVED***
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
***REMOVED***

export default Promise;
/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  var promise = new Promise(function(resolve, reject) ***REMOVED***
    // on success
    resolve(value);

    // on failure
    reject(reason);
  ***REMOVED***);

  promise.then(function(value) ***REMOVED***
    // on fulfillment
  ***REMOVED***, function(reason) ***REMOVED***
    // on rejection
  ***REMOVED***);
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) ***REMOVED***
    return new Promise(function(resolve, reject)***REMOVED***
      var xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() ***REMOVED***
        if (this.readyState === this.DONE) ***REMOVED***
          if (this.status === 200) ***REMOVED***
            resolve(this.response);
          ***REMOVED*** else ***REMOVED***
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***);
  ***REMOVED***

  getJSON('/posts.json').then(function(json) ***REMOVED***
    // on fulfillment
  ***REMOVED***, function(reason) ***REMOVED***
    // on rejection
  ***REMOVED***);
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values)***REMOVED***
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  ***REMOVED***);
  ```

  @class Promise
  @param ***REMOVED***function***REMOVED*** resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) ***REMOVED***
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) ***REMOVED***
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  ***REMOVED***
***REMOVED***

Promise.all = all;
Promise.race = race;
Promise.resolve = Resolve;
Promise.reject = Reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = ***REMOVED***
  constructor: Promise,

/**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.

  ```js
  findUser().then(function(user)***REMOVED***
    // user is available
  ***REMOVED***, function(reason)***REMOVED***
    // user is unavailable, and you are given the reason why
  ***REMOVED***);
  ```

  Chaining
  --------

  The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.

  ```js
  findUser().then(function (user) ***REMOVED***
    return user.name;
  ***REMOVED***, function (reason) ***REMOVED***
    return 'default name';
  ***REMOVED***).then(function (userName) ***REMOVED***
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  ***REMOVED***);

  findUser().then(function (user) ***REMOVED***
    throw new Error('Found user, but still unhappy');
  ***REMOVED***, function (reason) ***REMOVED***
    throw new Error('`findUser` rejected and we're unhappy');
  ***REMOVED***).then(function (value) ***REMOVED***
    // never reached
  ***REMOVED***, function (reason) ***REMOVED***
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  ***REMOVED***);
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

  ```js
  findUser().then(function (user) ***REMOVED***
    throw new PedagogicalException('Upstream error');
  ***REMOVED***).then(function (value) ***REMOVED***
    // never reached
  ***REMOVED***).then(function (value) ***REMOVED***
    // never reached
  ***REMOVED***, function (reason) ***REMOVED***
    // The `PedgagocialException` is propagated all the way down to here
  ***REMOVED***);
  ```

  Assimilation
  ------------

  Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.

  ```js
  findUser().then(function (user) ***REMOVED***
    return findCommentsByAuthor(user);
  ***REMOVED***).then(function (comments) ***REMOVED***
    // The user's comments are now available
  ***REMOVED***);
  ```

  If the assimliated promise rejects, then the downstream promise will also reject.

  ```js
  findUser().then(function (user) ***REMOVED***
    return findCommentsByAuthor(user);
  ***REMOVED***).then(function (comments) ***REMOVED***
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  ***REMOVED***, function (reason) ***REMOVED***
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  ***REMOVED***);
  ```

  Simple Example
  --------------

  Synchronous Example

  ```javascript
  var result;

  try ***REMOVED***
    result = findResult();
    // success
  ***REMOVED*** catch(reason) ***REMOVED***
    // failure
  ***REMOVED***
  ```

  Errback Example

  ```js
  findResult(function(result, err)***REMOVED***
    if (err) ***REMOVED***
      // failure
    ***REMOVED*** else ***REMOVED***
      // success
    ***REMOVED***
  ***REMOVED***);
  ```

  Promise Example;

  ```javascript
  findResult().then(function(result)***REMOVED***
    // success
  ***REMOVED***, function(reason)***REMOVED***
    // failure
  ***REMOVED***);
  ```

  Advanced Example
  --------------

  Synchronous Example

  ```javascript
  var author, books;

  try ***REMOVED***
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  ***REMOVED*** catch(reason) ***REMOVED***
    // failure
  ***REMOVED***
  ```

  Errback Example

  ```js

  function foundBooks(books) ***REMOVED***

  ***REMOVED***

  function failure(reason) ***REMOVED***

  ***REMOVED***

  findAuthor(function(author, err)***REMOVED***
    if (err) ***REMOVED***
      failure(err);
      // failure
    ***REMOVED*** else ***REMOVED***
      try ***REMOVED***
        findBoooksByAuthor(author, function(books, err) ***REMOVED***
          if (err) ***REMOVED***
            failure(err);
          ***REMOVED*** else ***REMOVED***
            try ***REMOVED***
              foundBooks(books);
            ***REMOVED*** catch(reason) ***REMOVED***
              failure(reason);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** catch(error) ***REMOVED***
        failure(err);
      ***REMOVED***
      // success
    ***REMOVED***
  ***REMOVED***);
  ```

  Promise Example;

  ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books)***REMOVED***
      // found books
  ***REMOVED***).catch(function(reason)***REMOVED***
    // something went wrong
  ***REMOVED***);
  ```

  @method then
  @param ***REMOVED***Function***REMOVED*** onFulfilled
  @param ***REMOVED***Function***REMOVED*** onRejected
  Useful for tooling.
  @return ***REMOVED***Promise***REMOVED***
*/
  then: then,

/**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.

  ```js
  function findAuthor()***REMOVED***
    throw new Error('couldn't find that author');
  ***REMOVED***

  // synchronous
  try ***REMOVED***
    findAuthor();
  ***REMOVED*** catch(reason) ***REMOVED***
    // something went wrong
  ***REMOVED***

  // async with promises
  findAuthor().catch(function(reason)***REMOVED***
    // something went wrong
  ***REMOVED***);
  ```

  @method catch
  @param ***REMOVED***Function***REMOVED*** onRejection
  Useful for tooling.
  @return ***REMOVED***Promise***REMOVED***
*/
  'catch': function(onRejection) ***REMOVED***
    return this.then(null, onRejection);
  ***REMOVED***
***REMOVED***;
