import ***REMOVED***
  objectOrFunction,
  isFunction
***REMOVED*** from './utils';

import ***REMOVED***
  asap
***REMOVED*** from './asap';

import originalThen from './then';
import originalResolve from './promise/resolve';

export var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() ***REMOVED******REMOVED***

var PENDING   = void 0;
var FULFILLED = 1;
var REJECTED  = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() ***REMOVED***
  return new TypeError("You cannot resolve a promise with itself");
***REMOVED***

function cannotReturnOwn() ***REMOVED***
  return new TypeError('A promises callback cannot return that same promise.');
***REMOVED***

function getThen(promise) ***REMOVED***
  try ***REMOVED***
    return promise.then;
  ***REMOVED*** catch(error) ***REMOVED***
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  ***REMOVED***
***REMOVED***

function tryThen(then, value, fulfillmentHandler, rejectionHandler) ***REMOVED***
  try ***REMOVED***
    then.call(value, fulfillmentHandler, rejectionHandler);
  ***REMOVED*** catch(e) ***REMOVED***
    return e;
  ***REMOVED***
***REMOVED***

function handleForeignThenable(promise, thenable, then) ***REMOVED***
   asap(function(promise) ***REMOVED***
    var sealed = false;
    var error = tryThen(then, thenable, function(value) ***REMOVED***
      if (sealed) ***REMOVED*** return; ***REMOVED***
      sealed = true;
      if (thenable !== value) ***REMOVED***
        resolve(promise, value);
      ***REMOVED*** else ***REMOVED***
        fulfill(promise, value);
      ***REMOVED***
    ***REMOVED***, function(reason) ***REMOVED***
      if (sealed) ***REMOVED*** return; ***REMOVED***
      sealed = true;

      reject(promise, reason);
    ***REMOVED***, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) ***REMOVED***
      sealed = true;
      reject(promise, error);
    ***REMOVED***
  ***REMOVED***, promise);
***REMOVED***

function handleOwnThenable(promise, thenable) ***REMOVED***
  if (thenable._state === FULFILLED) ***REMOVED***
    fulfill(promise, thenable._result);
  ***REMOVED*** else if (thenable._state === REJECTED) ***REMOVED***
    reject(promise, thenable._result);
  ***REMOVED*** else ***REMOVED***
    subscribe(thenable, undefined, function(value) ***REMOVED***
      resolve(promise, value);
    ***REMOVED***, function(reason) ***REMOVED***
      reject(promise, reason);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

function handleMaybeThenable(promise, maybeThenable, then) ***REMOVED***
  if (maybeThenable.constructor === promise.constructor &&
      then === originalThen &&
      constructor.resolve === originalResolve) ***REMOVED***
    handleOwnThenable(promise, maybeThenable);
  ***REMOVED*** else ***REMOVED***
    if (then === GET_THEN_ERROR) ***REMOVED***
      reject(promise, GET_THEN_ERROR.error);
    ***REMOVED*** else if (then === undefined) ***REMOVED***
      fulfill(promise, maybeThenable);
    ***REMOVED*** else if (isFunction(then)) ***REMOVED***
      handleForeignThenable(promise, maybeThenable, then);
    ***REMOVED*** else ***REMOVED***
      fulfill(promise, maybeThenable);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function resolve(promise, value) ***REMOVED***
  if (promise === value) ***REMOVED***
    reject(promise, selfFulfillment());
  ***REMOVED*** else if (objectOrFunction(value)) ***REMOVED***
    handleMaybeThenable(promise, value, getThen(value));
  ***REMOVED*** else ***REMOVED***
    fulfill(promise, value);
  ***REMOVED***
***REMOVED***

function publishRejection(promise) ***REMOVED***
  if (promise._onerror) ***REMOVED***
    promise._onerror(promise._result);
  ***REMOVED***

  publish(promise);
***REMOVED***

function fulfill(promise, value) ***REMOVED***
  if (promise._state !== PENDING) ***REMOVED*** return; ***REMOVED***

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) ***REMOVED***
    asap(publish, promise);
  ***REMOVED***
***REMOVED***

function reject(promise, reason) ***REMOVED***
  if (promise._state !== PENDING) ***REMOVED*** return; ***REMOVED***
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
***REMOVED***

function subscribe(parent, child, onFulfillment, onRejection) ***REMOVED***
  var subscribers = parent._subscribers;
  var length = subscribers.length;

  parent._onerror = null;

  subscribers[length] = child;
  subscribers[length + FULFILLED] = onFulfillment;
  subscribers[length + REJECTED]  = onRejection;

  if (length === 0 && parent._state) ***REMOVED***
    asap(publish, parent);
  ***REMOVED***
***REMOVED***

function publish(promise) ***REMOVED***
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) ***REMOVED*** return; ***REMOVED***

  var child, callback, detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) ***REMOVED***
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) ***REMOVED***
      invokeCallback(settled, child, callback, detail);
    ***REMOVED*** else ***REMOVED***
      callback(detail);
    ***REMOVED***
  ***REMOVED***

  promise._subscribers.length = 0;
***REMOVED***

function ErrorObject() ***REMOVED***
  this.error = null;
***REMOVED***

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) ***REMOVED***
  try ***REMOVED***
    return callback(detail);
  ***REMOVED*** catch(e) ***REMOVED***
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  ***REMOVED***
***REMOVED***

function invokeCallback(settled, promise, callback, detail) ***REMOVED***
  var hasCallback = isFunction(callback),
      value, error, succeeded, failed;

  if (hasCallback) ***REMOVED***
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) ***REMOVED***
      failed = true;
      error = value.error;
      value = null;
    ***REMOVED*** else ***REMOVED***
      succeeded = true;
    ***REMOVED***

    if (promise === value) ***REMOVED***
      reject(promise, cannotReturnOwn());
      return;
    ***REMOVED***

  ***REMOVED*** else ***REMOVED***
    value = detail;
    succeeded = true;
  ***REMOVED***

  if (promise._state !== PENDING) ***REMOVED***
    // noop
  ***REMOVED*** else if (hasCallback && succeeded) ***REMOVED***
    resolve(promise, value);
  ***REMOVED*** else if (failed) ***REMOVED***
    reject(promise, error);
  ***REMOVED*** else if (settled === FULFILLED) ***REMOVED***
    fulfill(promise, value);
  ***REMOVED*** else if (settled === REJECTED) ***REMOVED***
    reject(promise, value);
  ***REMOVED***
***REMOVED***

function initializePromise(promise, resolver) ***REMOVED***
  try ***REMOVED***
    resolver(function resolvePromise(value)***REMOVED***
      resolve(promise, value);
    ***REMOVED***, function rejectPromise(reason) ***REMOVED***
      reject(promise, reason);
    ***REMOVED***);
  ***REMOVED*** catch(e) ***REMOVED***
    reject(promise, e);
  ***REMOVED***
***REMOVED***

var id = 0;
function nextId() ***REMOVED***
  return id++;
***REMOVED***

function makePromise(promise) ***REMOVED***
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
***REMOVED***

export ***REMOVED***
  nextId,
  makePromise,
  getThen,
  noop,
  resolve,
  reject,
  fulfill,
  subscribe,
  publish,
  publishRejection,
  initializePromise,
  invokeCallback,
  FULFILLED,
  REJECTED,
  PENDING,
  handleMaybeThenable
***REMOVED***;
