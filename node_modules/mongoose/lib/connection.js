/*!
 * Module dependencies.
 */

var utils = require('./utils');
var EventEmitter = require('events').EventEmitter;
var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';
var Schema = require('./schema');
var Collection = require(driver + '/collection');
var STATES = require('./connectionstate');
var MongooseError = require('./error');
var muri = require('muri');
var PromiseProvider = require('./promise_provider');

/*!
 * Protocol prefix regexp.
 *
 * @api private
 */

var rgxProtocol = /^(?:.)+:\/\//;

/*!
 * A list of authentication mechanisms that don't require a password for authentication.
 * This is used by the authMechanismDoesNotRequirePassword method.
 *
 * @api private
 */
var authMechanismsWhichDontRequirePassword = [
  'MONGODB-X509'
];

/**
 * Connection constructor
 *
 * For practical reasons, a Connection equals a Db.
 *
 * @param ***REMOVED***Mongoose***REMOVED*** base a mongoose instance
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
 * @event `connecting`: Emitted when `connection.***REMOVED***open,openSet***REMOVED***()` is executed on this connection.
 * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.
 * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.
 * @event `disconnecting`: Emitted when `connection.close()` was executed.
 * @event `disconnected`: Emitted after getting disconnected from the db.
 * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.
 * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull connection.
 * @event `error`: Emitted when an error occurs on this connection.
 * @event `fullsetup`: Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string are connected.
 * @event `all`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.
 * @api public
 */

function Connection(base) ***REMOVED***
  this.base = base;
  this.collections = ***REMOVED******REMOVED***;
  this.models = ***REMOVED******REMOVED***;
  this.config = ***REMOVED***autoIndex: true***REMOVED***;
  this.replica = false;
  this.hosts = null;
  this.host = null;
  this.port = null;
  this.user = null;
  this.pass = null;
  this.name = null;
  this.options = null;
  this.otherDbs = [];
  this._readyState = STATES.disconnected;
  this._closeCalled = false;
  this._hasOpened = false;
***REMOVED***

/*!
 * Inherit from EventEmitter
 */

Connection.prototype.__proto__ = EventEmitter.prototype;

/**
 * Connection ready state
 *
 * - 0 = disconnected
 * - 1 = connected
 * - 2 = connecting
 * - 3 = disconnecting
 *
 * Each state change emits its associated event name.
 *
 * ####Example
 *
 *     conn.on('connected', callback);
 *     conn.on('disconnected', callback);
 *
 * @property readyState
 * @api public
 */

Object.defineProperty(Connection.prototype, 'readyState', ***REMOVED***
  get: function() ***REMOVED***
    return this._readyState;
  ***REMOVED***,
  set: function(val) ***REMOVED***
    if (!(val in STATES)) ***REMOVED***
      throw new Error('Invalid connection state: ' + val);
    ***REMOVED***

    if (this._readyState !== val) ***REMOVED***
      this._readyState = val;
      // loop over the otherDbs on this connection and change their state
      for (var i = 0; i < this.otherDbs.length; i++) ***REMOVED***
        this.otherDbs[i].readyState = val;
      ***REMOVED***

      if (STATES.connected === val) ***REMOVED***
        this._hasOpened = true;
      ***REMOVED***

      this.emit(STATES[val]);
    ***REMOVED***
  ***REMOVED***
***REMOVED***);

/**
 * A hash of the collections associated with this connection
 *
 * @property collections
 */

Connection.prototype.collections;

/**
 * The mongodb.Db instance, set when the connection is opened
 *
 * @property db
 */

Connection.prototype.db;

/**
 * A hash of the global options that are associated with this connection
 *
 * @property config
 */

Connection.prototype.config;

/**
 * Opens the connection to MongoDB.
 *
 * `options` is a hash with the following possible properties:
 *
 *     config  - passed to the connection config instance
 *     db      - passed to the connection db instance
 *     server  - passed to the connection server instance(s)
 *     replset - passed to the connection ReplSet instance
 *     user    - username for authentication
 *     pass    - password for authentication
 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
 *
 * ####Notes:
 *
 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
 * See the node-mongodb-native driver instance for options that it understands.
 *
 * _Options passed take precedence over options included in connection strings._
 *
 * @param ***REMOVED***String***REMOVED*** connection_string mongodb://uri or the host to which you are connecting
 * @param ***REMOVED***String***REMOVED*** [database] database name
 * @param ***REMOVED***Number***REMOVED*** [port] database port
 * @param ***REMOVED***Object***REMOVED*** [options] options
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
 * @api public
 */

Connection.prototype.open = function(host, database, port, options, callback) ***REMOVED***
  var parsed;
  var Promise = PromiseProvider.get();

  if (typeof database === 'string') ***REMOVED***
    switch (arguments.length) ***REMOVED***
      case 2:
        port = 27017;
        break;
      case 3:
        switch (typeof port) ***REMOVED***
          case 'function':
            callback = port;
            port = 27017;
            break;
          case 'object':
            options = port;
            port = 27017;
            break;
        ***REMOVED***
        break;
      case 4:
        if (typeof options === 'function') ***REMOVED***
          callback = options;
          options = ***REMOVED******REMOVED***;
        ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    switch (typeof database) ***REMOVED***
      case 'function':
        callback = database;
        database = undefined;
        break;
      case 'object':
        options = database;
        database = undefined;
        callback = port;
        break;
    ***REMOVED***

    if (!rgxProtocol.test(host)) ***REMOVED***
      host = 'mongodb://' + host;
    ***REMOVED***

    try ***REMOVED***
      parsed = muri(host);
    ***REMOVED*** catch (err) ***REMOVED***
      this.error(err, callback);
      return this;
    ***REMOVED***

    database = parsed.db;
    host = parsed.hosts[0].host || parsed.hosts[0].ipc;
    port = parsed.hosts[0].port || 27017;
  ***REMOVED***

  this.options = this.parseOptions(options, parsed && parsed.options);

  // make sure we can open
  if (STATES.disconnected !== this.readyState) ***REMOVED***
    var err = new Error('Trying to open unclosed connection.');
    err.state = this.readyState;
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) ***REMOVED***
      reject(err);
    ***REMOVED***);
  ***REMOVED***

  if (!host) ***REMOVED***
    this.error(new Error('Missing hostname.'), callback);
    return new Promise.ES6(function(resolve, reject) ***REMOVED***
      reject(err);
    ***REMOVED***);
  ***REMOVED***

  if (!database) ***REMOVED***
    this.error(new Error('Missing database name.'), callback);
    return new Promise.ES6(function(resolve, reject) ***REMOVED***
      reject(err);
    ***REMOVED***);
  ***REMOVED***

  // authentication
  if (this.optionsProvideAuthenticationData(options)) ***REMOVED***
    this.user = options.user;
    this.pass = options.pass;
  ***REMOVED*** else if (parsed && parsed.auth) ***REMOVED***
    this.user = parsed.auth.user;
    this.pass = parsed.auth.pass;

    // Check hostname for user/pass
  ***REMOVED*** else if (/@/.test(host) && /:/.test(host.split('@')[0])) ***REMOVED***
    host = host.split('@');
    var auth = host.shift().split(':');
    host = host.pop();
    this.user = auth[0];
    this.pass = auth[1];
  ***REMOVED*** else ***REMOVED***
    this.user = this.pass = undefined;
  ***REMOVED***

  // global configuration options
  if (options && options.config) ***REMOVED***
    this.config.autoIndex = options.config.autoIndex !== false;
  ***REMOVED***

  this.name = database;
  this.host = host;
  this.port = port;

  var _this = this;
  var promise = new Promise.ES6(function(resolve, reject) ***REMOVED***
    _this._open(true, function(error) ***REMOVED***
      callback && callback(error);
      if (error) ***REMOVED***
        reject(error);
        if (!callback && !promise.$hasHandler) ***REMOVED***
          _this.emit('error', error);
        ***REMOVED***
        return;
      ***REMOVED***
      resolve();
    ***REMOVED***);
  ***REMOVED***);
  return promise;
***REMOVED***;

/**
 * Helper for `dropDatabase()`.
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 */

Connection.prototype.dropDatabase = function(callback) ***REMOVED***
  var Promise = PromiseProvider.get();
  var _this = this;
  var promise = new Promise.ES6(function(resolve, reject) ***REMOVED***
    if (_this.readyState !== STATES.connected) ***REMOVED***
      _this.on('open', function() ***REMOVED***
        _this.db.dropDatabase(function(error) ***REMOVED***
          if (error) ***REMOVED***
            reject(error);
          ***REMOVED*** else ***REMOVED***
            resolve();
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      _this.db.dropDatabase(function(error) ***REMOVED***
        if (error) ***REMOVED***
          reject(error);
        ***REMOVED*** else ***REMOVED***
          resolve();
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);
  if (callback) ***REMOVED***
    promise.then(function() ***REMOVED*** callback(); ***REMOVED***, callback);
  ***REMOVED***
  return promise;
***REMOVED***;

/**
 * Opens the connection to a replica set.
 *
 * ####Example:
 *
 *     var db = mongoose.createConnection();
 *     db.openSet("mongodb://user:pwd@localhost:27020,localhost:27021,localhost:27012/mydb");
 *
 * The database name and/or auth need only be included in one URI.
 * The `options` is a hash which is passed to the internal driver connection object.
 *
 * Valid `options`
 *
 *     db      - passed to the connection db instance
 *     server  - passed to the connection server instance(s)
 *     replset - passed to the connection ReplSetServer instance
 *     user    - username for authentication
 *     pass    - password for authentication
 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
 *     mongos  - Boolean - if true, enables High Availability support for mongos
 *
 * _Options passed take precedence over options included in connection strings._
 *
 * ####Notes:
 *
 * _If connecting to multiple mongos servers, set the `mongos` option to true._
 *
 *     conn.open('mongodb://mongosA:27501,mongosB:27501', ***REMOVED*** mongos: true ***REMOVED***, cb);
 *
 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
 * See the node-mongodb-native driver instance for options that it understands.
 *
 * _Options passed take precedence over options included in connection strings._
 *
 * @param ***REMOVED***String***REMOVED*** uris MongoDB connection string
 * @param ***REMOVED***String***REMOVED*** [database] database name if not included in `uris`
 * @param ***REMOVED***Object***REMOVED*** [options] passed to the internal driver
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
 * @api public
 */

Connection.prototype.openSet = function(uris, database, options, callback) ***REMOVED***
  if (!rgxProtocol.test(uris)) ***REMOVED***
    uris = 'mongodb://' + uris;
  ***REMOVED***

  var Promise = PromiseProvider.get();

  switch (arguments.length) ***REMOVED***
    case 3:
      switch (typeof database) ***REMOVED***
        case 'string':
          this.name = database;
          break;
        case 'object':
          callback = options;
          options = database;
          database = null;
          break;
      ***REMOVED***

      if (typeof options === 'function') ***REMOVED***
        callback = options;
        options = ***REMOVED******REMOVED***;
      ***REMOVED***
      break;
    case 2:
      switch (typeof database) ***REMOVED***
        case 'string':
          this.name = database;
          break;
        case 'function':
          callback = database;
          database = null;
          break;
        case 'object':
          options = database;
          database = null;
          break;
      ***REMOVED***
  ***REMOVED***

  if (typeof database === 'string') ***REMOVED***
    this.name = database;
  ***REMOVED***

  var parsed;
  try ***REMOVED***
    parsed = muri(uris);
  ***REMOVED*** catch (err) ***REMOVED***
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) ***REMOVED***
      reject(err);
    ***REMOVED***);
  ***REMOVED***

  if (!this.name) ***REMOVED***
    this.name = parsed.db;
  ***REMOVED***

  this.hosts = parsed.hosts;
  this.options = this.parseOptions(options, parsed && parsed.options);
  this.replica = true;

  if (!this.name) ***REMOVED***
    var err = new Error('No database name provided for replica set');
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) ***REMOVED***
      reject(err);
    ***REMOVED***);
  ***REMOVED***

  // authentication
  if (this.optionsProvideAuthenticationData(options)) ***REMOVED***
    this.user = options.user;
    this.pass = options.pass;
  ***REMOVED*** else if (parsed && parsed.auth) ***REMOVED***
    this.user = parsed.auth.user;
    this.pass = parsed.auth.pass;
  ***REMOVED*** else ***REMOVED***
    this.user = this.pass = undefined;
  ***REMOVED***

  // global configuration options
  if (options && options.config) ***REMOVED***
    this.config.autoIndex = options.config.autoIndex !== false;
  ***REMOVED***

  var _this = this;
  var emitted = false;
  var promise = new Promise.ES6(function(resolve, reject) ***REMOVED***
    _this._open(true, function(error) ***REMOVED***
      callback && callback(error);
      if (error) ***REMOVED***
        reject(error);
        if (!callback && !promise.$hasHandler && !emitted) ***REMOVED***
          emitted = true;
          _this.emit('error', error);
        ***REMOVED***
        return;
      ***REMOVED***
      resolve();
    ***REMOVED***);
  ***REMOVED***);
  return promise;
***REMOVED***;

/**
 * error
 *
 * Graceful error handling, passes error to callback
 * if available, else emits error on the connection.
 *
 * @param ***REMOVED***Error***REMOVED*** err
 * @param ***REMOVED***Function***REMOVED*** callback optional
 * @api private
 */

Connection.prototype.error = function(err, callback) ***REMOVED***
  if (callback) ***REMOVED***
    return callback(err);
  ***REMOVED***
  this.emit('error', err);
***REMOVED***;

/**
 * Handles opening the connection with the appropriate method based on connection type.
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @api private
 */

Connection.prototype._open = function(emit, callback) ***REMOVED***
  this.readyState = STATES.connecting;
  this._closeCalled = false;

  var _this = this;

  var method = this.replica
      ? 'doOpenSet'
      : 'doOpen';

  // open connection
  this[method](function(err) ***REMOVED***
    if (err) ***REMOVED***
      _this.readyState = STATES.disconnected;
      if (_this._hasOpened) ***REMOVED***
        if (callback) ***REMOVED***
          callback(err);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        _this.error(err, emit && callback);
      ***REMOVED***
      return;
    ***REMOVED***

    _this.onOpen(callback);
  ***REMOVED***);
***REMOVED***;

/**
 * Called when the connection is opened
 *
 * @api private
 */

Connection.prototype.onOpen = function(callback) ***REMOVED***
  var _this = this;

  function open(err, isAuth) ***REMOVED***
    if (err) ***REMOVED***
      _this.readyState = isAuth ? STATES.unauthorized : STATES.disconnected;
      _this.error(err, callback);
      return;
    ***REMOVED***

    _this.readyState = STATES.connected;

    // avoid having the collection subscribe to our event emitter
    // to prevent 0.3 warning
    for (var i in _this.collections) ***REMOVED***
      if (utils.object.hasOwnProperty(_this.collections, i)) ***REMOVED***
        _this.collections[i].onOpen();
      ***REMOVED***
    ***REMOVED***

    callback && callback();
    _this.emit('open');
  ***REMOVED***

  // re-authenticate if we're not already connected #3871
  if (this._readyState !== STATES.connected && this.shouldAuthenticate()) ***REMOVED***
    _this.db.authenticate(_this.user, _this.pass, _this.options.auth, function(err) ***REMOVED***
      open(err, true);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    open();
  ***REMOVED***
***REMOVED***;

/**
 * Closes the connection
 *
 * @param ***REMOVED***Function***REMOVED*** [callback] optional
 * @return ***REMOVED***Connection***REMOVED*** self
 * @api public
 */

Connection.prototype.close = function(callback) ***REMOVED***
  var _this = this;
  var Promise = PromiseProvider.get();
  return new Promise.ES6(function(resolve, reject) ***REMOVED***
    _this._close(function(error) ***REMOVED***
      callback && callback(error);
      if (error) ***REMOVED***
        reject(error);
        return;
      ***REMOVED***
      resolve();
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Handles closing the connection
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @api private
 */
Connection.prototype._close = function(callback) ***REMOVED***
  var _this = this;
  this._closeCalled = true;

  switch (this.readyState) ***REMOVED***
    case 0: // disconnected
      callback && callback();
      break;

    case 1: // connected
    case 4: // unauthorized
      this.readyState = STATES.disconnecting;
      this.doClose(function(err) ***REMOVED***
        if (err) ***REMOVED***
          _this.error(err, callback);
        ***REMOVED*** else ***REMOVED***
          _this.onClose();
          callback && callback();
        ***REMOVED***
      ***REMOVED***);
      break;

    case 2: // connecting
      this.once('open', function() ***REMOVED***
        _this.close(callback);
      ***REMOVED***);
      break;

    case 3: // disconnecting
      if (!callback) ***REMOVED***
        break;
      ***REMOVED***
      this.once('close', function() ***REMOVED***
        callback();
      ***REMOVED***);
      break;
  ***REMOVED***

  return this;
***REMOVED***;

/**
 * Called when the connection closes
 *
 * @api private
 */

Connection.prototype.onClose = function() ***REMOVED***
  this.readyState = STATES.disconnected;

  // avoid having the collection subscribe to our event emitter
  // to prevent 0.3 warning
  for (var i in this.collections) ***REMOVED***
    if (utils.object.hasOwnProperty(this.collections, i)) ***REMOVED***
      this.collections[i].onClose();
    ***REMOVED***
  ***REMOVED***

  this.emit('close');
***REMOVED***;

/**
 * Retrieves a collection, creating it if not cached.
 *
 * Not typically needed by applications. Just talk to your collection through your model.
 *
 * @param ***REMOVED***String***REMOVED*** name of the collection
 * @param ***REMOVED***Object***REMOVED*** [options] optional collection options
 * @return ***REMOVED***Collection***REMOVED*** collection instance
 * @api public
 */

Connection.prototype.collection = function(name, options) ***REMOVED***
  if (!(name in this.collections)) ***REMOVED***
    this.collections[name] = new Collection(name, this, options);
  ***REMOVED***
  return this.collections[name];
***REMOVED***;

/**
 * Defines or retrieves a model.
 *
 *     var mongoose = require('mongoose');
 *     var db = mongoose.createConnection(..);
 *     db.model('Venue', new Schema(..));
 *     var Ticket = db.model('Ticket', new Schema(..));
 *     var Venue = db.model('Venue');
 *
 * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._
 *
 * ####Example:
 *
 *     var schema = new Schema(***REMOVED*** name: String ***REMOVED***, ***REMOVED*** collection: 'actor' ***REMOVED***);
 *
 *     // or
 *
 *     schema.set('collection', 'actor');
 *
 *     // or
 *
 *     var collectionName = 'actor'
 *     var M = conn.model('Actor', schema, collectionName)
 *
 * @param ***REMOVED***String***REMOVED*** name the model name
 * @param ***REMOVED***Schema***REMOVED*** [schema] a schema. necessary when defining a model
 * @param ***REMOVED***String***REMOVED*** [collection] name of mongodb collection (optional) if not given it will be induced from model name
 * @see Mongoose#model #index_Mongoose-model
 * @return ***REMOVED***Model***REMOVED*** The compiled model
 * @api public
 */

Connection.prototype.model = function(name, schema, collection) ***REMOVED***
  // collection name discovery
  if (typeof schema === 'string') ***REMOVED***
    collection = schema;
    schema = false;
  ***REMOVED***

  if (utils.isObject(schema) && !schema.instanceOfSchema) ***REMOVED***
    schema = new Schema(schema);
  ***REMOVED***
  if (schema && !schema.instanceOfSchema) ***REMOVED***
    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +
      'schema or a POJO');
  ***REMOVED***

  if (this.models[name] && !collection) ***REMOVED***
    // model exists but we are not subclassing with custom collection
    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) ***REMOVED***
      throw new MongooseError.OverwriteModelError(name);
    ***REMOVED***
    return this.models[name];
  ***REMOVED***

  var opts = ***REMOVED***cache: false, connection: this***REMOVED***;
  var model;

  if (schema && schema.instanceOfSchema) ***REMOVED***
    // compile a model
    model = this.base.model(name, schema, collection, opts);

    // only the first model with this name is cached to allow
    // for one-offs with custom collection names etc.
    if (!this.models[name]) ***REMOVED***
      this.models[name] = model;
    ***REMOVED***

    model.init();
    return model;
  ***REMOVED***

  if (this.models[name] && collection) ***REMOVED***
    // subclassing current model with alternate collection
    model = this.models[name];
    schema = model.prototype.schema;
    var sub = model.__subclass(this, schema, collection);
    // do not cache the sub model
    return sub;
  ***REMOVED***

  // lookup model in mongoose module
  model = this.base.models[name];

  if (!model) ***REMOVED***
    throw new MongooseError.MissingSchemaError(name);
  ***REMOVED***

  if (this === model.prototype.db
      && (!collection || collection === model.collection.name)) ***REMOVED***
    // model already uses this connection.

    // only the first model with this name is cached to allow
    // for one-offs with custom collection names etc.
    if (!this.models[name]) ***REMOVED***
      this.models[name] = model;
    ***REMOVED***

    return model;
  ***REMOVED***
  this.models[name] = model.__subclass(this, schema, collection);
  return this.models[name];
***REMOVED***;

/**
 * Returns an array of model names created on this connection.
 * @api public
 * @return ***REMOVED***Array***REMOVED***
 */

Connection.prototype.modelNames = function() ***REMOVED***
  return Object.keys(this.models);
***REMOVED***;

/**
 * @brief Returns if the connection requires authentication after it is opened. Generally if a
 * username and password are both provided than authentication is needed, but in some cases a
 * password is not required.
 * @api private
 * @return ***REMOVED***Boolean***REMOVED*** true if the connection should be authenticated after it is opened, otherwise false.
 */
Connection.prototype.shouldAuthenticate = function() ***REMOVED***
  return (this.user !== null && this.user !== void 0) &&
      ((this.pass !== null || this.pass !== void 0) || this.authMechanismDoesNotRequirePassword());
***REMOVED***;

/**
 * @brief Returns a boolean value that specifies if the current authentication mechanism needs a
 * password to authenticate according to the auth objects passed into the open/openSet methods.
 * @api private
 * @return ***REMOVED***Boolean***REMOVED*** true if the authentication mechanism specified in the options object requires
 *  a password, otherwise false.
 */
Connection.prototype.authMechanismDoesNotRequirePassword = function() ***REMOVED***
  if (this.options && this.options.auth) ***REMOVED***
    return authMechanismsWhichDontRequirePassword.indexOf(this.options.auth.authMechanism) >= 0;
  ***REMOVED***
  return true;
***REMOVED***;

/**
 * @brief Returns a boolean value that specifies if the provided objects object provides enough
 * data to authenticate with. Generally this is true if the username and password are both specified
 * but in some authentication methods, a password is not required for authentication so only a username
 * is required.
 * @param ***REMOVED***Object***REMOVED*** [options] the options object passed into the open/openSet methods.
 * @api private
 * @return ***REMOVED***Boolean***REMOVED*** true if the provided options object provides enough data to authenticate with,
 *   otherwise false.
 */
Connection.prototype.optionsProvideAuthenticationData = function(options) ***REMOVED***
  return (options) &&
      (options.user) &&
      ((options.pass) || this.authMechanismDoesNotRequirePassword());
***REMOVED***;

/*!
 * Module exports.
 */

Connection.STATES = STATES;
module.exports = Connection;
