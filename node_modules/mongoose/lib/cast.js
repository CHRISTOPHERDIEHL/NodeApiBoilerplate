/*!
 * Module dependencies.
 */

var StrictModeError = require('./error/strict');
var Types = require('./schema/index');
var utils = require('./utils');

var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];

/**
 * Handles internal casting for queries
 *
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** obj Object to cast
 * @param ***REMOVED***Object***REMOVED*** options the query options
 * @api private
 */
module.exports = function cast(schema, obj, options) ***REMOVED***
  var paths = Object.keys(obj),
      i = paths.length,
      _keys,
      any$conditionals,
      schematype,
      nested,
      path,
      type,
      val;

  while (i--) ***REMOVED***
    path = paths[i];
    val = obj[path];

    if (path === '$or' || path === '$nor' || path === '$and') ***REMOVED***
      var k = val.length;

      while (k--) ***REMOVED***
        val[k] = cast(schema, val[k]);
      ***REMOVED***
    ***REMOVED*** else if (path === '$where') ***REMOVED***
      type = typeof val;

      if (type !== 'string' && type !== 'function') ***REMOVED***
        throw new Error('Must have a string or function for $where');
      ***REMOVED***

      if (type === 'function') ***REMOVED***
        obj[path] = val.toString();
      ***REMOVED***

      continue;
    ***REMOVED*** else if (path === '$elemMatch') ***REMOVED***
      val = cast(schema, val);
    ***REMOVED*** else ***REMOVED***
      if (!schema) ***REMOVED***
        // no casting for Mixed types
        continue;
      ***REMOVED***

      schematype = schema.path(path);

      if (!schematype) ***REMOVED***
        // Handle potential embedded array queries
        var split = path.split('.'),
            j = split.length,
            pathFirstHalf,
            pathLastHalf,
            remainingConds;

        // Find the part of the var path that is a path of the Schema
        while (j--) ***REMOVED***
          pathFirstHalf = split.slice(0, j).join('.');
          schematype = schema.path(pathFirstHalf);
          if (schematype) ***REMOVED***
            break;
          ***REMOVED***
        ***REMOVED***

        // If a substring of the input path resolves to an actual real path...
        if (schematype) ***REMOVED***
          // Apply the casting; similar code for $elemMatch in schema/array.js
          if (schematype.caster && schematype.caster.schema) ***REMOVED***
            remainingConds = ***REMOVED******REMOVED***;
            pathLastHalf = split.slice(j).join('.');
            remainingConds[pathLastHalf] = val;
            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];
          ***REMOVED*** else ***REMOVED***
            obj[path] = val;
          ***REMOVED***
          continue;
        ***REMOVED***

        if (utils.isObject(val)) ***REMOVED***
          // handle geo schemas that use object notation
          // ***REMOVED*** loc: ***REMOVED*** long: Number, lat: Number ***REMOVED***

          var geo = '';
          if (val.$near) ***REMOVED***
            geo = '$near';
          ***REMOVED*** else if (val.$nearSphere) ***REMOVED***
            geo = '$nearSphere';
          ***REMOVED*** else if (val.$within) ***REMOVED***
            geo = '$within';
          ***REMOVED*** else if (val.$geoIntersects) ***REMOVED***
            geo = '$geoIntersects';
          ***REMOVED*** else if (val.$geoWithin) ***REMOVED***
            geo = '$geoWithin';
          ***REMOVED***

          if (geo) ***REMOVED***
            var numbertype = new Types.Number('__QueryCasting__');
            var value = val[geo];

            if (val.$maxDistance != null) ***REMOVED***
              val.$maxDistance = numbertype.castForQuery(val.$maxDistance);
            ***REMOVED***
            if (val.$minDistance != null) ***REMOVED***
              val.$minDistance = numbertype.castForQuery(val.$minDistance);
            ***REMOVED***

            if (geo === '$within') ***REMOVED***
              var withinType = value.$center
                  || value.$centerSphere
                  || value.$box
                  || value.$polygon;

              if (!withinType) ***REMOVED***
                throw new Error('Bad $within paramater: ' + JSON.stringify(val));
              ***REMOVED***

              value = withinType;
            ***REMOVED*** else if (geo === '$near' &&
                typeof value.type === 'string' && Array.isArray(value.coordinates)) ***REMOVED***
              // geojson; cast the coordinates
              value = value.coordinates;
            ***REMOVED*** else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&
                value.$geometry && typeof value.$geometry.type === 'string' &&
                Array.isArray(value.$geometry.coordinates)) ***REMOVED***
              if (value.$maxDistance != null) ***REMOVED***
                value.$maxDistance = numbertype.castForQuery(value.$maxDistance);
              ***REMOVED***
              if (value.$minDistance != null) ***REMOVED***
                value.$minDistance = numbertype.castForQuery(value.$minDistance);
              ***REMOVED***
              if (utils.isMongooseObject(value.$geometry)) ***REMOVED***
                value.$geometry = value.$geometry.toObject(***REMOVED***
                  transform: false,
                  virtuals: false
                ***REMOVED***);
              ***REMOVED***
              value = value.$geometry.coordinates;
            ***REMOVED*** else if (geo === '$geoWithin') ***REMOVED***
              if (value.$geometry) ***REMOVED***
                if (utils.isMongooseObject(value.$geometry)) ***REMOVED***
                  value.$geometry = value.$geometry.toObject(***REMOVED*** virtuals: false ***REMOVED***);
                ***REMOVED***
                var geoWithinType = value.$geometry.type;
                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) ***REMOVED***
                  throw new Error('Invalid geoJSON type for $geoWithin "' +
                    geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                ***REMOVED***
                value = value.$geometry.coordinates;
              ***REMOVED*** else ***REMOVED***
                value = value.$box || value.$polygon || value.$center ||
                  value.$centerSphere;
                if (utils.isMongooseObject(value)) ***REMOVED***
                  value = value.toObject(***REMOVED*** virtuals: false ***REMOVED***);
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***

            _cast(value, numbertype);
          ***REMOVED***
        ***REMOVED***

        if (options && options.upsert && options.strict) ***REMOVED***
          if (options.strict === 'throw') ***REMOVED***
            throw new StrictModeError(path);
          ***REMOVED***
          throw new StrictModeError(path, 'Path "' + path + '" is not in ' +
            'schema, strict mode is `true`, and upsert is `true`.');
        ***REMOVED***
      ***REMOVED*** else if (val === null || val === undefined) ***REMOVED***
        obj[path] = null;
        continue;
      ***REMOVED*** else if (val.constructor.name === 'Object') ***REMOVED***
        any$conditionals = Object.keys(val).some(function(k) ***REMOVED***
          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';
        ***REMOVED***);

        if (!any$conditionals) ***REMOVED***
          obj[path] = schematype.castForQuery(val);
        ***REMOVED*** else ***REMOVED***
          var ks = Object.keys(val),
              $cond;

          k = ks.length;

          while (k--) ***REMOVED***
            $cond = ks[k];
            nested = val[$cond];

            if ($cond === '$exists') ***REMOVED***
              if (typeof nested !== 'boolean') ***REMOVED***
                throw new Error('$exists parameter must be Boolean');
              ***REMOVED***
              continue;
            ***REMOVED***

            if ($cond === '$not') ***REMOVED***
              if (nested && schematype && !schematype.caster) ***REMOVED***
                _keys = Object.keys(nested);
                if (_keys.length && _keys[0].charAt(0) === '$') ***REMOVED***
                  for (var key in nested) ***REMOVED***
                    nested[key] = schematype.castForQuery(key, nested[key]);
                  ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                  val[$cond] = schematype.castForQuery($cond, nested);
                ***REMOVED***
                continue;
              ***REMOVED***
              cast(schematype.caster ? schematype.caster.schema : schema, nested);
            ***REMOVED*** else ***REMOVED***
              val[$cond] = schematype.castForQuery($cond, nested);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        obj[path] = schematype.castForQuery(val);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return obj;
***REMOVED***;

function _cast(val, numbertype) ***REMOVED***
  if (Array.isArray(val)) ***REMOVED***
    val.forEach(function(item, i) ***REMOVED***
      if (Array.isArray(item) || utils.isObject(item)) ***REMOVED***
        return _cast(item, numbertype);
      ***REMOVED***
      val[i] = numbertype.castForQuery(item);
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    var nearKeys = Object.keys(val);
    var nearLen = nearKeys.length;
    while (nearLen--) ***REMOVED***
      var nkey = nearKeys[nearLen];
      var item = val[nkey];
      if (Array.isArray(item) || utils.isObject(item)) ***REMOVED***
        _cast(item, numbertype);
        val[nkey] = item;
      ***REMOVED*** else ***REMOVED***
        val[nkey] = numbertype.castForQuery(item);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
