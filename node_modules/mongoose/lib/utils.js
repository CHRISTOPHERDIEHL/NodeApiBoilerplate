/*!
 * Module dependencies.
 */

var ObjectId = require('./types/objectid');
var cloneRegExp = require('regexp-clone');
var sliced = require('sliced');
var mpath = require('mpath');
var ms = require('ms');
var MongooseBuffer;
var MongooseArray;
var Document;

/*!
 * Produces a collection name from model `name`.
 *
 * @param ***REMOVED***String***REMOVED*** name a model name
 * @return ***REMOVED***String***REMOVED*** a collection name
 * @api private
 */

exports.toCollectionName = function(name, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  if (name === 'system.profile') ***REMOVED***
    return name;
  ***REMOVED***
  if (name === 'system.indexes') ***REMOVED***
    return name;
  ***REMOVED***
  if (options.pluralization === false) ***REMOVED***
    return name;
  ***REMOVED***
  return pluralize(name.toLowerCase());
***REMOVED***;

/**
 * Pluralization rules.
 *
 * These rules are applied while processing the argument to `toCollectionName`.
 *
 * @deprecated remove in 4.x gh-1350
 */

exports.pluralization = [
  [/(m)an$/gi, '$1en'],
  [/(pe)rson$/gi, '$1ople'],
  [/(child)$/gi, '$1ren'],
  [/^(ox)$/gi, '$1en'],
  [/(ax|test)is$/gi, '$1es'],
  [/(octop|vir)us$/gi, '$1i'],
  [/(alias|status)$/gi, '$1es'],
  [/(bu)s$/gi, '$1ses'],
  [/(buffal|tomat|potat)o$/gi, '$1oes'],
  [/([ti])um$/gi, '$1a'],
  [/sis$/gi, 'ses'],
  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],
  [/(hive)$/gi, '$1s'],
  [/([^aeiouy]|qu)y$/gi, '$1ies'],
  [/(x|ch|ss|sh)$/gi, '$1es'],
  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],
  [/([m|l])ouse$/gi, '$1ice'],
  [/(kn|w|l)ife$/gi, '$1ives'],
  [/(quiz)$/gi, '$1zes'],
  [/s$/gi, 's'],
  [/([^a-z])$/, '$1'],
  [/$/gi, 's']
];
var rules = exports.pluralization;

/**
 * Uncountable words.
 *
 * These words are applied while processing the argument to `toCollectionName`.
 * @api public
 */

exports.uncountables = [
  'advice',
  'energy',
  'excretion',
  'digestion',
  'cooperation',
  'health',
  'justice',
  'labour',
  'machinery',
  'equipment',
  'information',
  'pollution',
  'sewage',
  'paper',
  'money',
  'species',
  'series',
  'rain',
  'rice',
  'fish',
  'sheep',
  'moose',
  'deer',
  'news',
  'expertise',
  'status',
  'media'
];
var uncountables = exports.uncountables;

/*!
 * Pluralize function.
 *
 * @author TJ Holowaychuk (extracted from _ext.js_)
 * @param ***REMOVED***String***REMOVED*** string to pluralize
 * @api private
 */

function pluralize(str) ***REMOVED***
  var found;
  if (!~uncountables.indexOf(str.toLowerCase())) ***REMOVED***
    found = rules.filter(function(rule) ***REMOVED***
      return str.match(rule[0]);
    ***REMOVED***);
    if (found[0]) ***REMOVED***
      return str.replace(found[0][0], found[0][1]);
    ***REMOVED***
  ***REMOVED***
  return str;
***REMOVED***

/*!
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param ***REMOVED***any***REMOVED*** a a value to compare to `b`
 * @param ***REMOVED***any***REMOVED*** b a value to compare to `a`
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

exports.deepEqual = function deepEqual(a, b) ***REMOVED***
  if (a === b) ***REMOVED***
    return true;
  ***REMOVED***

  if (a instanceof Date && b instanceof Date) ***REMOVED***
    return a.getTime() === b.getTime();
  ***REMOVED***

  if (a instanceof ObjectId && b instanceof ObjectId) ***REMOVED***
    return a.toString() === b.toString();
  ***REMOVED***

  if (a instanceof RegExp && b instanceof RegExp) ***REMOVED***
    return a.source === b.source &&
        a.ignoreCase === b.ignoreCase &&
        a.multiline === b.multiline &&
        a.global === b.global;
  ***REMOVED***

  if (typeof a !== 'object' && typeof b !== 'object') ***REMOVED***
    return a == b;
  ***REMOVED***

  if (a === null || b === null || a === undefined || b === undefined) ***REMOVED***
    return false;
  ***REMOVED***

  if (a.prototype !== b.prototype) ***REMOVED***
    return false;
  ***REMOVED***

  // Handle MongooseNumbers
  if (a instanceof Number && b instanceof Number) ***REMOVED***
    return a.valueOf() === b.valueOf();
  ***REMOVED***

  if (Buffer.isBuffer(a)) ***REMOVED***
    return exports.buffer.areEqual(a, b);
  ***REMOVED***

  if (isMongooseObject(a)) ***REMOVED***
    a = a.toObject();
  ***REMOVED***
  if (isMongooseObject(b)) ***REMOVED***
    b = b.toObject();
  ***REMOVED***

  try ***REMOVED***
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  ***REMOVED*** catch (e) ***REMOVED***
    // happens when one is a string literal and the other isn't
    return false;
  ***REMOVED***

  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) ***REMOVED***
    return false;
  ***REMOVED***

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();

  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
    if (ka[i] !== kb[i]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  // equivalent values for every corresponding key, and
  // ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
    key = ka[i];
    if (!deepEqual(a[key], b[key])) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***;

/*!
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions are never cloned.
 *
 * @param ***REMOVED***Object***REMOVED*** obj the object to clone
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED*** the cloned object
 * @api private
 */

exports.clone = function clone(obj, options) ***REMOVED***
  if (obj === undefined || obj === null) ***REMOVED***
    return obj;
  ***REMOVED***

  if (Array.isArray(obj)) ***REMOVED***
    return cloneArray(obj, options);
  ***REMOVED***

  if (isMongooseObject(obj)) ***REMOVED***
    if (options && options.json && typeof obj.toJSON === 'function') ***REMOVED***
      return obj.toJSON(options);
    ***REMOVED***
    return obj.toObject(options);
  ***REMOVED***

  if (obj.constructor) ***REMOVED***
    switch (exports.getFunctionName(obj.constructor)) ***REMOVED***
      case 'Object':
        return cloneObject(obj, options);
      case 'Date':
        return new obj.constructor(+obj);
      case 'RegExp':
        return cloneRegExp(obj);
      default:
        // ignore
        break;
    ***REMOVED***
  ***REMOVED***

  if (obj instanceof ObjectId) ***REMOVED***
    return new ObjectId(obj.id);
  ***REMOVED***

  if (!obj.constructor && exports.isObject(obj)) ***REMOVED***
    // object created with Object.create(null)
    return cloneObject(obj, options);
  ***REMOVED***

  if (obj.valueOf) ***REMOVED***
    return obj.valueOf();
  ***REMOVED***
***REMOVED***;
var clone = exports.clone;

/*!
 * ignore
 */

function cloneObject(obj, options) ***REMOVED***
  var retainKeyOrder = options && options.retainKeyOrder,
      minimize = options && options.minimize,
      ret = ***REMOVED******REMOVED***,
      hasKeys,
      keys,
      val,
      k,
      i;

  if (retainKeyOrder) ***REMOVED***
    for (k in obj) ***REMOVED***
      val = clone(obj[k], options);

      if (!minimize || (typeof val !== 'undefined')) ***REMOVED***
        hasKeys || (hasKeys = true);
        ret[k] = val;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // faster

    keys = Object.keys(obj);
    i = keys.length;

    while (i--) ***REMOVED***
      k = keys[i];
      val = clone(obj[k], options);

      if (!minimize || (typeof val !== 'undefined')) ***REMOVED***
        if (!hasKeys) ***REMOVED***
          hasKeys = true;
        ***REMOVED***
        ret[k] = val;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return minimize
      ? hasKeys && ret
      : ret;
***REMOVED***

function cloneArray(arr, options) ***REMOVED***
  var ret = [];
  for (var i = 0, l = arr.length; i < l; i++) ***REMOVED***
    ret.push(clone(arr[i], options));
  ***REMOVED***
  return ret;
***REMOVED***

/*!
 * Shallow copies defaults into options.
 *
 * @param ***REMOVED***Object***REMOVED*** defaults
 * @param ***REMOVED***Object***REMOVED*** options
 * @return ***REMOVED***Object***REMOVED*** the merged object
 * @api private
 */

exports.options = function(defaults, options) ***REMOVED***
  var keys = Object.keys(defaults),
      i = keys.length,
      k;

  options = options || ***REMOVED******REMOVED***;

  while (i--) ***REMOVED***
    k = keys[i];
    if (!(k in options)) ***REMOVED***
      options[k] = defaults[k];
    ***REMOVED***
  ***REMOVED***

  return options;
***REMOVED***;

/*!
 * Generates a random string
 *
 * @api private
 */

exports.random = function() ***REMOVED***
  return Math.random().toString().substr(3);
***REMOVED***;

/*!
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param ***REMOVED***Object***REMOVED*** to
 * @param ***REMOVED***Object***REMOVED*** from
 * @api private
 */

exports.merge = function merge(to, from, options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  var keys = Object.keys(from);
  var i = 0;
  var len = keys.length;
  var key;

  if (options.retainKeyOrder) ***REMOVED***
    while (i < len) ***REMOVED***
      key = keys[i++];
      if (typeof to[key] === 'undefined') ***REMOVED***
        to[key] = from[key];
      ***REMOVED*** else if (exports.isObject(from[key])) ***REMOVED***
        merge(to[key], from[key]);
      ***REMOVED*** else if (options.overwrite) ***REMOVED***
        to[key] = from[key];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    while (len--) ***REMOVED***
      key = keys[len];
      if (typeof to[key] === 'undefined') ***REMOVED***
        to[key] = from[key];
      ***REMOVED*** else if (exports.isObject(from[key])) ***REMOVED***
        merge(to[key], from[key]);
      ***REMOVED*** else if (options.overwrite) ***REMOVED***
        to[key] = from[key];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/*!
 * toString helper
 */

var toString = Object.prototype.toString;

/*!
 * Applies toObject recursively.
 *
 * @param ***REMOVED***Document|Array|Object***REMOVED*** obj
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

exports.toObject = function toObject(obj) ***REMOVED***
  Document || (Document = require('./document'));
  var ret;

  if (exports.isNullOrUndefined(obj)) ***REMOVED***
    return obj;
  ***REMOVED***

  if (obj instanceof Document) ***REMOVED***
    return obj.toObject();
  ***REMOVED***

  if (Array.isArray(obj)) ***REMOVED***
    ret = [];

    for (var i = 0, len = obj.length; i < len; ++i) ***REMOVED***
      ret.push(toObject(obj[i]));
    ***REMOVED***

    return ret;
  ***REMOVED***

  if ((obj.constructor && exports.getFunctionName(obj.constructor) === 'Object') ||
      (!obj.constructor && exports.isObject(obj))) ***REMOVED***
    ret = ***REMOVED******REMOVED***;

    for (var k in obj) ***REMOVED***
      ret[k] = toObject(obj[k]);
    ***REMOVED***

    return ret;
  ***REMOVED***

  return obj;
***REMOVED***;

/*!
 * Determines if `arg` is an object.
 *
 * @param ***REMOVED***Object|Array|String|Function|RegExp|any***REMOVED*** arg
 * @api private
 * @return ***REMOVED***Boolean***REMOVED***
 */

exports.isObject = function(arg) ***REMOVED***
  if (Buffer.isBuffer(arg)) ***REMOVED***
    return true;
  ***REMOVED***
  return toString.call(arg) === '[object Object]';
***REMOVED***;

/*!
 * A faster Array.prototype.slice.call(arguments) alternative
 * @api private
 */

exports.args = sliced;

/*!
 * process.nextTick helper.
 *
 * Wraps `callback` in a try/catch + nextTick.
 *
 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @api private
 */

exports.tick = function tick(callback) ***REMOVED***
  if (typeof callback !== 'function') ***REMOVED***
    return;
  ***REMOVED***
  return function() ***REMOVED***
    try ***REMOVED***
      callback.apply(this, arguments);
    ***REMOVED*** catch (err) ***REMOVED***
      // only nextTick on err to get out of
      // the event loop and avoid state corruption.
      process.nextTick(function() ***REMOVED***
        throw err;
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;

/*!
 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
 *
 * This is for compatibility with libs like Date.js which do foolish things to Natives.
 *
 * @param ***REMOVED***any***REMOVED*** v
 * @api private
 */

exports.isMongooseObject = function(v) ***REMOVED***
  Document || (Document = require('./document'));
  MongooseArray || (MongooseArray = require('./types').Array);
  MongooseBuffer || (MongooseBuffer = require('./types').Buffer);

  return v instanceof Document ||
      (v && v.isMongooseArray) ||
      (v && v.isMongooseBuffer);
***REMOVED***;
var isMongooseObject = exports.isMongooseObject;

/*!
 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
 *
 * @param ***REMOVED***Object***REMOVED*** object
 * @api private
 */

exports.expires = function expires(object) ***REMOVED***
  if (!(object && object.constructor.name === 'Object')) ***REMOVED***
    return;
  ***REMOVED***
  if (!('expires' in object)) ***REMOVED***
    return;
  ***REMOVED***

  var when;
  if (typeof object.expires !== 'string') ***REMOVED***
    when = object.expires;
  ***REMOVED*** else ***REMOVED***
    when = Math.round(ms(object.expires) / 1000);
  ***REMOVED***
  object.expireAfterSeconds = when;
  delete object.expires;
***REMOVED***;

/*!
 * Populate options constructor
 */

function PopulateOptions(path, select, match, options, model, subPopulate) ***REMOVED***
  this.path = path;
  this.match = match;
  this.select = select;
  this.options = options;
  this.model = model;
  if (typeof subPopulate === 'object') ***REMOVED***
    this.populate = subPopulate;
  ***REMOVED***
  this._docs = ***REMOVED******REMOVED***;
***REMOVED***

// make it compatible with utils.clone
PopulateOptions.prototype.constructor = Object;

// expose
exports.PopulateOptions = PopulateOptions;

/*!
 * populate helper
 */

exports.populate = function populate(path, select, model, match, options, subPopulate) ***REMOVED***
  // The order of select/conditions args is opposite Model.find but
  // necessary to keep backward compatibility (select could be
  // an array, string, or object literal).

  // might have passed an object specifying all arguments
  if (arguments.length === 1) ***REMOVED***
    if (path instanceof PopulateOptions) ***REMOVED***
      return [path];
    ***REMOVED***

    if (Array.isArray(path)) ***REMOVED***
      return path.map(function(o) ***REMOVED***
        return exports.populate(o)[0];
      ***REMOVED***);
    ***REMOVED***

    if (exports.isObject(path)) ***REMOVED***
      match = path.match;
      options = path.options;
      select = path.select;
      model = path.model;
      subPopulate = path.populate;
      path = path.path;
    ***REMOVED***
  ***REMOVED*** else if (typeof model !== 'string' && typeof model !== 'function') ***REMOVED***
    options = match;
    match = model;
    model = undefined;
  ***REMOVED***

  if (typeof path !== 'string') ***REMOVED***
    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');
  ***REMOVED***

  if (typeof subPopulate === 'object') ***REMOVED***
    subPopulate = exports.populate(subPopulate);
  ***REMOVED***

  var ret = [];
  var paths = path.split(' ');
  options = exports.clone(options, ***REMOVED*** retainKeyOrder: true ***REMOVED***);
  for (var i = 0; i < paths.length; ++i) ***REMOVED***
    ret.push(new PopulateOptions(paths[i], select, match, options, model, subPopulate));
  ***REMOVED***

  return ret;
***REMOVED***;

/*!
 * Return the value of `obj` at the given `path`.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Object***REMOVED*** obj
 */

exports.getValue = function(path, obj, map) ***REMOVED***
  return mpath.get(path, obj, '_doc', map);
***REMOVED***;

/*!
 * Sets the value of `obj` at the given `path`.
 *
 * @param ***REMOVED***String***REMOVED*** path
 * @param ***REMOVED***Anything***REMOVED*** val
 * @param ***REMOVED***Object***REMOVED*** obj
 */

exports.setValue = function(path, val, obj, map) ***REMOVED***
  mpath.set(path, val, obj, '_doc', map);
***REMOVED***;

/*!
 * Returns an array of values from object `o`.
 *
 * @param ***REMOVED***Object***REMOVED*** o
 * @return ***REMOVED***Array***REMOVED***
 * @private
 */

exports.object = ***REMOVED******REMOVED***;
exports.object.vals = function vals(o) ***REMOVED***
  var keys = Object.keys(o),
      i = keys.length,
      ret = [];

  while (i--) ***REMOVED***
    ret.push(o[keys[i]]);
  ***REMOVED***

  return ret;
***REMOVED***;

/*!
 * @see exports.options
 */

exports.object.shallowCopy = exports.options;

/*!
 * Safer helper for hasOwnProperty checks
 *
 * @param ***REMOVED***Object***REMOVED*** obj
 * @param ***REMOVED***String***REMOVED*** prop
 */

var hop = Object.prototype.hasOwnProperty;
exports.object.hasOwnProperty = function(obj, prop) ***REMOVED***
  return hop.call(obj, prop);
***REMOVED***;

/*!
 * Determine if `val` is null or undefined
 *
 * @return ***REMOVED***Boolean***REMOVED***
 */

exports.isNullOrUndefined = function(val) ***REMOVED***
  return val === null || val === undefined;
***REMOVED***;

/*!
 * ignore
 */

exports.array = ***REMOVED******REMOVED***;

/*!
 * Flattens an array.
 *
 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @param ***REMOVED***Function***REMOVED*** [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsey value, the item will not be included in the results.
 * @return ***REMOVED***Array***REMOVED***
 * @private
 */

exports.array.flatten = function flatten(arr, filter, ret) ***REMOVED***
  ret || (ret = []);

  arr.forEach(function(item) ***REMOVED***
    if (Array.isArray(item)) ***REMOVED***
      flatten(item, filter, ret);
    ***REMOVED*** else ***REMOVED***
      if (!filter || filter(item)) ***REMOVED***
        ret.push(item);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  return ret;
***REMOVED***;

/*!
 * Removes duplicate values from an array
 *
 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
 *    => [ObjectId("550988ba0c19d57f697dc45e")]
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @return ***REMOVED***Array***REMOVED***
 * @private
 */

exports.array.unique = function(arr) ***REMOVED***
  var primitives = ***REMOVED******REMOVED***;
  var ids = ***REMOVED******REMOVED***;
  var ret = [];
  var length = arr.length;
  for (var i = 0; i < length; ++i) ***REMOVED***
    if (typeof arr[i] === 'number' || typeof arr[i] === 'string') ***REMOVED***
      if (primitives[arr[i]]) ***REMOVED***
        continue;
      ***REMOVED***
      ret.push(arr[i]);
      primitives[arr[i]] = true;
    ***REMOVED*** else if (arr[i] instanceof ObjectId) ***REMOVED***
      if (ids[arr[i].toString()]) ***REMOVED***
        continue;
      ***REMOVED***
      ret.push(arr[i]);
      ids[arr[i].toString()] = true;
    ***REMOVED*** else ***REMOVED***
      ret.push(arr[i]);
    ***REMOVED***
  ***REMOVED***

  return ret;
***REMOVED***;

/*!
 * Determines if two buffers are equal.
 *
 * @param ***REMOVED***Buffer***REMOVED*** a
 * @param ***REMOVED***Object***REMOVED*** b
 */

exports.buffer = ***REMOVED******REMOVED***;
exports.buffer.areEqual = function(a, b) ***REMOVED***
  if (!Buffer.isBuffer(a)) ***REMOVED***
    return false;
  ***REMOVED***
  if (!Buffer.isBuffer(b)) ***REMOVED***
    return false;
  ***REMOVED***
  if (a.length !== b.length) ***REMOVED***
    return false;
  ***REMOVED***
  for (var i = 0, len = a.length; i < len; ++i) ***REMOVED***
    if (a[i] !== b[i]) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***
  return true;
***REMOVED***;

exports.getFunctionName = function(fn) ***REMOVED***
  if (fn.name) ***REMOVED***
    return fn.name;
  ***REMOVED***
  return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
***REMOVED***;

exports.decorate = function(destination, source) ***REMOVED***
  for (var key in source) ***REMOVED***
    destination[key] = source[key];
  ***REMOVED***
***REMOVED***;

/**
 * merges to with a copy of from
 *
 * @param ***REMOVED***Object***REMOVED*** to
 * @param ***REMOVED***Object***REMOVED*** fromObj
 * @api private
 */

exports.mergeClone = function(to, fromObj) ***REMOVED***
  var keys = Object.keys(fromObj);
  var len = keys.length;
  var i = 0;
  var key;

  while (i < len) ***REMOVED***
    key = keys[i++];
    if (typeof to[key] === 'undefined') ***REMOVED***
      // make sure to retain key order here because of a bug handling the $each
      // operator in mongodb 2.4.4
      to[key] = exports.clone(fromObj[key], ***REMOVED***retainKeyOrder: 1***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      if (exports.isObject(fromObj[key])) ***REMOVED***
        var obj = fromObj[key];
        if (isMongooseObject(fromObj[key]) && !fromObj[key].isMongooseBuffer) ***REMOVED***
          obj = obj.toObject(***REMOVED*** transform: false, virtuals: false ***REMOVED***);
        ***REMOVED***
        if (fromObj[key].isMongooseBuffer) ***REMOVED***
          obj = new Buffer(obj);
        ***REMOVED***
        exports.mergeClone(to[key], obj);
      ***REMOVED*** else ***REMOVED***
        // make sure to retain key order here because of a bug handling the
        // $each operator in mongodb 2.4.4
        to[key] = exports.clone(fromObj[key], ***REMOVED***retainKeyOrder: 1***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

/**
 * Executes a function on each element of an array (like _.each)
 *
 * @param ***REMOVED***Array***REMOVED*** arr
 * @param ***REMOVED***Function***REMOVED*** fn
 * @api private
 */

exports.each = function(arr, fn) ***REMOVED***
  for (var i = 0; i < arr.length; ++i) ***REMOVED***
    fn(arr[i]);
  ***REMOVED***
***REMOVED***;
