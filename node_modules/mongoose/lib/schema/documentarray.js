/* eslint no-empty: 1 */

/*!
 * Module dependencies.
 */

var ArrayType = require('./array');
var CastError = require('../error/cast');
var MongooseDocumentArray = require('../types/documentarray');
var SchemaType = require('../schematype');
var Subdocument = require('../types/embedded');
var util = require('util');

/**
 * SubdocsArray SchemaType constructor
 *
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***Object***REMOVED*** options
 * @inherits SchemaArray
 * @api public
 */

function DocumentArray(key, schema, options) ***REMOVED***
  // compile an embedded document for this schema
  function EmbeddedDocument() ***REMOVED***
    Subdocument.apply(this, arguments);
  ***REMOVED***

  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);
  EmbeddedDocument.prototype.$__setSchema(schema);
  EmbeddedDocument.schema = schema;

  // apply methods
  for (var i in schema.methods) ***REMOVED***
    EmbeddedDocument.prototype[i] = schema.methods[i];
  ***REMOVED***

  // apply statics
  for (i in schema.statics) ***REMOVED***
    EmbeddedDocument[i] = schema.statics[i];
  ***REMOVED***

  EmbeddedDocument.options = options;

  ArrayType.call(this, key, EmbeddedDocument, options);

  this.schema = schema;
  this.$isMongooseDocumentArray = true;
  var fn = this.defaultValue;

  if (!('defaultValue' in this) || fn !== void 0) ***REMOVED***
    this.default(function() ***REMOVED***
      var arr = fn.call(this);
      if (!Array.isArray(arr)) ***REMOVED***
        arr = [arr];
      ***REMOVED***
      // Leave it up to `cast()` to convert this to a documentarray
      return arr;
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
DocumentArray.schemaName = 'DocumentArray';

/*!
 * Inherits from ArrayType.
 */
DocumentArray.prototype = Object.create(ArrayType.prototype);
DocumentArray.prototype.constructor = DocumentArray;

/**
 * Performs local validations first, then validations on each embedded doc
 *
 * @api private
 */

DocumentArray.prototype.doValidate = function(array, fn, scope, options) ***REMOVED***
  var _this = this;
  SchemaType.prototype.doValidate.call(this, array, function(err) ***REMOVED***
    if (err) ***REMOVED***
      return fn(err);
    ***REMOVED***

    var count = array && array.length;
    var error;

    if (!count) ***REMOVED***
      return fn();
    ***REMOVED***
    if (options && options.updateValidator) ***REMOVED***
      return fn();
    ***REMOVED***

    // handle sparse arrays, do not use array.forEach which does not
    // iterate over sparse elements yet reports array.length including
    // them :(

    function callback(err) ***REMOVED***
      if (err) ***REMOVED***
        error = err;
      ***REMOVED***
      --count || fn(error);
    ***REMOVED***

    for (var i = 0, len = count; i < len; ++i) ***REMOVED***
      // sidestep sparse entries
      var doc = array[i];
      if (!doc) ***REMOVED***
        --count || fn(error);
        continue;
      ***REMOVED***

      // If you set the array index directly, the doc might not yet be
      // a full fledged mongoose subdoc, so make it into one.
      if (!(doc instanceof Subdocument)) ***REMOVED***
        doc = array[i] = new _this.casterConstructor(doc, array, undefined,
            undefined, i);
      ***REMOVED***

      // HACK: use $__original_validate to avoid promises so bluebird doesn't
      // complain
      if (doc.$__original_validate) ***REMOVED***
        doc.$__original_validate(***REMOVED***__noPromise: true***REMOVED***, callback);
      ***REMOVED*** else ***REMOVED***
        doc.validate(***REMOVED***__noPromise: true***REMOVED***, callback);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, scope);
***REMOVED***;

/**
 * Performs local validations first, then validations on each embedded doc.
 *
 * ####Note:
 *
 * This method ignores the asynchronous validators.
 *
 * @return ***REMOVED***MongooseError|undefined***REMOVED***
 * @api private
 */

DocumentArray.prototype.doValidateSync = function(array, scope) ***REMOVED***
  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
  if (schemaTypeError) ***REMOVED***
    return schemaTypeError;
  ***REMOVED***

  var count = array && array.length,
      resultError = null;

  if (!count) ***REMOVED***
    return;
  ***REMOVED***

  // handle sparse arrays, do not use array.forEach which does not
  // iterate over sparse elements yet reports array.length including
  // them :(

  for (var i = 0, len = count; i < len; ++i) ***REMOVED***
    // only first error
    if (resultError) ***REMOVED***
      break;
    ***REMOVED***
    // sidestep sparse entries
    var doc = array[i];
    if (!doc) ***REMOVED***
      continue;
    ***REMOVED***

    var subdocValidateError = doc.validateSync();

    if (subdocValidateError) ***REMOVED***
      resultError = subdocValidateError;
    ***REMOVED***
  ***REMOVED***

  return resultError;
***REMOVED***;

/**
 * Casts contents
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @param ***REMOVED***Document***REMOVED*** document that triggers the casting
 * @api private
 */

DocumentArray.prototype.cast = function(value, doc, init, prev, options) ***REMOVED***
  var selected,
      subdoc,
      i;

  if (!Array.isArray(value)) ***REMOVED***
    // gh-2442 mark whole array as modified if we're initializing a doc from
    // the db and the path isn't an array in the document
    if (!!doc && init) ***REMOVED***
      doc.markModified(this.path);
    ***REMOVED***
    return this.cast([value], doc, init, prev);
  ***REMOVED***

  if (!(value && value.isMongooseDocumentArray) &&
      (!options || !options.skipDocumentArrayCast)) ***REMOVED***
    value = new MongooseDocumentArray(value, this.path, doc);
    if (prev && prev._handlers) ***REMOVED***
      for (var key in prev._handlers) ***REMOVED***
        doc.removeListener(key, prev._handlers[key]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (value && value.isMongooseDocumentArray) ***REMOVED***
    // We need to create a new array, otherwise change tracking will
    // update the old doc (gh-4449)
    value = new MongooseDocumentArray(value, this.path, doc);
  ***REMOVED***

  i = value.length;

  while (i--) ***REMOVED***
    if (!value[i]) ***REMOVED***
      continue;
    ***REMOVED***
    // Check if the document has a different schema (re gh-3701)
    if ((value[i] instanceof Subdocument) &&
        value[i].schema !== this.casterConstructor.schema) ***REMOVED***
      value[i] = value[i].toObject(***REMOVED*** transform: false, virtuals: false ***REMOVED***);
    ***REMOVED***
    if (!(value[i] instanceof Subdocument) && value[i]) ***REMOVED***
      if (init) ***REMOVED***
        if (doc) ***REMOVED***
          selected || (selected = scopePaths(this, doc.$__.selected, init));
        ***REMOVED*** else ***REMOVED***
          selected = true;
        ***REMOVED***

        subdoc = new this.casterConstructor(null, value, true, selected, i);
        value[i] = subdoc.init(value[i]);
      ***REMOVED*** else ***REMOVED***
        if (prev && (subdoc = prev.id(value[i]._id))) ***REMOVED***
          subdoc = prev.id(value[i]._id);
        ***REMOVED***

        if (prev && subdoc) ***REMOVED***
          // handle resetting doc with existing id but differing data
          // doc.array = [***REMOVED*** doc: 'val' ***REMOVED***]
          subdoc.set(value[i]);
          // if set() is hooked it will have no return value
          // see gh-746
          value[i] = subdoc;
        ***REMOVED*** else ***REMOVED***
          try ***REMOVED***
            subdoc = new this.casterConstructor(value[i], value, undefined,
                undefined, i);
            // if set() is hooked it will have no return value
            // see gh-746
            value[i] = subdoc;
          ***REMOVED*** catch (error) ***REMOVED***
            var valueInErrorMessage = util.inspect(value[i]);
            throw new CastError('embedded', valueInErrorMessage,
              value._path, error);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return value;
***REMOVED***;

/*!
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param ***REMOVED***DocumentArray***REMOVED*** array - the array to scope `fields` paths
 * @param ***REMOVED***Object|undefined***REMOVED*** fields - the root fields selected in the query
 * @param ***REMOVED***Boolean|undefined***REMOVED*** init - if we are being created part of a query result
 */

function scopePaths(array, fields, init) ***REMOVED***
  if (!(init && fields)) ***REMOVED***
    return undefined;
  ***REMOVED***

  var path = array.path + '.',
      keys = Object.keys(fields),
      i = keys.length,
      selected = ***REMOVED******REMOVED***,
      hasKeys,
      key;

  while (i--) ***REMOVED***
    key = keys[i];
    if (key.indexOf(path) === 0) ***REMOVED***
      hasKeys || (hasKeys = true);
      selected[key.substring(path.length)] = fields[key];
    ***REMOVED***
  ***REMOVED***

  return hasKeys && selected || undefined;
***REMOVED***

/*!
 * Module exports.
 */

module.exports = DocumentArray;
