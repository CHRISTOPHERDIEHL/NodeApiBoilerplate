/*!
 * Module dependencies.
 */

var SchemaType = require('../schematype');
var CastError = SchemaType.CastError;
var Types = ***REMOVED***
  Boolean: require('./boolean'),
  Date: require('./date'),
  Number: require('./number'),
  String: require('./string'),
  ObjectId: require('./objectid'),
  Buffer: require('./buffer')
***REMOVED***;
var MongooseArray = require('../types').Array;
var EmbeddedDoc = require('../types').Embedded;
var Mixed = require('./mixed');
var cast = require('../cast');
var util = require('util');
var utils = require('../utils');
var castToNumber = require('./operators/helpers').castToNumber;
var geospatial = require('./operators/geospatial');

/**
 * Array SchemaType constructor
 *
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***SchemaType***REMOVED*** cast
 * @param ***REMOVED***Object***REMOVED*** options
 * @inherits SchemaType
 * @api public
 */

function SchemaArray(key, cast, options, schemaOptions) ***REMOVED***
  var typeKey = 'type';
  if (schemaOptions && schemaOptions.typeKey) ***REMOVED***
    typeKey = schemaOptions.typeKey;
  ***REMOVED***

  if (cast) ***REMOVED***
    var castOptions = ***REMOVED******REMOVED***;

    if (utils.getFunctionName(cast.constructor) === 'Object') ***REMOVED***
      if (cast[typeKey]) ***REMOVED***
        // support ***REMOVED*** type: Woot ***REMOVED***
        castOptions = utils.clone(cast); // do not alter user arguments
        delete castOptions[typeKey];
        cast = cast[typeKey];
      ***REMOVED*** else ***REMOVED***
        cast = Mixed;
      ***REMOVED***
    ***REMOVED***

    // support ***REMOVED*** type: 'String' ***REMOVED***
    var name = typeof cast === 'string'
        ? cast
        : utils.getFunctionName(cast);

    var caster = name in Types
        ? Types[name]
        : cast;

    this.casterConstructor = caster;
    if (typeof caster === 'function') ***REMOVED***
      this.caster = new caster(null, castOptions);
    ***REMOVED*** else ***REMOVED***
      this.caster = caster;
    ***REMOVED***

    if (!(this.caster instanceof EmbeddedDoc)) ***REMOVED***
      this.caster.path = key;
    ***REMOVED***
  ***REMOVED***

  SchemaType.call(this, key, options, 'Array');

  var defaultArr;
  var fn;

  if (this.defaultValue != null) ***REMOVED***
    defaultArr = this.defaultValue;
    fn = typeof defaultArr === 'function';
  ***REMOVED***

  if (!('defaultValue' in this) || this.defaultValue !== void 0) ***REMOVED***
    this.default(function() ***REMOVED***
      var arr = [];
      if (fn) ***REMOVED***
        arr = defaultArr();
      ***REMOVED*** else if (defaultArr != null) ***REMOVED***
        arr = defaultArr;
      ***REMOVED***
      // Leave it up to `cast()` to convert the array
      return arr;
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
SchemaArray.schemaName = 'Array';

/*!
 * Inherits from SchemaType.
 */
SchemaArray.prototype = Object.create(SchemaType.prototype);
SchemaArray.prototype.constructor = SchemaArray;

/**
 * Check if the given value satisfies a required validator. The given value
 * must be not null nor undefined, and have a non-zero length.
 *
 * @param ***REMOVED***Any***REMOVED*** value
 * @return ***REMOVED***Boolean***REMOVED***
 * @api public
 */

SchemaArray.prototype.checkRequired = function(value) ***REMOVED***
  return !!(value && value.length);
***REMOVED***;

/**
 * Overrides the getters application for the population special-case
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @param ***REMOVED***Object***REMOVED*** scope
 * @api private
 */

SchemaArray.prototype.applyGetters = function(value, scope) ***REMOVED***
  if (this.caster.options && this.caster.options.ref) ***REMOVED***
    // means the object id was populated
    return value;
  ***REMOVED***

  return SchemaType.prototype.applyGetters.call(this, value, scope);
***REMOVED***;

/**
 * Casts values for set().
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @param ***REMOVED***Document***REMOVED*** doc document that triggers the casting
 * @param ***REMOVED***Boolean***REMOVED*** init whether this is an initialization cast
 * @api private
 */

SchemaArray.prototype.cast = function(value, doc, init) ***REMOVED***
  if (Array.isArray(value)) ***REMOVED***
    if (!value.length && doc) ***REMOVED***
      var indexes = doc.schema.indexedPaths();

      for (var i = 0, l = indexes.length; i < l; ++i) ***REMOVED***
        var pathIndex = indexes[i][0][this.path];
        if (pathIndex === '2dsphere' || pathIndex === '2d') ***REMOVED***
          return;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (!(value && value.isMongooseArray)) ***REMOVED***
      value = new MongooseArray(value, this.path, doc);
    ***REMOVED*** else if (value && value.isMongooseArray) ***REMOVED***
      // We need to create a new array, otherwise change tracking will
      // update the old doc (gh-4449)
      value = new MongooseArray(value, this.path, doc);
    ***REMOVED***

    if (this.caster) ***REMOVED***
      try ***REMOVED***
        for (i = 0, l = value.length; i < l; i++) ***REMOVED***
          value[i] = this.caster.cast(value[i], doc, init);
        ***REMOVED***
      ***REMOVED*** catch (e) ***REMOVED***
        // rethrow
        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);
      ***REMOVED***
    ***REMOVED***

    return value;
  ***REMOVED***
  // gh-2442: if we're loading this from the db and its not an array, mark
  // the whole array as modified.
  if (!!doc && !!init) ***REMOVED***
    doc.markModified(this.path);
  ***REMOVED***
  return this.cast([value], doc, init);
***REMOVED***;

/**
 * Casts values for queries.
 *
 * @param ***REMOVED***String***REMOVED*** $conditional
 * @param ***REMOVED***any***REMOVED*** [value]
 * @api private
 */

SchemaArray.prototype.castForQuery = function($conditional, value) ***REMOVED***
  var handler,
      val;

  if (arguments.length === 2) ***REMOVED***
    handler = this.$conditionalHandlers[$conditional];

    if (!handler) ***REMOVED***
      throw new Error('Can\'t use ' + $conditional + ' with Array.');
    ***REMOVED***

    val = handler.call(this, value);
  ***REMOVED*** else ***REMOVED***
    val = $conditional;
    var proto = this.casterConstructor.prototype;
    var method = proto && (proto.castForQuery || proto.cast);
    var caster = this.caster;

    if (Array.isArray(val)) ***REMOVED***
      val = val.map(function(v) ***REMOVED***
        if (utils.isObject(v) && v.$elemMatch) ***REMOVED***
          return v;
        ***REMOVED***
        if (method) ***REMOVED***
          v = method.call(caster, v);
        ***REMOVED***
        return v;
      ***REMOVED***);
    ***REMOVED*** else if (method) ***REMOVED***
      val = method.call(caster, val);
    ***REMOVED***
  ***REMOVED***

  return val;
***REMOVED***;

function cast$all(val) ***REMOVED***
  if (!Array.isArray(val)) ***REMOVED***
    val = [val];
  ***REMOVED***

  val = val.map(function(v) ***REMOVED***
    if (utils.isObject(v)) ***REMOVED***
      var o = ***REMOVED******REMOVED***;
      o[this.path] = v;
      return cast(this.casterConstructor.schema, o)[this.path];
    ***REMOVED***
    return v;
  ***REMOVED***, this);

  return this.castForQuery(val);
***REMOVED***

function cast$elemMatch(val) ***REMOVED***
  var keys = Object.keys(val);
  var numKeys = keys.length;
  var key;
  var value;
  for (var i = 0; i < numKeys; ++i) ***REMOVED***
    key = keys[i];
    value = val[key];
    if (key.indexOf('$') === 0 && value) ***REMOVED***
      val[key] = this.castForQuery(key, value);
    ***REMOVED***
  ***REMOVED***

  return cast(this.casterConstructor.schema, val);
***REMOVED***

var handle = SchemaArray.prototype.$conditionalHandlers = ***REMOVED******REMOVED***;

handle.$all = cast$all;
handle.$options = String;
handle.$elemMatch = cast$elemMatch;
handle.$geoIntersects = geospatial.cast$geoIntersects;
handle.$or = handle.$and = function(val) ***REMOVED***
  if (!Array.isArray(val)) ***REMOVED***
    throw new TypeError('conditional $or/$and require array');
  ***REMOVED***

  var ret = [];
  for (var i = 0; i < val.length; ++i) ***REMOVED***
    ret.push(cast(this.casterConstructor.schema, val[i]));
  ***REMOVED***

  return ret;
***REMOVED***;

handle.$near =
handle.$nearSphere = geospatial.cast$near;

handle.$within =
handle.$geoWithin = geospatial.cast$within;

handle.$size =
handle.$minDistance =
handle.$maxDistance = castToNumber;

handle.$eq =
handle.$gt =
handle.$gte =
handle.$in =
handle.$lt =
handle.$lte =
handle.$ne =
handle.$nin =
handle.$regex = SchemaArray.prototype.castForQuery;

/*!
 * Module exports.
 */

module.exports = SchemaArray;
