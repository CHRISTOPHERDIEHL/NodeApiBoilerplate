'use strict';

/*!
 * Module dependencies.
 */

var SchemaType = require('../schematype');
var Subdocument = require('../types/subdocument');
var castToNumber = require('./operators/helpers').castToNumber;
var geospatial = require('./operators/geospatial');

module.exports = Embedded;

/**
 * Sub-schema schematype constructor
 *
 * @param ***REMOVED***Schema***REMOVED*** schema
 * @param ***REMOVED***String***REMOVED*** key
 * @param ***REMOVED***Object***REMOVED*** options
 * @inherits SchemaType
 * @api public
 */

function Embedded(schema, path, options) ***REMOVED***
  var _embedded = function(value, path, parent) ***REMOVED***
    var _this = this;
    Subdocument.apply(this, arguments);
    this.$parent = parent;
    if (parent) ***REMOVED***
      parent.on('save', function() ***REMOVED***
        _this.emit('save', _this);
      ***REMOVED***);

      parent.on('isNew', function(val) ***REMOVED***
        _this.isNew = val;
        _this.emit('isNew', val);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;
  _embedded.prototype = Object.create(Subdocument.prototype);
  _embedded.prototype.$__setSchema(schema);
  _embedded.schema = schema;
  _embedded.$isSingleNested = true;
  _embedded.prototype.$basePath = path;
  _embedded.prototype.toBSON = function() ***REMOVED***
    return this.toObject(***REMOVED***
      transform: false,
      retainKeyOrder: schema.options.retainKeyOrder,
      virtuals: false
    ***REMOVED***);
  ***REMOVED***;

  // apply methods
  for (var i in schema.methods) ***REMOVED***
    _embedded.prototype[i] = schema.methods[i];
  ***REMOVED***

  // apply statics
  for (i in schema.statics) ***REMOVED***
    _embedded[i] = schema.statics[i];
  ***REMOVED***

  this.caster = _embedded;
  this.schema = schema;
  this.$isSingleNested = true;
  SchemaType.call(this, path, options, 'Embedded');
***REMOVED***

Embedded.prototype = Object.create(SchemaType.prototype);

/**
 * Special case for when users use a common location schema to represent
 * locations for use with $geoWithin.
 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
 *
 * @param ***REMOVED***Object***REMOVED*** val
 * @api private
 */

Embedded.prototype.$conditionalHandlers.$geoWithin = function(val) ***REMOVED***
  return ***REMOVED*** $geometry: this.castForQuery(val.$geometry) ***REMOVED***;
***REMOVED***;

/*!
 * ignore
 */

Embedded.prototype.$conditionalHandlers.$near =
Embedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;

Embedded.prototype.$conditionalHandlers.$within =
Embedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;

Embedded.prototype.$conditionalHandlers.$geoIntersects =
  geospatial.cast$geoIntersects;

Embedded.prototype.$conditionalHandlers.$minDistance = castToNumber;
Embedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;

/**
 * Casts contents
 *
 * @param ***REMOVED***Object***REMOVED*** value
 * @api private
 */

Embedded.prototype.cast = function(val, doc, init) ***REMOVED***
  if (val && val.$isSingleNested) ***REMOVED***
    return val;
  ***REMOVED***
  var subdoc = new this.caster(void 0, doc ? doc.$__.selected : void 0, doc);
  if (init) ***REMOVED***
    subdoc.init(val);
  ***REMOVED*** else ***REMOVED***
    subdoc.set(val, undefined, true);
  ***REMOVED***
  return subdoc;
***REMOVED***;

/**
 * Casts contents for query
 *
 * @param ***REMOVED***string***REMOVED*** [$conditional] optional query operator (like `$eq` or `$in`)
 * @param ***REMOVED***any***REMOVED*** value
 * @api private
 */

Embedded.prototype.castForQuery = function($conditional, val) ***REMOVED***
  var handler;
  if (arguments.length === 2) ***REMOVED***
    handler = this.$conditionalHandlers[$conditional];
    if (!handler) ***REMOVED***
      throw new Error('Can\'t use ' + $conditional);
    ***REMOVED***
    return handler.call(this, val);
  ***REMOVED***
  val = $conditional;
  if (val == null) ***REMOVED***
    return val;
  ***REMOVED***

  return new this.caster(val);
***REMOVED***;

/**
 * Async validation on this single nested doc.
 *
 * @api private
 */

Embedded.prototype.doValidate = function(value, fn, scope) ***REMOVED***
  SchemaType.prototype.doValidate.call(this, value, function(error) ***REMOVED***
    if (error) ***REMOVED***
      return fn(error);
    ***REMOVED***
    if (!value) ***REMOVED***
      return fn(null);
    ***REMOVED***
    value.validate(fn, ***REMOVED***__noPromise: true***REMOVED***);
  ***REMOVED***, scope);
***REMOVED***;

/**
 * Synchronously validate this single nested doc
 *
 * @api private
 */

Embedded.prototype.doValidateSync = function(value, scope) ***REMOVED***
  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
  if (schemaTypeError) ***REMOVED***
    return schemaTypeError;
  ***REMOVED***
  if (!value) ***REMOVED***
    return;
  ***REMOVED***
  return value.validateSync();
***REMOVED***;
