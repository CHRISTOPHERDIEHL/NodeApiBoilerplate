/*!
 * Module dependencies
 */

var util = require('util');
var utils = require('./utils');
var PromiseProvider = require('./promise_provider');
var Query = require('./query');
var read = Query.prototype.read;

/**
 * Aggregate constructor used for building aggregation pipelines.
 *
 * ####Example:
 *
 *     new Aggregate();
 *     new Aggregate(***REMOVED*** $project: ***REMOVED*** a: 1, b: 1 ***REMOVED*** ***REMOVED***);
 *     new Aggregate(***REMOVED*** $project: ***REMOVED*** a: 1, b: 1 ***REMOVED*** ***REMOVED***, ***REMOVED*** $skip: 5 ***REMOVED***);
 *     new Aggregate([***REMOVED*** $project: ***REMOVED*** a: 1, b: 1 ***REMOVED*** ***REMOVED***, ***REMOVED*** $skip: 5 ***REMOVED***]);
 *
 * Returned when calling Model.aggregate().
 *
 * ####Example:
 *
 *     Model
 *     .aggregate(***REMOVED*** $match: ***REMOVED*** age: ***REMOVED*** $gte: 21 ***REMOVED******REMOVED******REMOVED***)
 *     .unwind('tags')
 *     .exec(callback)
 *
 * ####Note:
 *
 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
 * - Requires MongoDB >= 2.1
 * - Mongoose does **not** cast pipeline stages. `new Aggregate(***REMOVED*** $match: ***REMOVED*** _id: '00000000000000000000000a' ***REMOVED*** ***REMOVED***);` will not work unless `_id` is a string in the database. Use `new Aggregate(***REMOVED*** $match: ***REMOVED*** _id: mongoose.Types.ObjectId('00000000000000000000000a') ***REMOVED*** ***REMOVED***);` instead.
 *
 * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/
 * @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate
 * @param ***REMOVED***Object|Array***REMOVED*** [ops] aggregation operator(s) or operator array
 * @api public
 */

function Aggregate() ***REMOVED***
  this._pipeline = [];
  this._model = undefined;
  this.options = undefined;

  if (arguments.length === 1 && util.isArray(arguments[0])) ***REMOVED***
    this.append.apply(this, arguments[0]);
  ***REMOVED*** else ***REMOVED***
    this.append.apply(this, arguments);
  ***REMOVED***
***REMOVED***

/**
 * Binds this aggregate to a model.
 *
 * @param ***REMOVED***Model***REMOVED*** model the model to which the aggregate is to be bound
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

Aggregate.prototype.model = function(model) ***REMOVED***
  this._model = model;
  return this;
***REMOVED***;

/**
 * Appends new operators to this aggregate pipeline
 *
 * ####Examples:
 *
 *     aggregate.append(***REMOVED*** $project: ***REMOVED*** field: 1 ***REMOVED******REMOVED***, ***REMOVED*** $limit: 2 ***REMOVED***);
 *
 *     // or pass an array
 *     var pipeline = [***REMOVED*** $match: ***REMOVED*** daw: 'Logic Audio X' ***REMOVED******REMOVED*** ];
 *     aggregate.append(pipeline);
 *
 * @param ***REMOVED***Object***REMOVED*** ops operator(s) to append
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

Aggregate.prototype.append = function() ***REMOVED***
  var args = (arguments.length === 1 && util.isArray(arguments[0]))
      ? arguments[0]
      : utils.args(arguments);

  if (!args.every(isOperator)) ***REMOVED***
    throw new Error('Arguments must be aggregate pipeline operators');
  ***REMOVED***

  this._pipeline = this._pipeline.concat(args);

  return this;
***REMOVED***;

/**
 * Appends a new $project operator to this aggregate pipeline.
 *
 * Mongoose query [selection syntax](#query_Query-select) is also supported.
 *
 * ####Examples:
 *
 *     // include a, include b, exclude _id
 *     aggregate.project("a b -_id");
 *
 *     // or you may use object notation, useful when
 *     // you have keys already prefixed with a "-"
 *     aggregate.project(***REMOVED***a: 1, b: 1, _id: 0***REMOVED***);
 *
 *     // reshaping documents
 *     aggregate.project(***REMOVED***
 *         newField: '$b.nested'
 *       , plusTen: ***REMOVED*** $add: ['$val', 10]***REMOVED***
 *       , sub: ***REMOVED***
 *            name: '$a'
 *         ***REMOVED***
 *     ***REMOVED***)
 *
 *     // etc
 *     aggregate.project(***REMOVED*** salary_k: ***REMOVED*** $divide: [ "$salary", 1000 ] ***REMOVED*** ***REMOVED***);
 *
 * @param ***REMOVED***Object|String***REMOVED*** arg field specification
 * @see projection http://docs.mongodb.org/manual/reference/aggregation/project/
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

Aggregate.prototype.project = function(arg) ***REMOVED***
  var fields = ***REMOVED******REMOVED***;

  if (typeof arg === 'object' && !util.isArray(arg)) ***REMOVED***
    Object.keys(arg).forEach(function(field) ***REMOVED***
      fields[field] = arg[field];
    ***REMOVED***);
  ***REMOVED*** else if (arguments.length === 1 && typeof arg === 'string') ***REMOVED***
    arg.split(/\s+/).forEach(function(field) ***REMOVED***
      if (!field) ***REMOVED***
        return;
      ***REMOVED***
      var include = field[0] === '-' ? 0 : 1;
      if (include === 0) ***REMOVED***
        field = field.substring(1);
      ***REMOVED***
      fields[field] = include;
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    throw new Error('Invalid project() argument. Must be string or object');
  ***REMOVED***

  return this.append(***REMOVED***$project: fields***REMOVED***);
***REMOVED***;

/**
 * Appends a new custom $group operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.group(***REMOVED*** _id: "$department" ***REMOVED***);
 *
 * @see $group http://docs.mongodb.org/manual/reference/aggregation/group/
 * @method group
 * @memberOf Aggregate
 * @param ***REMOVED***Object***REMOVED*** arg $group operator contents
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

/**
 * Appends a new custom $match operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.match(***REMOVED*** department: ***REMOVED*** $in: [ "sales", "engineering" ***REMOVED*** ***REMOVED*** ***REMOVED***);
 *
 * @see $match http://docs.mongodb.org/manual/reference/aggregation/match/
 * @method match
 * @memberOf Aggregate
 * @param ***REMOVED***Object***REMOVED*** arg $match operator contents
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

/**
 * Appends a new $skip operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.skip(10);
 *
 * @see $skip http://docs.mongodb.org/manual/reference/aggregation/skip/
 * @method skip
 * @memberOf Aggregate
 * @param ***REMOVED***Number***REMOVED*** num number of records to skip before next stage
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

/**
 * Appends a new $limit operator to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.limit(10);
 *
 * @see $limit http://docs.mongodb.org/manual/reference/aggregation/limit/
 * @method limit
 * @memberOf Aggregate
 * @param ***REMOVED***Number***REMOVED*** num maximum number of records to pass to the next stage
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

/**
 * Appends a new $geoNear operator to this aggregate pipeline.
 *
 * ####NOTE:
 *
 * **MUST** be used as the first operator in the pipeline.
 *
 * ####Examples:
 *
 *     aggregate.near(***REMOVED***
 *       near: [40.724, -73.997],
 *       distanceField: "dist.calculated", // required
 *       maxDistance: 0.008,
 *       query: ***REMOVED*** type: "public" ***REMOVED***,
 *       includeLocs: "dist.location",
 *       uniqueDocs: true,
 *       num: 5
 *     ***REMOVED***);
 *
 * @see $geoNear http://docs.mongodb.org/manual/reference/aggregation/geoNear/
 * @method near
 * @memberOf Aggregate
 * @param ***REMOVED***Object***REMOVED*** parameters
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

Aggregate.prototype.near = function(arg) ***REMOVED***
  var op = ***REMOVED******REMOVED***;
  op.$geoNear = arg;
  return this.append(op);
***REMOVED***;

/*!
 * define methods
 */

'group match skip limit out'.split(' ').forEach(function($operator) ***REMOVED***
  Aggregate.prototype[$operator] = function(arg) ***REMOVED***
    var op = ***REMOVED******REMOVED***;
    op['$' + $operator] = arg;
    return this.append(op);
  ***REMOVED***;
***REMOVED***);

/**
 * Appends new custom $unwind operator(s) to this aggregate pipeline.
 *
 * Note that the `$unwind` operator requires the path name to start with '$'.
 * Mongoose will prepend '$' if the specified field doesn't start '$'.
 *
 * ####Examples:
 *
 *     aggregate.unwind("tags");
 *     aggregate.unwind("a", "b", "c");
 *
 * @see $unwind http://docs.mongodb.org/manual/reference/aggregation/unwind/
 * @param ***REMOVED***String***REMOVED*** fields the field(s) to unwind
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

Aggregate.prototype.unwind = function() ***REMOVED***
  var args = utils.args(arguments);

  var res = [];
  for (var i = 0; i < args.length; ++i) ***REMOVED***
    var arg = args[i];
    if (arg && typeof arg === 'object') ***REMOVED***
      res.push(***REMOVED*** $unwind: arg ***REMOVED***);
    ***REMOVED*** else if (typeof arg === 'string') ***REMOVED***
      res.push(***REMOVED***
        $unwind: (arg && arg.charAt(0) === '$') ? arg : '$' + arg
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      throw new Error('Invalid arg "' + arg + '" to unwind(), ' +
        'must be string or object');
    ***REMOVED***
  ***REMOVED***

  return this.append.apply(this, res);
***REMOVED***;

/**
 * Appends new custom $lookup operator(s) to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.lookup(***REMOVED*** from: 'users', localField: 'userId', foreignField: '_id', as: 'users' ***REMOVED***);
 *
 * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup
 * @param ***REMOVED***Object***REMOVED*** options to $lookup as described in the above link
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

Aggregate.prototype.lookup = function(options) ***REMOVED***
  return this.append(***REMOVED***$lookup: options***REMOVED***);
***REMOVED***;

/**
 * Appends new custom $sample operator(s) to this aggregate pipeline.
 *
 * ####Examples:
 *
 *     aggregate.sample(3); // Add a pipeline that picks 3 random documents
 *
 * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample
 * @param ***REMOVED***Number***REMOVED*** size number of random documents to pick
 * @return ***REMOVED***Aggregate***REMOVED***
 * @api public
 */

Aggregate.prototype.sample = function(size) ***REMOVED***
  return this.append(***REMOVED***$sample: ***REMOVED***size: size***REMOVED******REMOVED***);
***REMOVED***;

/**
 * Appends a new $sort operator to this aggregate pipeline.
 *
 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
 *
 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
 *
 * ####Examples:
 *
 *     // these are equivalent
 *     aggregate.sort(***REMOVED*** field: 'asc', test: -1 ***REMOVED***);
 *     aggregate.sort('field -test');
 *
 * @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/
 * @param ***REMOVED***Object|String***REMOVED*** arg
 * @return ***REMOVED***Aggregate***REMOVED*** this
 * @api public
 */

Aggregate.prototype.sort = function(arg) ***REMOVED***
  // TODO refactor to reuse the query builder logic

  var sort = ***REMOVED******REMOVED***;

  if (arg.constructor.name === 'Object') ***REMOVED***
    var desc = ['desc', 'descending', -1];
    Object.keys(arg).forEach(function(field) ***REMOVED***
      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
    ***REMOVED***);
  ***REMOVED*** else if (arguments.length === 1 && typeof arg === 'string') ***REMOVED***
    arg.split(/\s+/).forEach(function(field) ***REMOVED***
      if (!field) ***REMOVED***
        return;
      ***REMOVED***
      var ascend = field[0] === '-' ? -1 : 1;
      if (ascend === -1) ***REMOVED***
        field = field.substring(1);
      ***REMOVED***
      sort[field] = ascend;
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    throw new TypeError('Invalid sort() argument. Must be a string or object.');
  ***REMOVED***

  return this.append(***REMOVED***$sort: sort***REMOVED***);
***REMOVED***;

/**
 * Sets the readPreference option for the aggregation query.
 *
 * ####Example:
 *
 *     Model.aggregate(..).read('primaryPreferred').exec(callback)
 *
 * @param ***REMOVED***String***REMOVED*** pref one of the listed preference options or their aliases
 * @param ***REMOVED***Array***REMOVED*** [tags] optional tags for this query
 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
 */

Aggregate.prototype.read = function(pref, tags) ***REMOVED***
  if (!this.options) ***REMOVED***
    this.options = ***REMOVED******REMOVED***;
  ***REMOVED***
  read.call(this, pref, tags);
  return this;
***REMOVED***;

/**
 * Execute the aggregation with explain
 *
 * ####Example:
 *
 *     Model.aggregate(..).explain(callback)
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Promise***REMOVED***
 */

Aggregate.prototype.explain = function(callback) ***REMOVED***
  var _this = this;
  var Promise = PromiseProvider.get();
  return new Promise.ES6(function(resolve, reject) ***REMOVED***
    if (!_this._pipeline.length) ***REMOVED***
      var err = new Error('Aggregate has empty pipeline');
      if (callback) ***REMOVED***
        callback(err);
      ***REMOVED***
      reject(err);
      return;
    ***REMOVED***

    prepareDiscriminatorPipeline(_this);

    _this._model
        .collection
        .aggregate(_this._pipeline, _this.options || ***REMOVED******REMOVED***)
        .explain(function(error, result) ***REMOVED***
          if (error) ***REMOVED***
            if (callback) ***REMOVED***
              callback(error);
            ***REMOVED***
            reject(error);
            return;
          ***REMOVED***

          if (callback) ***REMOVED***
            callback(null, result);
          ***REMOVED***
          resolve(result);
        ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)
 *
 * ####Example:
 *
 *     Model.aggregate(..).allowDiskUse(true).exec(callback)
 *
 * @param ***REMOVED***Boolean***REMOVED*** value Should tell server it can use hard drive to store data during aggregation.
 * @param ***REMOVED***Array***REMOVED*** [tags] optional tags for this query
 * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/
 */

Aggregate.prototype.allowDiskUse = function(value) ***REMOVED***
  if (!this.options) ***REMOVED***
    this.options = ***REMOVED******REMOVED***;
  ***REMOVED***
  this.options.allowDiskUse = value;
  return this;
***REMOVED***;

/**
 * Sets the cursor option option for the aggregation query (ignored for < 2.6.0).
 * Note the different syntax below: .exec() returns a cursor object, and no callback
 * is necessary.
 *
 * ####Example:
 *
 *     var cursor = Model.aggregate(..).cursor(***REMOVED*** batchSize: 1000 ***REMOVED***).exec();
 *     cursor.each(function(error, doc) ***REMOVED***
 *       // use doc
 *     ***REMOVED***);
 *
 * @param ***REMOVED***Object***REMOVED*** options set the cursor batch size
 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html
 */

Aggregate.prototype.cursor = function(options) ***REMOVED***
  if (!this.options) ***REMOVED***
    this.options = ***REMOVED******REMOVED***;
  ***REMOVED***
  this.options.cursor = options || ***REMOVED******REMOVED***;
  return this;
***REMOVED***;

/**
 * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#addCursorFlag)
 *
 * ####Example:
 *
 *     var cursor = Model.aggregate(..).cursor(***REMOVED*** batchSize: 1000 ***REMOVED***).exec();
 *     cursor.each(function(error, doc) ***REMOVED***
 *       // use doc
 *     ***REMOVED***);
 *
 * @param ***REMOVED***String***REMOVED*** flag
 * @param ***REMOVED***Boolean***REMOVED*** value
 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#addCursorFlag
 */

Aggregate.prototype.addCursorFlag = function(flag, value) ***REMOVED***
  if (!this.options) ***REMOVED***
    this.options = ***REMOVED******REMOVED***;
  ***REMOVED***
  this.options[flag] = value;
  return this;
***REMOVED***;

/**
 * Executes the aggregate pipeline on the currently bound Model.
 *
 * ####Example:
 *
 *     aggregate.exec(callback);
 *
 *     // Because a promise is returned, the `callback` is optional.
 *     var promise = aggregate.exec();
 *     promise.then(..);
 *
 * @see Promise #promise_Promise
 * @param ***REMOVED***Function***REMOVED*** [callback]
 * @return ***REMOVED***Promise***REMOVED***
 * @api public
 */

Aggregate.prototype.exec = function(callback) ***REMOVED***
  if (!this._model) ***REMOVED***
    throw new Error('Aggregate not bound to any Model');
  ***REMOVED***
  var _this = this;
  var Promise = PromiseProvider.get();
  var options = utils.clone(this.options);

  if (options && options.cursor) ***REMOVED***
    if (options.cursor.async) ***REMOVED***
      delete options.cursor.async;
      return new Promise.ES6(function(resolve) ***REMOVED***
        if (!_this._model.collection.buffer) ***REMOVED***
          process.nextTick(function() ***REMOVED***
            var cursor = _this._model.collection.
            aggregate(_this._pipeline, options || ***REMOVED******REMOVED***);
            resolve(cursor);
            callback && callback(null, cursor);
          ***REMOVED***);
          return;
        ***REMOVED***
        _this._model.collection.emitter.once('queue', function() ***REMOVED***
          var cursor = _this._model.collection.
          aggregate(_this._pipeline, options || ***REMOVED******REMOVED***);
          resolve(cursor);
          callback && callback(null, cursor);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***
    return this._model.collection.
      aggregate(this._pipeline, this.options || ***REMOVED******REMOVED***);
  ***REMOVED***

  return new Promise.ES6(function(resolve, reject) ***REMOVED***
    if (!_this._pipeline.length) ***REMOVED***
      var err = new Error('Aggregate has empty pipeline');
      if (callback) ***REMOVED***
        callback(err);
      ***REMOVED***
      reject(err);
      return;
    ***REMOVED***

    prepareDiscriminatorPipeline(_this);

    _this._model
        .collection
        .aggregate(_this._pipeline, _this.options || ***REMOVED******REMOVED***, function(error, result) ***REMOVED***
          if (error) ***REMOVED***
            if (callback) ***REMOVED***
              callback(error);
            ***REMOVED***
            reject(error);
            return;
          ***REMOVED***

          if (callback) ***REMOVED***
            callback(null, result);
          ***REMOVED***
          resolve(result);
        ***REMOVED***);
  ***REMOVED***);
***REMOVED***;

/**
 * Provides promise for aggregate.
 *
 * ####Example:
 *
 *     Model.aggregate(..).then(successCallback, errorCallback);
 *
 * @see Promise #promise_Promise
 * @param ***REMOVED***Function***REMOVED*** [resolve] successCallback
 * @param ***REMOVED***Function***REMOVED*** [reject]  errorCallback
 * @return ***REMOVED***Promise***REMOVED***
 */
Aggregate.prototype.then = function(resolve, reject) ***REMOVED***
  return this.exec().then(resolve, reject);
***REMOVED***;

/*!
 * Helpers
 */

/**
 * Checks whether an object is likely a pipeline operator
 *
 * @param ***REMOVED***Object***REMOVED*** obj object to check
 * @return ***REMOVED***Boolean***REMOVED***
 * @api private
 */

function isOperator(obj) ***REMOVED***
  var k;

  if (typeof obj !== 'object') ***REMOVED***
    return false;
  ***REMOVED***

  k = Object.keys(obj);

  return k.length === 1 && k
          .some(function(key) ***REMOVED***
            return key[0] === '$';
          ***REMOVED***);
***REMOVED***

/*!
 * Adds the appropriate `$match` pipeline step to the top of an aggregate's
 * pipeline, should it's model is a non-root discriminator type. This is
 * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.
 *
 * @param ***REMOVED***Aggregate***REMOVED*** aggregate Aggregate to prepare
 */

function prepareDiscriminatorPipeline(aggregate) ***REMOVED***
  var schema = aggregate._model.schema,
      discriminatorMapping = schema && schema.discriminatorMapping;

  if (discriminatorMapping && !discriminatorMapping.isRoot) ***REMOVED***
    var originalPipeline = aggregate._pipeline,
        discriminatorKey = discriminatorMapping.key,
        discriminatorValue = discriminatorMapping.value;

    // If the first pipeline stage is a match and it doesn't specify a `__t`
    // key, add the discriminator key to it. This allows for potential
    // aggregation query optimizations not to be disturbed by this feature.
    if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) ***REMOVED***
      originalPipeline[0].$match[discriminatorKey] = discriminatorValue;
      // `originalPipeline` is a ref, so there's no need for
      // aggregate._pipeline = originalPipeline
    ***REMOVED*** else if (originalPipeline[0] && originalPipeline[0].$geoNear) ***REMOVED***
      originalPipeline[0].$geoNear.query =
          originalPipeline[0].$geoNear.query || ***REMOVED******REMOVED***;
      originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;
    ***REMOVED*** else ***REMOVED***
      var match = ***REMOVED******REMOVED***;
      match[discriminatorKey] = discriminatorValue;
      aggregate._pipeline = [***REMOVED***$match: match***REMOVED***].concat(originalPipeline);
    ***REMOVED***
  ***REMOVED***
***REMOVED***


/*!
 * Exports
 */

module.exports = Aggregate;
